/*! -- 
    Mojo JavaScript Library
    Copyright (C) 1996-2011 MicroStrategy Incorporated, All rights reserved. Confidential. 
-- */
var xmjd = mstrmojo && mstrmojo.descriptors;

/**
 * The global namespace for all project mojo objects and classes.
 *
 * @namespace
 */
var mstrmojo = {
    helpPath: function () {
        return (mstrApp.helpUrl || "../help/") + "MSTRWeb/WebHelp/Lang_" + (mstrApp.helpLocaleId || mstrApp.localeId) + "/Content/";
    },
    helpPathMobileAdmin: function () {
        return (mstrApp.helpUrl || "../help/") + "MobileAdmin/WebHelp/Lang_" + (mstrApp.helpLocaleId || mstrApp.localeId) + "/";
    },
    upgradeHelpPath: function () {
        return (mstrApp.upgradeHelpUrl || "../help/") + "WebHelp/Lang_" + (mstrApp.helpLocaleId || mstrApp.localeId) + "/Content/";
    },
    /**
     * <p>Descriptor store. </p>
     *
     * <p>This is a hash map keyed by descriptor key, and value is the localized string for the descriptor.</p>
     */
    descriptors: xmjd || {},

    /**
     * <p>Information about MSTR metadata.</p>
     *
     * @type {Object}
     */
    meta: {
        TP: "t",     // the key for a web object's type
        STP: "st"    // the key for a web object's sub-type
    },

    /**
     * A static empty function for use by classes to declare abstract methods.
     */
    emptyFn: function () {
    },

    /**
     * Generates tstid HTML attribute string
     * @param ob
     * @returns {string}
     */
    tstid: function (value) {
        var res;
        if (value) {
            if (typeof(value) === 'object') {
                res = value.tstid;
            } else {
                res = value;
            }
        }
        return res ? 'tstid="' + res + '"' : '';
    },
    /**
     * Returns a function that can be used as a placeholder for methods that must be overridden in subclasses.
     *
     * @return {Function}
     * @throws An error notifying the developer specifying which method needs to be overriden.
     */
    getMissingFn: function getMissingFn() {
        return function () {
            var n = this.scriptClass,
                i;

            try {
                for (i in this) {
                    // If we found the function,
                    if (this[i] === arguments.callee) {
                        n += "." + i;
                        break;
                    }
                }
            } catch (e) {
                // Swallow error and do nothing.
            }

            // Throw a new error specifying that we have an abstract method that was not implemented.
            throw new Error('Missing abstract method: ' + n);
        };
    },

    /**
     * <p>Get tick count in milliseconds</p>
     *
     * @returns {int} The number of milliseconds since beginning of epoch.
     */
    now: function now() {
        return new Date().getTime();
    },

    /**
     * <p>If true, indicates that the mstrmojo namespace spans multiple frames/windows.</p>
     *
     * @type {boolean}
     */
    usesFrames: false
};

(function () {

    /**
     * <p>Reference to the global context object, typically same as "window" in browsers, may be different
     * in other environments like Adobe AIR.</p>
     *
     * @type {window}
     */
    mstrmojo.global = /** @type {window} **/ (function () {
        var f = function () {
            return this;
        };
        return f.call(null);
    }());

    /**
     * <p>Stubs to be overridden by debug.js augmentation.
     */
    mstrmojo.dbg = mstrmojo.emptyFn;
    mstrmojo.dbg_stack = mstrmojo.emptyFn;
    mstrmojo.dbg_xhr = mstrmojo.emptyFn;
    mstrmojo.dbg_profile = mstrmojo.emptyFn;

    mstrmojo.debugBundles = (function () {
        // Debug bundles flags are stored in the debug flags at 4 bit.
        return (window.mstrConfig && (mstrConfig.debugFlags !== undefined) && ((mstrConfig.debugFlags & 4) > 0));
    })();

    /**
     * sub packages.
     */
    mstrmojo.platform = {};
    mstrmojo.prompt = {};
    mstrmojo.settings = {};

    /**
     * The namespace for the model classes.
     *
     * @namespace
     */
    mstrmojo.models = {
        /**
         * The namespace for datasets model class and utilities.
         *
         * @namespace
         */
        datasets: {},

        /**
         * The namespace for template data interfaces and utilities.
         *
         * @namespace
         */
        template: {}
    };

    /**
     * mstrmojo's UI component's namespace.
     *
     * @namespace
     */
    mstrmojo.ui = {
        /**
         * The namespace for common editor components.
         *
         * @namespace
         */
        editors: {
            /**
             * The namespace for common editor controls.
             *
             * @namespace
             */
            controls: {}
        },
        /**
         * The UX namespace for menus.
         *
         * @namespace
         */
        menus: {},

        /**
         * The path bar namespace.
         *
         * @namespace
         */
        pathbar: {}
    };

    /**
     * The mstrmojo namespace for preference related widgets.
     *
     * @namespace
     */
    mstrmojo.prefs = {};

    mstrmojo.ACL = {};
    mstrmojo.CMS = {};
    mstrmojo.storage = {};
    mstrmojo.maps = {};
    mstrmojo.maps.androidmap = {};
    mstrmojo.maps.jsmap = {};
    mstrmojo.graph = {};
    mstrmojo.IPA = {};
    mstrmojo.IPA.Monitors = {};
    mstrmojo.IPA.Alerts = {};
    mstrmojo.IPA.Environment = {};
    mstrmojo.IPA.Groups = {};
    mstrmojo.IPA.Heartbeat = {};
    mstrmojo.IPA.Managers = {};
    mstrmojo.sm = {};
    mstrmojo.sort = {};
    /**
     * The metric editor namespace.
     *
     * @namespace
     */
    mstrmojo.ME = {};
    /**
     * The Web Architect namespace.
     *
     * @namespace
     */
    mstrmojo.architect = {
        /**
         * The Web Architect namespace for UI components.
         *
         * @namespace
         */
        ui: {
            /**
             * The Web Architect namespace for UI editor components.
             *
             * @namespace
             */
            editors: {},

            /**
             * The Web Architect namespace for UI Panels
             *
             * @namespace
             */
            panels: {},

            /**
             * The Web Architect namespace for UI Factories
             *
             * @namespace
             */
            factories: {}
        },

        /**
         * The Web Architect namespace for model objects.
         *
         * @namespace
         */
        obj: {},

        /**
         * The Web Architect namespace for menus.
         *
         * @namespace
         */
        menu: {},

        /**
         * The Web Architect namespace for project management.
         *
         * @namespace
         */
        projectmanagement: {}
    };
    /**
     * The warehouse panel namespace.
     *
     * @namespace
     */
    mstrmojo.warehouse = {
        /**
         * The warehouse panel namespace for UI components.
         *
         * @namespace
         */
        ui: {
            /**
             * The warehouse namespace for UI editor components.
             *
             * @namespace
             */
            editors: {}
        },

        /**
         * The warehouse panel namespace for model objects.
         *
         * @namespace
         */
        obj: {},

        /**
         * The warehouse panel namespace for dbroles.
         *
         * @namespace
         */
        dbroles: {},

        /**
         * The Architect namespace for menus.
         *
         * @namespace
         */
        menu: {}
    };
    mstrmojo.plugins = {};
    mstrmojo.AS = {};
    mstrmojo.DI = {
        /**
         * DI Controllers
         */
        controller: {},

        /**
         * DI model
         */
        model: {},

        /**
         * DI widgets
         */
        ui: {
            /**
             * DI dialogs
             */
            dialogs: {}
        }
    };
    mstrmojo.Refine = {};
    /**
     * The Web QueryBuilder namespace.
     *
     * @namespace
     */
    mstrmojo.qb = {
        /**
         * The Web QueryBuilder namespace for Big Query.
         *
         * @namespace
         */
        bigquery: {},
        /**
         * The Web QueryBuilder namespace for Emma Single Source Table.
         *
         * @namespace
         */
        es: {},
        /**
         * The Web QueryBuilder namespace for MDX Source Table.
         *
         * @namespace
         */
        mdx: {},
        /**
         * The Web QueryBuilder namespace for context menu
         *
         * @namespace
         */
        menu: {},
        /**
         * The Web QueryBuilder namespace for SAPBO/OBIEE/COGNOS Source Table.
         *
         * @namespace
         */
        thirdParty: {}

    };

    mstrmojo.WH = {};
    mstrmojo.fe = {};
    mstrmojo.txEditor = {};
    mstrmojo.condTx = {};


    /**
     * The namespace to handle all the editors relating to threshold edits.
     *
     * @namespace
     */
    mstrmojo.threshold = {};

    /**
     * The Report Services Express Mode namespace.
     *
     * @namespace
     */
    mstrmojo.express = {
        /**
         * The Report Services Express Mode namespace for UI components.
         *
         * @namespace
         */
        ui: {}
    };

    /**
     * The Report Services namespace.
     *
     * @namespace
     */
    mstrmojo.rw = {
        /**
         * The namespace to host the RWD model specific class.
         *
         * @namespace
         */
        model: {},

        /**
         * The namespace to host the xtab specific classes for documents.
         *
         * @namespace
         */
        xtab: {}
    };

    /**
     * The common utilities namespace.
     *
     * @namespace
     */
    mstrmojo.util = {
        /**
         * The common utilities namespace for UI utilities.
         *
         * @namespace
         */
        ui: {}
    };

    /**
     * The Android namespace.
     *
     * @namespace
     */
    mstrmojo.android = {

        /**
         * Android controllers.
         *
         * @namespace
         */
        controllers: {},

        /**
         * Android factories.
         *
         * @namespace
         */
        factories: {},

        /**
         * Android input controls.
         *
         * @namespace
         */
        inputControls: {},

        /**
         * Android tablet specific namespace.
         *
         * @namespace
         */
        large: {
            /**
             * Android op controllers.
             *
             * @namespace
             */
            controllers: {},

            /**
             * Android tablet factories.
             *
             * @namespace
             */
            factories: {},

            /**
             * Android tablet UI controls.
             *
             * @namespace
             */
            ui: {}
        },

        /**
         * Android phone specific namespace.
         *
         * @namespace
         */
        medium: {
            /**
             * Android phone controllers.
             *
             * @namespace
             */
            controllers: {},

            /**
             * Android phone factories.
             *
             * @namespace
             */
            factories: {},

            /**
             * Android phone UI controls.
             *
             * @namespace
             */
            ui: {

                /**
                 * Android Native Navigation Bar.
                 *
                 * @namespace
                 */
                nativebar: {}
            }
        },

        /**
         * Android selectors.
         *
         * @namespace
         */
        selectors: {},

        /**
         * Common Android UI controls and mixins.
         *
         * @namespace
         */
        ui: {},

        /**
         * Android Native Dialog.
         *
         * @namespace
         */
        nativedialog: {}
    };

    /**
     * The HTML5 VI namespace.
     *
     * @namespace
     */
    mstrmojo.vi = {
        /**
         * The HTML5 VI namespace for application controllers.
         *
         * @namespace
         */
        controllers: {},

        /**
         * The HTML5 VI namespace for view, model and controller factories.
         */
        factories: {},

        /**
         * The HTML5 VI namespace for data models.
         *
         * @namespace
         */
        models: {
            /**
             * The HTML5 VI namespace for properties editor models.
             *
             * @namespace
             */
            editors: {}
        },

        /**
         * The HTML5 VI namespace for VI enumerations.
         *
         * @namespace
         */
        enums: {

        },

        /**
         * The HTML5 VI namespace for UI controls.
         *
         * @namespace
         */
        ui: {
            /**
             * The HTML5 VI namespace UI menus.
             *
             * @namespace
             */
            menus: {},

            /**
             * The HTML5 VI namespace for properties editor UI components.
             *
             * @namespace
             */
            editors: {
                /**
                 * The HTML5 VI namespace for filter editor.
                 *
                 * @namespace
                 */
                fe: {},
                cm: {},
                nlp: {}
            },

            /**
             * The HTML5 VI namespace for Report Services document UI controls.
             *
             * @namespace
             */
            rw: {
                /**
                 * The HTML5 VI namespace for Report Services document selector controls.
                 *
                 * @namespace
                 */
                selectors: {},

                /**
                 * The HTML5 VI namespace for Report Services specific Xtab classes.
                 */
                xtab: {}
            },

            /**
             * The HTML5 VI namespace for tab controls.
             *
             * @namespace
             */
            tabs: {},

            /**
             * The HTML5 VI namespace for Toolbar controls.
             *
             * @namespace
             */
            toolbars: {

            },

            /**
             * The HTML5 VI namespace for the Tutorial.
             *
             * @namespace
             */
            tutorial: {

            }
        },

        /**
         * The HTML5 VI namespace for VI visualization code.
         *
         * @namespace
         */
        viz: {},

        /**
         * The HTML5 VI namespace for VI utilities.
         *
         * @namespace
         */
        util: {}
    };

    /**
     * The MSTR OneTier namespace.
     *
     * @namespace
     */
    mstrmojo.onetier = {
        /**
         * The OneTier namespace for application controllers.
         *
         * @namespace
         */
        controllers: {},

        /**
         * The OneTier namespace for one tier specific classes.
         *
         * @namespace
         */
        vi: {
            /**
             * name space for access list settings for one tier
             */
            acl : {},
            /**
             * The OneTier UI namespace for the preferences editor.
             */
            prefs: {
                /**
                 * The OneTier Preferences Editor namespace for model classes.
                 *
                 * @namespace
                 */
                model: {}
            },

            /**
             * The OneTier namepsace for one-tier UI classes.
             */
            ui: {
                /**
                 * The onetier namespace for onetier tutorial classes.
                 */
                tutorial: {}
            }
        }
    };

    /**
     * The MSTR Config namespace.
     *
     * @namespace
     */
    mstrmojo.config = {
        /**
         * The config namespace for HTML5 VI specific config files.
         *
         * @namespace
         */
        vi: {},

        /**
         * The config namespace for OneTier specific config files.
         *
         * @namespace
         */
        onetier: {}
    };

    /**
     * The HTML charts namespace.
     *
     * @namespace
     */
    mstrmojo.chart = {
        /**
         * package for classes and functions that are common to more than one Chart type
         * @namespace
         */
        common: {
        },

        /**
         * package to hold various enumerations ported from C++ code
         * @namespace
         */
        enums: {},

        /**
         * classes for Chart model
         * @namespace
         */
        model: {

            /**
             * package to hold enumerations related to chart data model
             * @namespace
             */
            enums: {}
        }
    };

        /**
     * native android namespace
     */
    mstrmojo.nativeandroid = {}

    /**
     * GraphMatrix namespace
     * @namespace
     */
    mstrmojo.gm = {

    };

    /**
     * GraphMatrix namespace
     * @namespace
     */
    mstrmojo.ngm = {

    };

    /**
     * HeatMap namespace
     * @namespace
     */
    mstrmojo.heatmap = {
        vi: {}
    };

    /**
     * Network visualization namespace
     * @namespace
     */
    mstrmojo.netviz = {

    };

    /**
     * Image Layout visualization namespace
     * @namespace
     */
    mstrmojo.imagelayout = {

    };

    /**
     * KPI card visualization namespace
     * @namespace
     */
    mstrmojo.kpicard = {
        layout: {},
        editors: {}
    };

    // iPhone specific libraries.
    mstrmojo.iphone = {};

    // Windows Phone specific libraries.
    mstrmojo.winphone = {};

    // MSTRWeb related based code.
    mstrmojo.mstr = {
        search: {}
    };
    // MSTRWeb related UI component
    mstrmojo.mstr.ui = {};

    mstrmojo.gmaps = {
        basemap: {},
        graphic: {},
        geometry: {},
        layer: {
            svg: {},
            canvas: {},
            mapbox: {}
        }
    };
    mstrmojo.esrimap = {};
    mstrmojo.mapbox = {
        ui: {
            selectors: {}
        }
    };

    /**
     * The namespace for code used in the Mojo Example plugin page.
     *
     * @namespace
     */
    mstrmojo.examples = {};


    /**
     * The Home Page namespace.
     *
     * @namespace
     */
    mstrmojo.home = {
        /**
         * The Home namespace for application controllers.
         *
         * @namespace
         */
        controllers: {},

        /**
         * The Home namespace for data models.
         *
         * @namespace
         */
        models: { },

        views: { },

        /**
         * The Home namespace for UI controls.
         *
         * @namespace
         */
        ui: { }
    };


    /**
     * Namespace for Workstation specific code.
     * We suggest clearly separating Workstation-specific code from common logic
     * and avoiding "if workstation-specific then ..." in common logic.
     *
     * @namespace
     */
    mstrmojo.workstation = {
        /**
         * Namespace for page classes that can be used in Workstation embedded web view.
         *
         * @namespace
         */
        pages: {}
    };



    /**
     * <p>Alerts an error message to the user when errors are encountered.</p>
     *
     * @param {{name: string, message: string, fileName: string, lineNumber: string, sourceURL: string, line: int}} e The error object.
     * @param okFn, callback function to be triggered upon clicking the OK button
     */
    mstrmojo.err = function err(e, okFn) {
        // Default message
        var s = e.name + ': "' + e.message + '"';

        if (mstrmojo.debug) {
            if (e.fileName) {
                s += ' at\n    ' + e.fileName;
            }
            if (e.hasOwnProperty('lineNumber')) {
                s += ': ' + e.lineNumber;
            } else if (e.hasOwnProperty('line') && e.sourceURL) { //for webkit
                var a = e.sourceURL.split('/');
                s += '(' + a[a.length > 1 ? a.length - 1 : 0] + ':' + e.line + ')';
            }
        }

        // If console is available then output there as well.
        this.dbg(s);
        //this.dbg_stack();

        // Display to user.
        if (mstrmojo.Dialog) {
            // DE22547 replace mstrmojo.alert() with mstrmojo.error() because when the error message is too looooooooog,
            // it will make the alert window too long to close.
            mstrmojo.error({longDesc: e.message, code: e.code}, okFn, {title: e.name});
        } else {
            window.alert(s);
        }
    };

    /**
     * Displays a simple confirm message using the window.confirm method.
     *
     * @param {string} msg The message to display.
     *
     * @returns True is use pressed Ok button.
     */
    mstrmojo.confirm = function confirm(msg) {
        return window.confirm(msg);
    };

    /**
     * Displays a simple message to the user with a single 'Ok' button.
     *
     * @param {string} msg The message to display.
     */
    mstrmojo.alert = function alert(msg) {
        window.alert(msg);
    };

    /**
     * <p>Used to determine if the current browser can parse a function's body text.</p>
     *
     * @private
     */
    var canParseFuncs = !!(/return true/.test(String(function () {
        return true;
    })));

    /**
     * <p>Similar to {@link mstrmojo.hash.copy} in that it copies all of the members of a given source hash to another given destination hash, except that
     * it does NOT overwrite existing Functions in the destination.</p>
     *
     * <p>When there is a name collision between 2 functions, the destination receives a newly created wrapper function which
     * allows the overwriting function to call the pre-existing function with the reserved call "this._super()".</p>
     *
     * @param {Object} src The source object whose properties/values should be copied.
     * @param {Object=} dest An optional hash to receive the copied properties/values.  If this parameter is undefined, an empty hash will be used.
     *
     * @returns {Object} The modified destination hash.
     */
    mstrmojo.mixin = function mixin(src, dest) {
        if (src) {
            dest = dest || {};
            var funcCallsSuper = /this\.\_super/;

            /**
             * Utility function for adding _super functionality to methods.
             *
             * @param {Function} overwriting
             * @param {Function} inher
             *
             * @inner
             */
            var fnWrapMethod = function (overwriting, inher) {
                return function superwrap() {
                    var tmp = this._super;
                    this._super = inher;
                    var ret = overwriting.apply(this, arguments || []);
                    this._super = tmp;
                    return ret;
                };
            };

            // Optimization: temporarily remove the optional reserved "__onmixin__" property.
            var fnOnMixin = src.__onmixin__;
            if (fnOnMixin) {
                delete src.__onmixin__;
            }

            var n;
            for (n in src) {
                // Are we overwriting a function with a function? And if so, does the
                // overwriting function call "this._super"?
                if ((typeof src[n] === 'function') && (!canParseFuncs || funcCallsSuper.test(src[n]))) {
                    // Yes, we are subclassing a method with a new method that uses the
                    // "this._super" reserved keyword call to invoke the inherited method.  To support
                    // the reserved keyword, create a wrapper function which encapsulates both the
                    // overwriting method and the inherited method.
                    // Do this even if there is no this._super defined, because the wrapper is
                    // needed to reset this._super back to null; otherwise this._super would get
                    // stuck pointing at the bottom of the inheritance chain, causing an infinite loop there.
                    // For example, suppose the mixin has a method M that checks:
                    // "if (this._super) this._super()"
                    // If the base has no such method M, this._super is null.  So far so good. But now
                    // suppose second mixin is applied on top of the first, and the second mixin does
                    // have an overwriting method named M too, which calls "this._super()".
                    // A wrapper is made around the second M, setting this._super to the first M.
                    // Now after the first M is called, we must reset this._super to null, otherwise,
                    // the "if (this._super)" check in first M [see above] will return true, triggering
                    // an infinite loop!  So who will reset this._super to null when first M is called?
                    // Answer: the wrapper to the first M method, which we create here because even though
                    // first M has no super, its code still references this._super, and that's what matters.
                    dest[n] = fnWrapMethod(src[n], dest[n]);
                } else {
                    // We are not subclassing a method; just do a simple overwrite.
                    dest[n] = src[n];
                }
            }

            // Cleanup optimization.
            if (fnOnMixin) {
                src.__onmixin__ = fnOnMixin;
            }
        }
        return dest;
    };
}());

(function () {

    /**
     * <p>The XMLHTTPRequest object used to load files. Instantiated on-demand.</p>
     *
     * @private
     */
    var $XHR;

    /**
     * <p>Hash of FQCNs that are requested to load but fail.</p>
     *
     * <p>The hash is keyed by FQCN strings; each value is a Boolean (true).</p>
     */
    var $MISSING = {};

    var getApp = function() { return mstrmojo.global.mstrApp || {};},
        getJsRoot = function() { return getApp().jsRoot || "../javascript/";},
        getJsBundlesRoot = function() { return getJsRoot() + "bundles/";},
        getJsMojoRoot = function() { return getApp().jsMojoRoot || "../javascript/mojo/js/source/"; },
        getPluginRoot = function() { return getApp().pluginRoot || '../plugins/'; },
        getPluginMojoRoot = function() { return getApp().pluginMojoRoot || getJsMojoRoot(); },
        isIE = !!document.all;     // Don't use mstrmojo.dom here. Avoid dependencies on utilities.



    function getXHR() {
        // Instantiate XMLHTTPRequest using browser-specific techniques.
        // For IE, use new ActiveXObject(); for Mozilla, new XMLHttpRequest().
        $XHR = self.XMLHttpRequest ? new XMLHttpRequest() : (self.ActiveXObject ? new ActiveXObject("Microsoft.XMLHTTP") : null);
    }



    /**
     * <p>Encodes parameters for XHR transport.</p>
     *
     * @param {Object} params A hash containing parameter names and values.
     * @returns {String} The encoded parameter string.
     *
     * @returns {string} A URL of encoded parameters.
     *
     * @private
     */
    function encodeParams(params) {
        var x = -1,
            url = [],
            p;

        if (params) {
            for (p in params) {
                if (params.hasOwnProperty(p)) {
                    url[++x] = p + '=' + encodeURIComponent(params[p]);
                }
            }
        }

        return url.join('&');
    }

    /**
     * <p>Builds up the url with parameters is method == 'GET'.</p>
     *
     * @param {String} method The method for the xhr ('GET' or 'POST').
     * @param {String} baseUrl The url used for both GET and POST (excludes parameters in GET case).
     * @param {Object} [params] The parameters for this request.
     *
     * @returns {string} The url built from the baseUrl and params.
     *
     * @private
     */
    function appendUrlParams(method, baseUrl, params) {
        if (method !== 'GET' || !params) {
            return baseUrl;
        }

        return baseUrl + '?' + encodeParams(params);
    }

    function syncXHR(method, baseUrl, params) {
        var result = null;

        // Make sure it's uppercase for comparisons.
        method = method.toUpperCase();
        if (!$XHR) {
            getXHR();
        }
        if ($XHR) {
            try {
                var m = null,
                    app = window.mstrApp;

                if (window.microstrategy !== undefined && microstrategy) {
                    m = microstrategy;
                }

                // Set default values.
                params.taskContentType = params.taskContentType || 'json';
                params.taskEnv = 'xhr';
                params.xts = mstrmojo.now();

                params = mstrmojo.addCSRFTokenToTaskParams(params);

                //persisted task params
                var ptp = (app && app.persistTaskParams) || (m && m.persistParams);
                if (ptp) {
                    mstrmojo.requiresCls("mstrmojo.hash");
                    mstrmojo.hash.copy(ptp, params);
                }

                $XHR.open(method, appendUrlParams(method, baseUrl, params), false);
                $XHR.setRequestHeader('X-Requested-With', 'XMLHttpRequest');

                if (method !== 'POST') {
                    params = null;
                } else {
                    params = encodeParams(params);
                    $XHR.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
                }

                $XHR.send(params);
                // Retrieve responseText. If successful, status will be 200 (HTTP) or 0 (file://).
                result = $XHR.responseText || null;
            } catch (localerr) {
                if (window.console) {
                    window.console.log(localerr);
                }
            }
        }
        return result;
    }

    /**
     * <p>Loads a given javascript file path synchronously via XmlHttpRequest, then tests if load succeeded by
     * performing a null-check on a given expression.</p>
     *
     * @param {String} file Path + name of the file to load (example: "/javascript/foo.js").
     * @param {String} [nullCheck] JavaScript expression for null-check after the file is loaded.
     * @returns {Boolean} true if the given file is loaded successfully and, optionally, if the given
     * expression does not evaluate to null after the file is loaded; false otherwise.
     */
    function _jsGet(file, nullCheck) {
        var js = mstrmojo.loadFileSync(file);
        if (js) {
            try {
                eval(js);

                return nullCheck ?
                    !!verifyJsLoaded(nullCheck) :
                    true;
            } catch (localerr) {
                window.alert('JavaScript compile error:\n\nFile: ' + file + '\n\nError: ' + localerr.message);
            }
        }
        return false;
    }

    mstrmojo.requiresBundle = function reqBundle(bundleName) {
        return _jsGet(getJsBundlesRoot() + bundleName);
    };


    /**
     * <p>Loads dependency libraries using synchronous
     * XMLHTTPRequest GET call.</p>
     *
     * @param {String} file The path + name of the file to load.
     * @param {Boolean} true if the external library is using AMD
     * @returns {Boolean} true if the given file is loaded successfully; false otherwise.
     */
    mstrmojo.requiresDepLib = function requiresDepLib(file, AMD) {
        if (reqCache[file]) {
            return true;
        }
        function isAMD() {
            return "function" === typeof define && define.amd;
        }
        var AMDCache = window.define;
        // DE93546 we have to remove the global of define so that the UMD module loading will not be messed up with AMD module loading
        if (!AMD && isAMD()) {
            delete window.define;
        }
        var value = _jsGet(file);
        reqCache[file] = true;
        window.define = AMDCache; //restore define global if any
        return value;
    };

    /**
     * <p>Loads contents of given file into a string using synchronous
     * XMLHTTPRequest GET call.</p>
     *
     * @param {String} file The path + name of the file to load.
     * @returns {String} The file contents as a string, if successful; null otherwise.
     */
    mstrmojo.loadFileSync = function loadFileSync(file) {
        var result = null;

        if (!$XHR) {
            getXHR();
        }
        if ($XHR) {
            try {
                // Do a synchronous GET call to fetch the file.
                $XHR.open("GET", file + ((window.mstrConfig && mstrConfig.webVersion) ? '?v=' + mstrConfig.webVersion : ''), false);
                $XHR.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
                $XHR.send(null);
                // Retrieve responseText. If successful, status will be 200 (HTTP) or 0 (file://).
                result = $XHR.responseText || null;
            } catch (localerr) {
            }

            // Minor hack: For Mozilla, do an abort() afterwards to avoid errors.
            // TO DO: investigate why without abort() we get errors on subsequent calls here.
            if (!isIE && $XHR.abort) {
                $XHR.abort();
            }
        }

        return result;
    };

    /**
     * <p>Appends a new css link element to the document head element</p>
     *
     * @param {String[]} an array of file paths to link (example: ["/styles/style.css"]).
     */
    mstrmojo.insertCSSLinks = function insertCSSLinks(files) {
        var css, firsthead;

        if (files && files.length > 0) {
            firsthead = document.getElementsByTagName("head")[0];

            files.forEach(function (file) {
                css = document.createElement("link");
                css.setAttribute("id", file.replace(/[^a-zA-Z0-9]/g,''));
                css.setAttribute("rel", "stylesheet");
                css.setAttribute("type", "text/css");
                css.setAttribute("href", file);
                firsthead.appendChild(css);
            });
        }
    };

    /**
     * <p>Loads script files for javascript objects.</p>
     *
     * @class
     * @static
     */
    mstrmojo.loader = {
        /**
         * <p>Hash of FQCNs that are successfully loaded.</p>
         *
         * <p>The hash is keyed by FQCN strings; each has value is a Boolean (true).</p>
         */
        loaded: {
            mstrmojo: true,
            "mstrmojo.loader": true
        },

        /**
         * <p>Determines if a given JavaScript class is currently loaded.</p>
         *
         * <p>This method tries to evaluate the FQCN into an object. If the evaluation results
         * in a non-null object, the class is considered loaded.  If this method determines that the given FQCN is loaded,
         * it will ensure that the FQCN is recorded in a local hash of loaded classes for future reference.</p>
         *
         * @param {String} fqcn The fully qualified class name of the JavaScript class.
         * @returns {Boolean} true if the given FQCN evaluates to a non-null result; false otherwise.
         */
        isLoaded: function isLd(fqcn) {
            var isLoaded = !!verifyJsLoaded(fqcn);
            if (isLoaded) {
                this.loaded[fqcn] = true;
            }
            return isLoaded;
        },

        /**
         * Attempts to load a named JavaScript class, if not loaded already.
         */
        load: function ld(fqcn) {

            // Have we tried and failed before?
            if ($MISSING[fqcn]) {
                return false;
            }
            // Have we succeeded before? Or perhaps it's already loaded?
            if (this.loaded[fqcn] || this.isLoaded(fqcn)) {
                return true;
            }

            // No luck so far. Try to load it for the first time.
            if (_jsGet(this.fqcnToFile(fqcn), fqcn)) {
                this.loaded[fqcn] = true;
                return true;
            }

            $MISSING[fqcn] = true;
            return false;
        },

        /**
         * <p>Computes the relative path of the JavaScript file for the given FQCN.</p>
         *
         * <p>Examples:</p>
         * <ol>
         * <li>"Class1" is mapped to "<mstrApp.jsRoot>Class1.js"</li>
         * <li>"pkg.Class1" is mapped to "<mstrApp.jsRoot>pkg/Class1.js"</li>
         * <li>"mstrmojo.Class1" is mapped to "<mstrApp.jsMojoRoot>Class1.js"</li>
         * <li>"mstrmojo.pkg.Class1" is mapped to "<mstrApp.jsMojoRoot>pkg/Class1.js"</li>
         * </ol>
         *
         * <p>If "mstrApp" is undefined, then the default roots are used:</p>
         * <ol>
         * <li>jsRoot = "../javascript/"</li>
         * <li>jsMojoRoot = "../javascript/mojo/js/source/"</li>
         * </ol>
         *
         * @param {String} fqcn The name of the class to be mapped to a file.
         * @returns {String} The file relative path + name.
         */
        fqcnToFile: function fqcnToFile(fqcn) {
            if (fqcn.match(/^mstrmojo\.plugins\./)) {
                var pluginName = fqcn.substring(17, fqcn.indexOf(".", 17)),
                    pluginFile = pluginName + '/javascript/' + getPluginMojoRoot() + fqcn.replace("mstrmojo.plugins." + pluginName + '.', "").replace(/\./gm, '/');
                /**
                 * DE65302
                 * a. For workstation live mode, dossier server side plugins would be loaded from dossier server plugins
                 * b. Other cases, keep loaded from local workstation
                 * c. For plugin file always load
                 */

                if (mstrApp && mstrApp.supportFeature && mstrApp.supportFeature(mstrmojo.vi.enums.EnumFeatures.SUPPORT_LIVEMODE) && mstrApp.getWSLiveMode() && mstrConfig.dossierServerPluginNames && mstrConfig.dossierServerPluginNames.indexOf(pluginName) > -1) {
                    fqcn = mstrApp.dossierServerBaseUrl + 'plugins/' + pluginFile;
                } else {
                    fqcn = getPluginRoot() + pluginFile;
                }
            } else if (fqcn.match(/^mstrmojo\./)) {
                fqcn = getJsMojoRoot() + fqcn.replace("mstrmojo.", "").replace(/\./gm, '/');
            } else {
                fqcn = getJsRoot() + fqcn.replace(/\./gm, '/');
            }
            return fqcn + '.js';
        }

    };

    var $LOADER = mstrmojo.loader,
        isLoaded = $LOADER.loaded;

    /**
     * <p>Cache of arguments passed into loader.requires method. Used to avoid duplicate loads.</p>
     * @private
     */
    var reqCache = {},
        addPackagesToReqCache = function addPkg(n, ns) {
            var ps = n.split('.'),
                klen = ps.length,
                k;

            for (k = 1; k < klen; k++) {
                var s = ps.slice(0, k).join('.');
                if (!reqCache[s]) {
                    ns.push(s);
                    reqCache[s] = true;
                }
            }
        },
        loadInputScripts = function loadInputScripts(ns) {
            var jlen = ns.length,
                j;

            for (j = 0; j < jlen; j++) {
                if (!$LOADER.load(ns[j])) {
                    window.alert('Warning: Javascript class not found:\n' + ns[j]);
                    break;
                }
            }
        };

    /**
     * <p>Ensures that the given fully qualified class names are loaded, as well as the
     * package prefixes of those names. Attempts to load any which are not already loaded, in the given order.</p>
     *
     * <p>This method takes a variable number of input parameters. Each parameter is assumed to be a
     * fully qualified class name (String).</p>
     *
     * @returns {boolean} true, so that calls can be AND'ed with subsequent operations, for example: "mstrmojo.requiresCls('X') && X.foo()"
     */
    mstrmojo.requiresCls = function reqCls() {
        // Create an array of input strings.
        var argLen = arguments.length,
            ns = [],
            i,
            len;

        // Walk the given FQCN strings...
        for (i = 0, len = argLen; i < len; i++) {

            // Optimization: Have we received this argument before? or preloaded it? If so, skip it.
            var n = arguments[i];
            if (!n || isLoaded[n] || $MISSING[n]) {
                continue;
            } else if (reqCache[n]) {
                // we have requested this class before.  get it now
                loadInputScripts([n]);
                reqCache[n] = false;
                continue;
            }

            // is this not a plugin?
            if (!n.match(/^mstrmojo\.plugins\./)) {

                // If the argument has package prefixes, first add packages to array of inputs
                addPackagesToReqCache(n, ns);

            }
            // After package prefixes (if any), add the FQCN to array of inputs.
            ns.push(n);
            reqCache[n] = true;
        }

        // Now load all the inputs.
        loadInputScripts(ns);
        return true;
    };

    /**
     * <p>Ensures that the given fully qualified class names are loaded, as well as the
     * package prefixes of those names. Attempts to load any which are not already loaded, in the given order.</p>
     *
     * <p>This method takes a minimum of two parameters.  The first parameter is the package prefix of the
     * remaining variable number of input parameters. Each subsequent parameter is assumed to be an unqualified class name (String).</p>
     *
     * @returns {boolean} true, so that calls can be AND'ed with subsequent operations, for example: "mstrmojo.requiresCls('X') && X.foo()"
     */
    mstrmojo.requiresClsP = function reqClsP() {

        // Create an array of input strings.
        var argLen = arguments.length,
            ns = [],
            pkgName = arguments[0],
            i,
            len;

        // If the argument has package prefixes, first add packages to array of inputs.
        addPackagesToReqCache(pkgName, ns);

        // Walk the given class names strings...
        for (i = 1, len = argLen; i < len; i++) {

            // Optimization: Have we received this argument before? or preloaded it? If so, skip it.
            var n = pkgName + "." + arguments[i];
            if (!n || isLoaded[n] || $MISSING[n]) {
                continue;
            } else if (reqCache[n]) {
                // we have requested this class before.  get it now
                loadInputScripts([n]);
                reqCache[n] = false;
                continue;
            }


            if (!n.match(/^mstrmojo\.plugins\./)) {

                // After package prefixes (if any), add the FQCN to array of inputs.
                ns.push(n);
                reqCache[n] = true;
            }
        }

        // Now load all the inputs.
        loadInputScripts(ns);

        return true;
    };

    // =============================== loading descriptors =============================
    var $DESCRIPTORS = mstrmojo.descriptors,
        descPrefix = 'mstrWeb.';

    /**
     * Merge the descriptors information from input into descriptor store.
     *
     * @param ds {Object} This object contains the descriptor information retrieved from task call.
     * @private
     */
    function populateDescriptors(ds) {
        if (ds) {
            var dlen = ds.length,
                di;
            for (di = 0; di < dlen; di++) {
                var d = ds[di];
                $DESCRIPTORS[d.key] = d.v;
            }
        }
    }

    mstrmojo.populateDescriptors = populateDescriptors;

    // When this file is loaded, try to merge the pre-loaded descriptor information into descriptor store
    if (window.mstrConfig !== undefined) {
        populateDescriptors(mstrConfig.mstrDescs && mstrConfig.mstrDescs.descriptors);

        // Remove the descriptors loaded into the page...
        mstrConfig.mstrDescs = null;
    }
    // #694796. merge pre-loaded descriptors
    if (window.mstrApp !== undefined) {
        populateDescriptors(mstrApp.mstrDescs && mstrApp.mstrDescs.descriptors);
    }

    /**
     * Helper method to retrieve descriptors via the XHR.
     *
     * @param {string} prefix The descriptor prefix.
     * @param {int[]} ids An array of requested descriptor IDs.
     *
     * @private
     */
    var requestDescriptor = function (prefix, ids) {
        // Create an array of input strings.
        var ns = [],
            len = ids.length,
            i;

        for (i = 0; i < len; i++) {
            var k = ids[i];
            if (k && !($DESCRIPTORS.hasOwnProperty(prefix + k))) {
                ns.push(k);
            }
        }
        if (ns.length > 0) {
            var response = syncXHR('POST', (window.mstrConfig && mstrConfig.taskURL) || 'taskProc', {
                taskId: 'getDescriptors',
                keys: ns.join(','),
                prefix: prefix
            });

            if (response) {
                // The replace is needed for descriptors that have single quotes (') in them. From the Java side, those descriptors are
                // received as single quote escaped (/'). However, in JSON format, since everything is in double quotes ("), there does not need
                // to be escaping for a single quote and it is not valid JSON. Therefore, wherever there is an escaped single quote it needs to
                // be replaced by a non-escaped single quote for the JSON to correctly parse.
                var r = JSON.parse(response.replace(/\\'/g, "'"));
                populateDescriptors(r && r.descriptors);
            }
        }
    };

    /**
     * Ensure the required descriptors exist in descriptor store. If any descriptor is missing from the store,
     * this method will make XHR call to load it before returning.
     *
     * <p>This method takes a variable number of input parameters. The first parameter is for the prefix for every key.
     * Each parameter, except the first one, is assumed to be a descriptor id (number).</p>
     */
    mstrmojo.requiresDescsWPrefix = function reqDescP(prefix) {
        var args = [].slice.call(arguments);

        args[0] = null;
        requestDescriptor(prefix, args);
    };

    /**
     * <p>Ensure the required descriptors exist in descriptor store.</p>
     * If any descriptor is missing from the store, this method will make XHR call to load it before return.
     *
     * <p>This method takes a variable number of input parameters. Each parameter is assumed to be a
     * descriptor id (number). This method assumes that 'mstrWeb.' is the prefix for each key.</p>
     */
    mstrmojo.requiresDescs = function reqDesc() {
        // if we are not on a mobile device, then request the descriptors via XHR.
        // On a mobile device, it is assumed that the descriptors have been preloaded.
        if (window.mstrConfig !== undefined && !mstrConfig.onMobileDevice) {
            requestDescriptor(descPrefix, arguments);
        }
    };

    /**
     * <p>Returns the localized string for the descriptor key.</p>
     * This method assume the 'mstrWeb.' as the prefix. So, it will look up the descriptor by key 'mstrWeb.' + key.
     *
     * @param descID {Number} the key for the descriptor. It assumes the prefix for the key is 'mstrWeb.'.
     * @param defText {String} The text to use for the descriptor if it cannot be loaded.
     */
    mstrmojo.desc = function desc(descID, defText) {
        // Is the descID parameter a non-null value?
        if (descID !== null && descID !== undefined) {
            // Load the descriptor remotely if it is not found in the local store...
            mstrmojo.requiresDescs(descID);

            // Was it found?
            if ($DESCRIPTORS.hasOwnProperty(descPrefix + descID)) {
                return $DESCRIPTORS[descPrefix + descID];
            }

            // Give a meaningful string if omitted...
            defText = defText || "No string descriptor found for descID=" + descID;
        }

        // "Decorate" the default text...
        var decDefText = "[" + defText + "]";

        // Put the replacement text in the array so it doesn't get continually loaded from the Web Server...
        $DESCRIPTORS[descPrefix + descID] = decDefText;

        return decDefText;
    };

    /**
     * <p>Returns the localized string for the descriptor key.</p>
     * This method will lookup the descriptor whose key prefix + key.
     *
     * @param prefix {String} the prefix for the key.
     * @param descID {Number} the key for the descriptor. It assumes the prefix for the key is 'mstrWeb.'.
     * @param defText {String} The text to use for the descriptor if it cannot be loaded.
     */
    mstrmojo.descP = function descP(prefix, descID, defText) {
        // Load the descriptor remotely if it is not found in the local store...
        mstrmojo.requiresDescsWPrefix(prefix, descID);

        // Was it found?
        if ($DESCRIPTORS.hasOwnProperty(prefix + descID)) {
            return $DESCRIPTORS[prefix + descID];
        }

        // Give a meaningful string if omitted...
        defText = defText || "No string descriptor found for descID=" + descID;

        // "Decorate" the default text...
        var decDefText = "*" + defText + "*";

        // Put the replacement text in the array so it doesn't get continually loaded from the Web Server...
        $DESCRIPTORS[prefix + descID] = decDefText;

        return decDefText;
    };

    // =================== End of descriptors ============================

    /**
     * Records a given static class as loaded under a given fully qualified class name.
     *
     * @param {String} fqcn The fully qualified class name.
     * @param {Object} cls The static class object.
     * @returns {Object} The same static class object.
     */
    mstrmojo.provide = function prv(fqcn, cls) {
        isLoaded[fqcn] = !!cls;
        return cls;
    };

    //TQMS : 536567
    /**
     * <p>This method will mark the given FQCN as needing to be reloaded again during next call to {@link mstrmojo.requiresCls}.</p>
     *
     * @param {string} fqcn The fully qualified class name that should be reloaded during its next call to {@link mstrmojo.requiresCls}.
     */
    mstrmojo.invalidateCls = function rel(fqcn) {
        reqCache[fqcn] = false;
        isLoaded[fqcn] = false;

        this.invalidateJsLoaded(fqcn);
    };

    var mx = mstrmojo.mixin;

    /**
     * Creates a javascript custom class with the given superclass, mixins, and instance properties/methods.
     *
     * @param {Function} SuperCls The constructor of the superclass for the class to be declared. If missing, Object is implied.
     * @param {Object[]} mixins An optional array of "mixins" to be applied to the new custom class. A "mixin" is a hash table of
     *                          properties and/or methods; if given, these will be applied to the constructor's prototype.
     * @param {Object} config A hash table of functions, keyed by name. The functions are assumed to be instance methods;
     *                          they are applied to the constructor's prototype.
     *
     * @returns Function The class constructor.
     */
    mstrmojo.declare = function declare(SuperCls, mixins, config) {
        /**
         * Create a constructor for our custom class.  The constructor doesn't do much itself, it just calls
         * the class's instance method "init" (if any).  The one other job of the constructor is to check if the
         * input param tells it to skip the "init" call; this is useful when defining a subclass, because in
         * that scenario we want to skip the init call.
         *
         * @param {Object} [props={}] Optional instance properties.
         * @inner
         */
        function Constr(props) {
            if ((!props || !props.dontInit) && this.init) {
                this.init(props);
            }
        }

        // If superclass is given, set the constructor's prototype to an instance of it.  This allows
        // every instance of our constructor to inherit all the superclass' instance methods/props.  However,
        // this also means that all instances of our constructor will inherit the "constructor" property
        // from that superclass instance; the superclass instance's "constructor" property is the superclass constructor.
        // That's not right for us; we want all instances of our constructor to have their "constructor" property
        // point back to our constructor (of course).  To fix that, simply manually reset the constructor's prototype's
        // "constructor" back to our constructor.
        if (SuperCls) {
            Constr.prototype = new SuperCls({
                dontInit: true
            });
            Constr.prototype.constructor = Constr;
        }

        var proto = Constr.prototype;

        // Apply all the mixin methods to the constructor's prototype.
        var cnt = (mixins && mixins.length) || 0,
            i;
        for (i = 0; i < cnt; i++) {
            mx(mixins[i], proto);
        }

        // Apply all the instance methods to the constructor's prototype.
        if (config) {
            mx(config, proto);
            if (config.scriptClass) {
                isLoaded[config.scriptClass] = true;
            }
        }

        return Constr;
    };

    /**
     * Finds an ancestor widget (via 'parent' chain) by searching for the presence of a particular field or method.
     *
     * @param {mstrmojo.Widget} src The {@link mstrmojo.Widget} to begin searching from.
     * @param {string} property The name of the field or method to search for.
     * @param {*} [value=null] An optional property value to match against.
     * @param {mstrmojo.Container} [limitClass=null] An optional constructor to be used to limit the search.  If at any time this search
     *          encounters an instance of this passed constructor the search will halt and null will be returned.
     *
     * @returns {mstrmojo.Container} The found instance of {@link mstrmojo.Container}, or null if not found.

     * @static
     */
    mstrmojo.findAncestor = function findAncestor(src, property, value, limitClass) {
        var ancestor = src && src.parent;
        while (ancestor && (!limitClass || !(ancestor instanceof limitClass))) {
            var targetProperty = ancestor[property];
            if (targetProperty !== undefined) {
                if (value !== undefined && value !== null) {
                    if (targetProperty === value) {
                        return ancestor;
                    }
                } else {
                    return ancestor;
                }
            }

            ancestor = ancestor.parent;
        }

        return null;
    };

    /**
     * Check a given mojo widget to see whether it is a descandant of another mojo widget.
     * @param {mstrmojo.Widget} parent The container widget.
     * @param {mstrmojo.Widget} child The candidate descendant widget.
     *
     * @returns {boolean} True if child widget is a descendant of parent widget, otherwise, false
     */
    mstrmojo.isDescendant = function isDescendant(parent, child) {
        var ancestor;

        if (!child || !parent) {
            return false;
        }
        ancestor = child.parent;
        //loop through the ancestor of child widget
        while (ancestor) {
            //if found a match, end the loop and return true
            if (ancestor === parent) {
                return true;
            }
            //otherwise, look for its parent
            ancestor = ancestor.parent;
        }
        return false;
    };

    /**
     * Get CSRF token
     * @param {*} [url=null] the url where the token is to be added to. It would not append if it points to a different Web application
     * @returns {string} the csrf token
     */
    mstrmojo.getCSRFToken = function getCSRFToken(url) {
        var tkn = null;

        try {
            if (url) { // if a URL is provided we first check if we should add the token
                if (url.indexOf('validateRandNum=') >= 0) { // token already there?
                    return tkn;
                }

                if (this.isUrlExternal(url)) { // links to external websites do not need the token
                    return tkn;
                }
            }
            if (window.mstrApp && mstrApp.validateRandNum) {
                tkn = mstrApp.validateRandNum;
            } else if (window.mstrConfig && mstrConfig.validateRandNum) {
                tkn = mstrConfig.validateRandNum;
            } else if (window.microstrategy !== undefined && microstrategy && microstrategy.validateRandNum) {
                tkn = microstrategy.validateRandNum;
            }
        } catch (err) {
            //ignore
        }
        return tkn;
    };

    /**
     * Adds the CSRF token to a URL if needed
     * @param {String} url the url to add the token to
     * @returns {String} url with appended token if needed
     */
    mstrmojo.addCSRFTokenToURL = function addCSRFTknToURL(url) {
        if (!url) {
            return '';
        }
        var tkn = mstrmojo.getCSRFToken(url);
        if (tkn && tkn.length > 0) {
            if (url.indexOf('?') > -1) {
                url += "&";
            } else {
                url += "?";
            }
            url += "validateRandNum=" + tkn;
        }
        return url;
    };

    /**
     * Adds the CSRF token to task params if needed
     * @param {Object} params the task params collection
     * @returns {Object} params the task params collection
     */
    mstrmojo.addCSRFTokenToTaskParams = function addCSRFTknToTaskParams(params) {
        if (params) {
            var tkn = mstrmojo.getCSRFToken();
            if (tkn && tkn.length > 0) {
                params.validateRandNum = tkn;
            }
        }
        return params;
    };

    /**
     * <p>Returns a new instance as described by the configuration.</p>
     *
     * @param {Object} config The configuration for the requested instance (must include a valid scriptClass property).
     *
     * @return mstrmojo.Obj
     */
    mstrmojo.getInstance = function getInstance(config) {
        var Clazz = mstrmojo.hash.walk(config.scriptClass, window);
        if (Clazz) {
            return new Clazz(config);
        }

        return null;
    };

    /**
     * Determine is the URL provided is external (i.e. google.com)
     * @param url
     * @returns {boolean}
     */
    mstrmojo.isUrlExternal = function isUrlExternal(url) {
        var curURL = window.location.href;
        var servletName = window.mstrApp && mstrApp.name,
            taskProcName = window.mstrConfig.taskURL && mstrConfig.taskURL,
            isSameWebApp = (url.indexOf('?') === 0 || //?evt...
                url.indexOf(servletName) === 0 || //mstrWeb
                url.indexOf('./' + servletName) === 0 || // ./mstrWeb
                url.indexOf(taskProcName) === 0 || //taskProc
                url.indexOf('./' + taskProcName) === 0 || // ./taskProc
                url.indexOf(curURL) === 0 || // http://localhost:8080/MicroStrategy/servlet/mstrWeb
                ((curURL.indexOf('?') > 0) && (url.indexOf(curURL.substring(0, curURL.indexOf('?'))) === 0))); // http://localhost:8080/MicroStrategy/servlet/mstrWeb?a=1&b=2
        return !isSameWebApp;
    };

    /**
     * Resolve the value of a feature. Return true if the feature exists and it's true.
     *
     * @param {String} feature the name of the feature
     * @returns {Boolean}
     */
    mstrmojo.resolveFeature = function resolveFeature(feature) {
        var features = mstrApp.features;

        return features && features[feature];
    };

    /**
     * Return the base URL for locating STYLE static resources. Consults the mstrConfig object for a 'styleRoot' property. If either is absent, it defaults to "../style".
     * @returns {string}
     */
    mstrmojo.getStyleRoot = function getStyleRoot() {
        var c = mstrConfig || {},
            styleRoot = c.styleRoot || "../style";

        return styleRoot;
    };

    /**
     * Return the base URL for js resources
     * @returns {string}
     */
    mstrmojo.getJsRoot = getJsRoot;

    /**
     *  Returns the object that exists on window for the fully qualified class name of a js file.
     *  @returns {object} - will return undefined if object does not exist.
     */
    function verifyJsLoaded(name) {
        name = name.trim();
        var path = name.split('.');
        var o = window;

        for (var i = 0; i < path.length; i++) {
            o = o[path[i]];
            if (!o) {
                break;
            }
        }
        return o;
    }

    mstrmojo.invalidateJsLoaded = function invalidateJsLoaded(name) {
        var path = name && name.trim().split('.'),
            len = (path && path.length) || 0,
            tmp = window,
            i;

        for (i = 0; i < len - 1; i++) {
            if (!tmp) {
                return;
            }
            tmp = tmp[path[i]];
        }
        if (tmp && path[i]) {
            tmp[path[i]] = undefined;
        }
    };
}());
(function () {

    /**
     * Utility functions to evaluate or reformat urls.
     *
     * @namespace mstrmojo.url
     */
    mstrmojo.url = mstrmojo.provide(
        "mstrmojo.url",

        /**
         * @lends mstrmojo.url
         */
        {
            /**
             * Decides whether the url is an absoluate URL or not
             *
             * @param {string} url the URL string
             *
             * @returns {boolean} True if the url contains http|ftp|file at the beginning
             */
            isAbsoluteURL: function (url) {
                return (/^(http|https|ftp|file):\/\//i.test(url));
            },

            /**
             * Convert the input URL to an absolute URL. If the input URL is already an absolute URL, returns itself.
             * Otherwise, convert the URL into absolute URL. If based url is not presented, insert 'http://' at the beginning of the input URL.
             *
             * @param {string} url The relative URL path
             * @param {string} [baseUrl] The optional base url to convert an relative url to absolute
             *
             * @returns {string} Converted absolute url path
             */
            getAbsoluteURL: function (url, baseUrl) {
                if (this.isAbsoluteURL(url)) {
                    return url;
                }
                if (baseUrl) {
                    return baseUrl + (/\/$/.test(baseUrl) ? '' : '/') + url;
                }
                return 'http://' + url;
            },

            // DE58474, DE58645, DE58656
            // get web server location of current page
            // an example: http://localhost:8080/MSTRWeb/
            getWebServerUrl: function (isTablet) {
                var webServerUrl = null;

                if (isTablet) {
                    // on android tablet
                    if (mstrApp !== undefined && mstrApp.getConfiguration) {
                        webServerUrl = mstrApp.getConfiguration().getCurrentProjectWebServerUrl();
                    }
                } else {
                    // on html5
                    var href = document.location && document.location.href;
                    if (href) {
                        var hrefLowerCase = href.toLowerCase();
                        var appReg = '/app/',
                            servletReg = '/servlet/',
                            aspReg = '/asp/';
                        var appIndex = hrefLowerCase.indexOf(appReg),
                            servletIndex = hrefLowerCase.indexOf(servletReg),
                            aspIndex = hrefLowerCase.indexOf(aspReg);

                        if (appIndex >= 0) {
                            webServerUrl = href.substr(0, appIndex + 1);
                        } else if (servletIndex >= 0) {
                            if (aspIndex < 0) {
                                webServerUrl = href.substr(0, servletIndex + 1);
                            } else if (aspIndex >= 0) {
                                var index = (servletIndex > aspIndex) ? aspIndex : servletIndex;
                                webServerUrl = href.substr(0, index + 1);
                            }
                        } else if (servletIndex < 0) {
                            if (aspIndex >= 0) {
                                webServerUrl = href.substr(0, aspIndex + 1);
                            } /*else if (aspIndex < 0) {

                            }*/
                        }
                    }
                }

                return webServerUrl;
            },

            /**
             * get full path according to path, used by image threshold icon and  background image
             * path: can be relative or absolute path
             *
             */
            getFullPath: function getFullPath(path) {
                var fullPath = path,
                    reg = /^[A-z]:\/\//, // absolute url regulation
                    baseUrl,
                    baseUrlIdx;

                // DE59398 If it is not dossier app do nothing and return the same path
                // DE108700 in case the path is undefined return also as in Dossier call to get the path can result when the value is undefined
                // DE105160 if the path is 64 bit image don't try to convert
                if (!(mstrApp && mstrApp.isDossier) || !path || path.indexOf("data:image") === 0) {
                    return path;
                }

                if (reg.test(path)) {
                    // is an complete URL
                    fullPath = path;
                } else {
                    // is relative path in mobile server

                    // delete '../', '..\', './', '.\', '/', '\' at the beginning of the path if there is any
                    var tempReg1 = /^(\.\.\/|\.\.\\)/; // need to test the regularation
                    var tempReg2 = /^(\.\/|\.\\)/;
                    var tempReg3 = /^(\/|\\)/;
                    path = path.replace(tempReg1, '');
                    path = path.replace(tempReg2, '');
                    path = path.replace(tempReg3, '');

                    if (mstrApp && mstrApp.getConfiguration) {
                        //DE44678, Dossier need only relative path and there is no servlet/asp in the server url
                        var serverUrl = this.getWebServerUrl(this.isTablet);
                        if (!serverUrl) {
                            fullPath = path;
                        } else {
                            fullPath = this.getAbsoluteURL(path, serverUrl);
                        }
                    }
                }

                return fullPath;
            }
        }
    );
}());
if (!mstrmojo.LoadedExternalJSURLs) {
    mstrmojo.LoadedExternalJSURLs = {};
}

function LoadScriptsExternalJSCallback() {

    //since we processed this url, remove it from the array
    mstrmojo.LoadedExternalJSURLs[mstrmojo._LoadsScript.esScripts.splice(0, 1)[0].url] = true;
    //now load the remaining urls
    mstrmojo._LoadsScript.requiresExternalScripts(
        mstrmojo._LoadsScript.esScripts,
        mstrmojo._LoadsScript.callback,
        mstrmojo._LoadsScript.esScritsContext
    );

    mstrmojo._LoadsScript.ExternalJSCallbackIsBusy = false;
}

/**
 * Ensure mstrmojo._LoadsScript is only declared once.
 * This is because some scripts information and callbacks are stored on mstrmojo._LoadsScript.
 * In some pages mstrmojo._LoadsScript (e.g. RW interactive mode/report) is loaded more than once because multiple bundles which include it are loaded.
 * The latter one will clean mstrmojo._LoadsScript.esScripts and cause error in callback of previous one.
 * The error can be reproduced by open map widget in RW interactive mode since map requires a lot of external libraries.
 */
if (!mstrmojo._LoadsScript) {

    /**
     * <p>Enables an object to load javascript methods at run-time.</p>
     *
     * @mixin
     * @public
     */
    mstrmojo._LoadsScript = mstrmojo.provide(
        "mstrmojo._LoadsScript",

        /**
         * @lends mstrmojo._LoadsScript.prototype
         */
        {
            /**
             * @ignore
             */
            _meta_usesSuper: false,

            /**
             * <p>Ensures that the script for a given method is loaded into this object.</p>
             *
             * <p>If this object's property with the given method name points to a function, we assume
             * that function is the desired method.  Otherwise, we assume we must load a mixin that
             * implements the method.  The FQCN from the mixin is a string that is assumed to be declared
             * either:
             * <ul>
             * <li>under the method name; or</li>
             * <li>under the "this.methods" hash, keyed by the method name; or</li>
             * <li>under the "this.methods" hash, keyed by "*" (meaning, a default mixin for all methods).</li>
             * </ul>
             * </p>
             *
             * @param {string} n The name of the method to be loaded.
             * @returns {boolean} true if the method is now successfully loaded in this object.
             */
            requiresMethod: function requiresMethod(n) {
                if (!n) {
                    return false;
                }

                // Do we have a function for this method?
                if (typeof this[n] === "function") {
                    return true;
                }
                // Try to load the method. We need the FQCN of the mixin that impls the method.
                var fqcn = this[n] || (this.methods && (this.methods[n] || this.methods["*"]));
                if (typeof fqcn === "string") {
                    this.requiresCls(fqcn);
                    return typeof this[n]  === "function";
                }

                return false;
            },

            /**
             * Loads the requested mixins (if not already loaded), mixes them into the
             * prototype of this widget's constructor, and then fires given callback.
             *
             * @param {Array|String} mixins
             * @param {Function=} callback
             */
            requiresCls: function req(mixins, callback) {
                // TO DO: implement this using async XHR.
                if (mixins) {
                    if (typeof mixins === "string") {
                        mixins = [mixins];
                    }
                    // XHR get any of the mixins that are not loaded in-memory yet.
                    mstrmojo.requiresCls.apply(mstrmojo, mixins);
                    // Mix these into the constructor's prototype. Record the mixins
                    // we do in a class-level hash, so we don't redo them again later.
                    var p = this.constructor.prototype,
                        pm = p.mixins;
                    if (!pm) {
                        p.mixins = {};
                        pm = p.mixins;
                    }
                    var mx = mstrmojo.mixin,
                        i,
                        len;

                    for (i = 0, len = mixins.length; i < len; i++) {
                        var fqcn = mixins[i];
                        if (!pm[fqcn]) {
                            var m = eval(mixins[i]);
                            mx(m, p);
                            pm[fqcn] = true;
                            // After each mixin, call the mixin's __onmixin__ method (if any) on ourselves.
                            if (m.__onmixin__) {
                                m.__onmixin__.apply(this, []);
                            }
                        }
                    }
                    if (callback) {
                        callback.apply(this, []);
                    }
                }
            },

            /**
             * Loads the contributor object identified in the given property. If loaded successfully,
             * stores a reference to it in the given property and sets its parent to this widget; otherwise,
             * if not loaded successfully, replaces the property value with null.
             *
             * @param {string} propName
             * @param {boolean} [bForceStartup=false]
             */
            requiresContrib: function reqCb(propName, bForceStartup) {
                var fqcn = this[propName];
                if (fqcn) {
                    var c,
                        firstTime = false;
                    if (typeof fqcn === 'string') {
                        c = mstrmojo.registry.ref(fqcn);
                        this[propName] = c;
                        firstTime = true;
                    } else {
                        c = fqcn;    // Assume its the contributor object itself.
                    }
                    // Set the parent and call startup. We do this the first time we initialize
                    // the contributor, and additionally if a flag tells us to do it subsequent times.
                    if (c && (firstTime || bForceStartup)) {
                        c.parent = this;
                        if (c.startup) {
                            c.startup();
                        }
                    }
                    return c;
                }
                return null;
            },

            /**
             *
             * Load the external java scripts synchronously
             *
             */
            requiresExternalScripts: function requiresExternalScripts(esScripts, callback, context) {

                if (esScripts && esScripts instanceof Array) {
                    if (esScripts.length === 0) { //this could be case when user provided only one url and has a call back
                        if (callback) {
                            callback.call(context);
                        }

                        return false;
                    }

                    //check if the next script to be loaded is in the loaded cache, then skip this one
                    if (esScripts[0] && esScripts[0].forceReload === false && mstrmojo.LoadedExternalJSURLs[esScripts[0].url]) {

                        esScripts.splice(0, 1); //remove this from the array and start loading the remaining urls

                        return this.requiresExternalScripts(esScripts, callback, context);
                    }

                    var script = document.createElement("script"), isIE = !!document.all,
                        url = esScripts[0].url,
                        onError = esScripts[0].onError;

                    // US38000: Support offline libraries. Relative path should be used, e.g. file://../../abc/d.js.
                    //          In web 'file://' should be removed. In onetier it will be appended automatically.
                    if (url.substr(0,7) === "file://") {
                        url = url.substr(7);
                    } else if (mstrApp.isSingleTier && url.substr(0,4) !== "http" ) {
                        // TQMS#1007849 prefix URL with 'HTTP:' for OneTier app. otherwise it will default the protocol to 'file://'
                        url = "http:" + url;
                    }
                    script.type = "text/javascript";
                    script.src = url;

                    if (onError) {
                        script.onerror = function() {
                            if (onError && onError.callback && context) {
                                onError.callback.call(context, onError.params); // handle no internet cases
                            }
                        };
                    }

                    if (!esScripts[0].callbackParamName) {
                        if (isIE) {
                            //IE: handle <script> Tag state change event:
                            script.onreadystatechange = function () {
                                //when IE finishes loading/parsing current <script>, continue next

                                if (script.readyState === "loaded" || script.readyState === "complete") {
                                    script.onreadystatechange = null; // avoid handling twice
                                    script.onerror = null;            // avoid memory leak
                                    //load the next script if any here
                                    if (esScripts.length > 1) {
                                        //remove the first element which is processed

                                        mstrmojo.LoadedExternalJSURLs[esScripts.splice(0, 1)[0].url] = true;
                                        mstrmojo._LoadsScript.requiresExternalScripts(esScripts, callback, context);

                                    } else if (esScripts.length === 1) {
                                        mstrmojo.LoadedExternalJSURLs[esScripts[0].url] = true;
                                        //call the callback function if any
                                        if (callback) {
                                            callback.call(context);
                                        }
                                    }
                                }
                            };
                        } else { // for FireFox, safari etc
                            script.onload = function () {

                                script.error = null;   // avoid memory leak
                                script.onload = null;  // avoid handling twice
                                //load the next script if any here
                                if (esScripts.length > 1) {
                                    //remove the first element which is processed

                                    mstrmojo.LoadedExternalJSURLs[esScripts.splice(0, 1)[0].url] = true;
                                    mstrmojo._LoadsScript.requiresExternalScripts(esScripts, callback, context);
                                } else if (esScripts.length === 1) {
                                    mstrmojo.LoadedExternalJSURLs[esScripts[0].url] = true;
                                    //call the callback function if any
                                    if (callback) {
                                        callback.call(context);
                                    }

                                }
                            };
                        }
                    } else {
                        if (esScripts[0].callbackParamName.length !== 0) { //if we have a callback request parameter name then use it
                            //check if already someone else is using the global callback method. If yes, then we have to wait for sometime and check back
                            if (mstrmojo._LoadsScript.ExternalJSCallbackIsBusy && mstrmojo._LoadsScript.ExternalJSCallbackIsBusy === true) {
                                var that = this;
                                window.setTimeout(function () {
                                    that.requiresExternalScripts(esScripts, callback, context);
                                }, 500);
                                return;
                            }
                            //indicate the global flag that the callback function is busy
                            mstrmojo._LoadsScript.ExternalJSCallbackIsBusy = true;

                            //remove the first element which is processed
                            script.src += "&" + esScripts[0].callbackParamName + "=LoadScriptsExternalJSCallback";

                            mstrmojo._LoadsScript.esScripts = esScripts;
                            mstrmojo._LoadsScript.callback = callback;
                            mstrmojo._LoadsScript.esScritsContext = context;

                        }
                    }

                    document.getElementsByTagName("head")[0].appendChild(script);
                }
            }

        }
    );
}
(function () {

    /**
     * Utility method that returns a native DOM event object.  Used to get a handle
     * to the event while encapsulating cross-browser differences.
     *
     * @param {Window} hWin
     * @param {Event=} e
     *
     * @returns {Event}
     */
    function getEvent(hWin, e) {
        return e || (hWin || window).event;
    }

    /**
     * Extract a string to get the integer
     * @param value
     * @returns {*}
     */
    function extractNumber(value) {
        var n = parseInt(value, 10);

        return n === null || isNaN(n) ? 0 : n;
    }

    /**
     * A type to describe the position of an HTMLElement.
     *
     * @typedef {{
     *     x: int,
     *     y: int,
     *     w: int,
     *     h: int
     * }}
     *
     * @property {int} x The position of the element along the x-axis.
     * @property {int} y The position of the element along the y-axis.
     * @property {int} w The width of the element.
     * @property {int} h The height of the element.
     */
    mstrmojo.PositionType = null;

    var isIE = !!document.all,
        docMode = document.documentMode, //available in IE browsers
        ua = navigator.userAgent,
        isIE6 = false,
        isIE7 = false,
        isIE8 = false,
        isIE9 = false,
        isIE10 = false,
        isIE11 = !isIE && "ActiveXObject" in window, // IE11 dose not act like IE<=10
        isDXIE = false;
    isIE = isIE || isIE11;

    if (isIE) {
        if (window.mstrConfig && mstrConfig.isEdgeModeEnabled) {
            isIE6 = !!ua.match(/MSIE 6/);
            isIE7 = ((!!ua.match(/MSIE 7/) && !docMode) || docMode === 7);  //IE7 or IE in IE7 Standards Mode
            isIE8 = (docMode === 8);    //IE in IE8 Standards Mode
            isIE9 = (docMode === 9);    //IE in IE9 Standards Mode
            isIE10 = (docMode === 10);  //IE in IE10 Standards Mode
            isDXIE = (!docMode || docMode <= 9); //IE9- supports DX filters
        } else {
            isIE6 = !!ua.match(/MSIE 6/);
            isIE7 = !!ua.match(/MSIE 7/);
            isIE8 = !!ua.match(/MSIE 8/);
            isIE9 = !!ua.match(/MSIE 9/);
            isIE10 = !!ua.match(/MSIE 10/);
            isDXIE = !isIE10;
        }
    }

    var isFF = !isIE && !!ua.match(/Firefox/),
        bv = 0,
        isAndroid = !!ua.match(/Android/),
        isIPad = !!ua.match(/iPad/),
        isIPhone = !!ua.match(/iPhone/),
        tch = !!document.createTouch || isAndroid,
        isPlayBook = !!ua.match(/PlayBook/),
        isWinPhone = !!ua.match(/Windows Phone/),
        isIEW3C = !isIE && !!ua.match(/Trident.*rv/),
        CSS3_PREFIX = isFF ? '-moz-' : (isIE || isIEW3C) ? '' : '-webkit-',
        CSS3_TRANSFORM_PREFIX = isFF ? 'Moz' : (isIE10 || isIEW3C) ? '' : isIE ? 'ms' : 'webkit',
        CSS3_T_INITIAL = ((isIE10 || isIEW3C) ? 't' : 'T'),
        CSS3_TRANSITION = CSS3_TRANSFORM_PREFIX + CSS3_T_INITIAL + 'ransition'; // IE9: N/A, IE10: transition, Chrome: webkitTransition, Moz: transition or MozTransransition

    function buildCSS3Transform() {

        /*
         IE9: msTransform
         IE10: transform
         Chrome: webkitTransform
         Moz: transform or MozTransform
         */
        return CSS3_TRANSFORM_PREFIX + CSS3_T_INITIAL + 'ransform';
    }

    function buildCSS3TransitionProperty() {

        /*
         IE9: N/A
         IE10: transitionProperty
         Chrome: webkitTransitionProperty
         Moz: transitionProperty or MozTransransitionProperty
         */

        return CSS3_TRANSITION + 'Property';
    }

    function buildCSS3TransitionDuration() {

        /*
         IE9: N/A
         IE10: transitionDuration
         Chrome: webkitTransitionDuration
         Moz: transitionDuration/MozTransitionDuration
         */

        return CSS3_TRANSITION + 'Duration';
    }

    function buildCSS3TransitionEnd() {

        /*
         IE9: N/A
         IE10: transitionend
         Chrome: webkitTransitionEnd
         Moz: transitionend
         */

        return (isIE10 || isFF) ? 'transitionend' : 'webkitTransitionEnd';
    }

    function buildCSS3BoxShadow() {

        /*
         IE9: N/A
         IE10: BoxShadow
         Chrome: webkitBoxShadow
         Moz: MozBoxShadow
         */

        return CSS3_TRANSFORM_PREFIX + 'BoxShadow';
    }

    var CSS3_TRANSFORM = buildCSS3Transform(),
        CSS3_TRANSITION_PROPERTY = buildCSS3TransitionProperty(),
        CSS3_TRANSITION_DURATION = buildCSS3TransitionDuration(),
        CSS3_TRANSITION_END = buildCSS3TransitionEnd(),
        CSS3_BOXSHADOW = buildCSS3BoxShadow();

    /**
     * Private function for extracting the Firefox browser version number.
     *
     * @private
     * @ignore
     */
    function getBrowserVersion() {
        // Have we cached the browser version already?
        if (!bv && isFF) {
            // If not, we only need this for Firefox.
            // Retrieve the Firefox version number from the user agent.
            var nav = ua.match(/.*Firefox\/([\d|\.]*).*/);
            // Did we find it?
            if (nav) {
                // Store this in the browser version and return it.
                bv = parseFloat(nav[1]);
            }
        }

        return bv;
    }

    function docScroll() {
        var x = 0,
            y = 0,
            w = window,
            d = document,
            b = d.body,
            de = d.documentElement;
        if (typeof w.pageYOffset === 'number') {
            y = w.pageYOffset;
            x = w.pageXOffset;
        } else if (b && (b.scrollLeft || b.scrollTop)) {
            y = b.scrollTop;
            x = b.scrollLeft;
        } else if (de && (de.scrollLeft || de.scrollTop)) {
            y = de.scrollTop;
            x = de.scrollLeft;
        }
        return {
            x: x,
            y: y
        };
    }

    function setTranslateValue(num) {

        //Validate for null or undefined
        num = num || 0;

        //Convert to string
        num = String(num);

        return ((num.indexOf("%", 0)) !== -1) ? num : (num + 'px');
    }

    function createTransformationString(x, y, z, use3d, translateString) {

        if (!mstrmojo.dom.isWinPhone) {
            use3d = (use3d || false || this.isHWAccelerated);
        } else {
            use3d = false;
        }

        var translateOpen = translateString + (use3d ? '3d' : '') + '(',
            translateClose = use3d ? (',' + z + ')') : ')';

        return translateOpen + x + ',' + y + translateClose;
    }

    var BOTTOM = 2,
    //        TOP = 1,
    //        LEFT = 4,
    //        RIGHT = 5,
        CENTER = 3;

    /**
     * Align DOM node to the indicated position within the window.
     *
     * @param {HTMLElement} e The dom node that needs alignment
     * @param {int} h Horizontal alignment flag, can be LEFT, CENTER, or RIGHT
     * @param {int} v Vertical alignment flag, can be TOP, CENTER, or BOTTOM
     */
    function alignDOM(e, h, v) {
        var elementStyle = e.style,
            elementDisplay = elementStyle.display,
            windowDimensions = this.windowDim(),
            ds = docScroll();

        //display before reading clientWidth/height
        elementStyle.display = 'block';

        var hpos = windowDimensions.w - e.clientWidth,
            vpos = Math.max(windowDimensions.h - e.clientHeight, 0),
            hm = {
                4: 0, /* left */
                5: hpos, /* right */
                3: hpos / 2     /* center */
            },
            vm = {
                1: 0, /* top */
                3: vpos / 2, /* center */
                2: vpos         /* bottom */
            };

        elementStyle.left = hm[h] + ds.x + 'px';
        elementStyle.top = vm[v] + ds.y + 'px';
        elementStyle.display = elementDisplay;
    }

    /**
     * It's an override of mstrmojo.dom.attachEvent, since in IE8- attachEvent will duplicate register the same handlers
     *
     * @param {HTMLElement} el The HTMLElement to attach an event listener to.
     * @param {string} eventName The name of event to listen for.
     * @param {Function} f The function to execute when the event occurs.
     * @param {boolean=} phase The event phase to capture (false for bubbles, true for capture).
     */
    function attachUniqueEvent(el, eventName, f, phase) {
        if (el.addEventListener) {
            return el.addEventListener(eventName, f, !!phase);
        }

        // assign each event handler a unique ID
        f._id = f._id || attachUniqueEvent.guid++;

        // create a hash table of event types for the element
        el.events = el.events || {};

        // create a hash table of event handlers for each element/event pair
        var handlers = el.events[eventName];
        if (!handlers) {
            handlers = el.events[eventName] = {};
            // store the existing event handler (if there is one)
            if (el["on" + eventName]) {
                handlers[0] = el["on" + eventName];
            }
        }

        // store the event handler in the hash table
        handlers[f._id] = f;

        function handleUniqueEvent(event) {
            // grab the event object (IE uses a global event object)
            event = event || window.event;
            // get a reference to the hash table of event handlers
            var handles = this.events[event.type],
                i;

            // execute each event handler
            for (i in handles) {
                handles[i].call(this, event);
            }
        }

        // assign a global event handler to do all the work
        el["on" + eventName] = handleUniqueEvent;
    }

    // a counter used to create unique IDs
    attachUniqueEvent.guid = 1;

    /**
     * It's an override of mstrmojo.dom.detachEvent
     *
     * @param {HTMLElement} el The HTMLElement to attach an event listener to.
     * @param {string} eventName The name of event to listen for.
     * @param {Function} f The function to execute when the event occurs.
     * @param {boolean=} phase The event phase to capture (false for bubbles, true for capture).
     */
    function detachUniqueEvent(el, eventName, f, phase) {
        if (!el) {
            return;
        }
        if (el.removeEventListener) {
            el.removeEventListener(eventName, f, !!phase);
        } else {
            // delete the event handler from the hash table
            if (el.events && el.events[eventName]) {
                delete el.events[eventName][f._id];
            }
        }
    }

    mstrmojo.Enum_Keys = {
        // summary:
        //      Definitions for common key values
        BACKSPACE: 8,
        TAB: 9,
        ENTER: 13,
        CTRL: 17,
        ESCAPE: 27,
        SPACE: 32,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        END: 35,
        HOME: 36,
        LEFT_ARROW: 37,
        UP_ARROW: 38,
        RIGHT_ARROW: 39,
        DOWN_ARROW: 40,
        INSERT: 45,
        DELETE: 46
    };

    /**
     * Utility class for common DOM operations.
     *
     * @type {Object}
     * @static
     */
    mstrmojo.dom = mstrmojo.provide(
        "mstrmojo.dom",

        /**
         * @lends mstrmojo.dom
         */
        {
            userAgent: ua,

            isIE: isIE,
            isIE6: isIE6,
            isIE7: isIE7,
            isIE8: isIE8,
            isIE9: isIE9,
            isIE10: isIE10,
            isIE11: isIE11,
            isIEW3C: isIEW3C,
            isNSIE: isDXIE, //Non Standards IE
            isDXIE: isDXIE,

            isFF: isFF,

            isWK: !!ua.match(/AppleWebKit/),

            isSafari: !!ua.match(/Safari/) && !ua.match(/Chrome/),

            isChrome : !!ua.match(/AppleWebKit/) && ua.match(/Chrome/),

            isEdge :  !!ua.match(/Edge/),

            isHWAccelerated: !isAndroid,

            isAndroid: isAndroid,

            isIPad: isIPad,

            isPlayBook: isPlayBook,

            isWinPhone: isWinPhone,

            isMobile: isIPad || isIPhone || isWinPhone || isAndroid,

            isIOSTouch : (isIPad || isIPhone) && !window.MSStream,//DE74846, added to support contextmenu in IOS touch device, for web

            supportsTouches: tch,

            TOUCHSTART: tch ? 'touchstart' : 'mousedown',
            TOUCHMOVE: tch ? 'touchmove' : 'mousemove',
            TOUCHEND: tch ? 'touchend' : 'mouseup',
            TOUCHCANCEL: tch ? 'touchcancel' : '',
            RESIZE: tch ? 'orientationchange' : 'resize',

            CSS3_PREFIX: CSS3_PREFIX,
            CSS3_BOXSHADOW: CSS3_BOXSHADOW,
            CSS3_TRANSFORM: CSS3_TRANSFORM,
            CSS3_TRANSITION: CSS3_TRANSITION,
            CSS3_TRANSITION_PROPERTY: CSS3_TRANSITION_PROPERTY,
            CSS3_TRANSITION_DURATION: CSS3_TRANSITION_DURATION,
            CSS3_TRANSITION_END: CSS3_TRANSITION_END,

            cssFeatures: {
                GRADIENTS: 'gd',
                ROUND_CORNERS: 'rc',
                TEXT_ROTATION: 'tr',
                DROP_SHADOW: 'sh'
            },
            htmlFeatures: {
                FILE_READER: 'fr'
            },

            /**
             * button associated with mouse event
             */
            MOUSE_BUTTON: {
                LEFT: 1,
                RIGHT: 2
            },

            /**
             * Determines if the users browser supports a particular feature.
             *
             * @param {string} featureName The feature to check using the constants defined on this object.
             *
             * @returns {boolean}
             */
            supports: function supports(featureName) {
                var ffVer = this.isFF && getBrowserVersion();
                switch (featureName) {
                case this.cssFeatures.GRADIENTS:
                    return (this.isIE || this.isIEW3C || this.isWK || ffVer >= 3.6 || this.isWinPhone);

                case this.cssFeatures.ROUND_CORNERS:
                    return (this.isWK || this.isFF || this.isWinPhone || this.isIE10);

                case this.cssFeatures.TEXT_ROTATION:
                    // fall-through
                case this.cssFeatures.DROP_SHADOW:
                    return (this.isIE || this.isWK || ffVer >= 3.5 || this.isWinPhone || this.isIE10 || this.isIEW3C);
                case this.htmlFeatures.FILE_READER:
                    return !!(window.FileReader);
                }

                return false;
            },

            /**
             * <p>Returns information on the OS (and it's version) on which the browser is running.</p>
             *
             * @returns {{name: string, version: string}}
             */
            getOSInfo: function getOSInfo() {
                var unknown = 'Unknown',
                    appVersion = navigator.appVersion,
                    userAgent = navigator.userAgent,
                    os = unknown;

                // A map of all the browser strings that we care about.
                var clientStrings = [{
                    s: 'Windows 3.11',
                    r: /Win16/
                }, {
                    s: 'Windows 95',
                    r: /(Windows 95|Win95|Windows_95)/
                }, {
                    s: 'Windows ME',
                    r: /(Win 9x 4.90|Windows ME)/
                }, {
                    s: 'Windows 98',
                    r: /(Windows 98|Win98)/
                }, {
                    s: 'Windows CE',
                    r: /Windows CE/
                }, {
                    s: 'Windows 2000',
                    r: /(Windows NT 5.0|Windows 2000)/
                }, {
                    s: 'Windows XP',
                    r: /(Windows NT 5.1|Windows XP)/
                }, {
                    s: 'Windows Server 2003',
                    r: /Windows NT 5.2/
                }, {
                    s: 'Windows Vista',
                    r: /Windows NT 6.0/
                }, {
                    s: 'Windows 7',
                    r: /(Windows 7|Windows NT 6.1)/
                }, {
                    s: 'Windows 8.1',
                    r: /(Windows 8.1|Windows NT 6.3)/
                }, {
                    s: 'Windows 8',
                    r: /(Windows 8|Windows NT 6.2)/
                }, {
                    s: 'Windows NT 4.0',
                    r: /(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/
                }, {
                    s: 'Windows ME',
                    r: /Windows ME/
                }, {
                    s: 'Android',
                    r: /Android/
                }, {
                    s: 'Open BSD',
                    r: /OpenBSD/
                }, {
                    s: 'Sun OS',
                    r: /SunOS/
                }, {
                    s: 'Linux',
                    r: /(Linux|X11)/
                }, {
                    s: 'iOS',
                    r: /(iPhone|iPad|iPod)/
                }, {
                    s: 'Mac OS X',
                    r: /Mac OS X/
                }, {
                    s: 'Mac OS',
                    r: /(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/
                }, {
                    s: 'QNX',
                    r: /QNX/
                }, {
                    s: 'UNIX',
                    r: /UNIX/
                }, {
                    s: 'BeOS',
                    r: /BeOS/
                }, {
                    s: 'OS/2',
                    r: /OS\/2/
                }, {
                    s: 'Search Bot',
                    r: /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask Jeeves\/Teoma|ia_archiver)/
                }];

                var i;
                for (i = 0; i < clientStrings.length; i++) {
                    var clientInfo = clientStrings[i];
                    if (clientInfo.r.test(userAgent)) {
                        os = clientInfo.s;
                        break;
                    }
                }

                // Now let's determine the OS
                var osVersion = unknown;

                // Special case for multiple Windows versions.
                if (/Windows/.test(os)) {
                    osVersion = /Windows (.*)/.exec(os)[1];
                    os = 'Windows';
                }

                // Handling Mac, Android and iOS...
                switch (os) {
                case 'Mac OS X':
                    osVersion = /Mac OS X (10[\.\_\d]+)/.exec(userAgent)[1];
                    break;

                case 'Android':
                    osVersion = /Android ([\.\_\d]+)/.exec(userAgent)[1];
                    break;

                case 'iOS':
                    osVersion = /OS (\d+)_(\d+)_?(\d+)?/.exec(appVersion);
                    osVersion = osVersion[1] + '.' + osVersion[2] + '.' + (osVersion[3] | 0);
                    break;
                }

                // Return the name of the OS and it's version number.
                return {
                    name: os,
                    version: osVersion
                };
            },

            /**
             * The name of the transition end event for a given transition prefix.
             *
             * @type {Object.<string, string>}
             */
            transEndEvtNames: {
                WebkitTransition: 'webkitTransitionEnd',
                MozTransition: 'transitionend',
                OTransition: 'oTransitionEnd',
                msTransition: 'MSTransitionEnd',
                transition: 'transitionend'
            },

            /**
             * The name of the animation end event for a given animation prefix.             *
             * @type {Object.<string, string>}
             */
            animationEndEvtNames: {
                WebkitAnimation: 'webkitAnimationEnd',
                OAnimation: 'oAnimationEnd',
                msAnimation: 'MSAnimationEnd',
                MozAnimation: 'animationend',
                animation: 'animationend'
            },

            /**
             * Replaces one Dom node in a DOM Doc with another.
             *
             * @param {HTMLElement|Node} target
             * @param {HTMLElement|Node} replacement
             *
             * @returns {HTMLElement|Node} The replacement element.
             */
            replace: function replace(target, replacement) {
                // Is there both a target AND a replacement node?
                if (target && replacement) {
                    // Is there a parent element?
                    var p = target.parentNode;
                    if (p) {
                        // Replace target in parent.
                        p.replaceChild(replacement, target);
                    }
                }

                // Return replacement;
                return replacement;
            },

            /**
             * Cross-browser wrapper for DOM2's addEventListener method, which in IE is called attachEvent.
             *
             * @param {HTMLElement|Node|Window} el The HTMLElement to attach an event listener to.
             * @param {string} eventName The name of event to listen for.
             * @param {Function} f The function to execute when the event occurs.
             * @param {boolean=} phase The event phase to capture (false for bubbles, true for capture).
             */
            attachEvent: function attachEvent(el, eventName, f, phase) {
                if (el.addEventListener) {
                    return el.addEventListener(eventName, f, !!phase);
                }

                return el.attachEvent('on' + eventName, f);
            },

            /**
             * Cross-browser wrapper for DOM2's removeEventListener method, which in IE is called detachEvent.
             *
             * @param {HTMLElement|Node} el The HTMLElement to attach an event listener to.
             * @param {string} eventName The name of event to listen for.
             * @param {Function} f The function to execute when the event occurs.
             * @param {boolean=} phase The event phase to capture (false for bubbles, true for capture).
             */
            detachEvent: function dom_detach(el, eventName, f, phase) {
                if (!el) {
                    return;
                }

                if (el.removeEventListener) {
                    el.removeEventListener(eventName, f, !!phase);
                } else {
                    el.detachEvent("on" + eventName, f);
                }
            },

            /**
             * <p>Cross-browser wrapper to allow attaching DOM events on a given element and raising an event to a given
             * mstrmojo widget.</p>
             *
             * @param {String} id The alpha-numeric mstrmojo id of the widget which needs to attach an event on it's markup.
             * @param {HTMLElement|Node} el The DOM element node to which the event needs to be attached.
             * @param {String} eventName The name of the event to attach on the DOM element.
             *
             * @return {Function} The event handler.
             */
            attachMarkupEvent: function attachMarkupEvent(id, el, eventName) {
                var fnEventHandler = function (e) {
                    mstrmojo.all[id].captureDomEvent(eventName, window, e);
                };

                this.attachEvent(el, eventName, fnEventHandler);

                // Return the event handler function which can be used to detach the event.
                return fnEventHandler;
            },

            /**
             * Attaches an event listener to a DOM node that will automatically be detached after it fires.
             *
             * @param {HTMLElement|Node} el The element to attach to.
             * @param {string} eventName The event to listen for.
             * @param {Function} f The function to listen for.
             * @param {boolean} [forceUnique=false] whether we want to avoid duplicate register same handlers
             *
             * @returns {Function}
             */
            attachOneTimeEvent: function attachOneTimeEvent(el, eventName, f, forceUnique) {
                // Create wrapper function so we can detach later.
                var fn = function (evt) {
                    // Call supplied function.
                    f(evt);

                    // Detach event.
                    if (forceUnique) {
                        detachUniqueEvent(this, eventName, fn);
                    } else {
                        mstrmojo.dom.detachEvent(this, eventName, fn);
                    }
                };

                // Attach event.
                if (forceUnique) {
                    attachUniqueEvent(el, eventName, fn);
                } else {
                    this.attachEvent(el, eventName, fn);
                }

                // Kill 'el' reference to avoid memory leaks.
                el = null;

                return fn;
            },

            /**
             * Attaches event listeners to the document for mousemove and mouseup that will automatically detach during mouseup.
             *
             * @param {function(evt:Event):boolean} fnMove The mouse move function to attach.
             * @param {function(evt:Event):boolean} [fnUp] An optional mouse up function that will be called during mouseup.
             */
            attachMouseMoveEvents: function attachMouseMoveEvents(fnMove, fnUp) {
                var $DOM = this,
                    fnMouseUp = function (evt) {
                        // Was a mouse up function supplied?
                        if (fnUp) {
                            fnUp(evt);
                        }

                        // Detach mouse event handlers.
                        $DOM.detachEvent(document, 'mousemove', fnMove);
                        $DOM.detachEvent(document, 'mouseup', fnMouseUp);
                    };

                // Attach mouse event handlers.
                $DOM.attachEvent(document, 'mousemove', fnMove);
                $DOM.attachEvent(document, 'mouseup', fnMouseUp);
            },

            /**
             * captures and processes a DOM event; usually called from event handler attached to DOM element.
             * event is passed to the object in the mstrmojo.all collection referenced by the id parameter.
             */
            captureDomEvent: function captureDomEvent(id, type, hWin, e, config) {
                var x = mstrmojo.all[id];
                if (x) {
                    x.captureDomEvent(type, hWin, e, config);
                }
            },

            /**
             * <p>Captures DOM event info during a drag into the properties of a given hash.</p>
             *
             * <p>The given hash represents the info for either the mouse down, mouse move, or
             * mouse up in a drag. The properties we capture specify what the event target DOM and position were.</p>
             *
             * @param {{hWin: window, e: Event}} info The hash table in which to record event info.
             * @returns {{hWin: window, e: Event, node: EventTarget, pos: {x: number, y: number}}} A copy of the original hash table.
             */
            captureEventInfo: function captureEventInfo(info) {
                // Copy info and make sure it has window and event.
                var rtn = mstrmojo.hash.copy(info, {}),
                    win = rtn.hWin = rtn.hWin || window,
                    evt = rtn.e = rtn.e || win.event;

                // Add event target and mouse position.
                rtn.node = this.eventTarget(win, evt);
                rtn.pos = this.getMousePosition(evt, win);

                return rtn;
            },

            /**
             * This method uses the Webkit's transform property to translate a DOM node. Based on whether the browser has been HW accelerated,
             * the method decides whether to use 'translate' or 'translate3d'.
             *
             * @param {HTMLElement} el The HTML DOM element that needs to be translated
             * @param {int} x The number of pixels (or percentage) to be moved along the x axis
             * @param {int} y The number of pixels (or percentage) to be moved along the y axis
             * @param {int} z The number of pixels (or percentage) to be moved along the z axis
             * @param {string=} extra Optional parameter: Any other extra CSS transform properties.
             * @param {boolean=} useTranslate3d Optional parameter helps in overriding the default device/browser behavior in using webkitTransforms.
             */
            translate: function translate(el, x, y, z, extra, useTranslate3d) {
                extra = (extra && ' ' + extra) || '';

                el.style[((mstrmojo.dom.isWinPhone || mstrmojo.dom.isIE9 || mstrmojo.dom.isIE10) ? 'ms' : 'webkit') + 'Transform'] = this.createTranslateString(x, y, z, useTranslate3d) + extra;
            },

            createTranslateString: function createTranslateString(x, y, z, useTranslate3d) {

                // Set the property to fit the transform string.
                x = setTranslateValue(x);
                y = setTranslateValue(y);
                z = setTranslateValue(z);

                return createTransformationString(x, y, z, useTranslate3d, 'translate');
            },

            createScaleString: function createScaleString(x, y, z, useScale3d) {

                //Set the property to fit the transform string.
                x = x || 0;
                y = y || 0;
                z = z || 0;

                return createTransformationString(x, y, z, useScale3d, 'scale');
            },

            /**
             * Number of milliseconds that an event is buffered by attachBufferedEvent methods.
             */
            _bufferSize: 200,

            /**
             * A lookup hash of buffer DOM attachments (plus timeout ids, listeners, etc) keyed by "<nodeid>-<event name>".
             */
            _bufferConnects: {},

            /**
             * Warning: this method assumes a single namespace for all node ids. Need to enhance it to support
             * nodes from different frames/windows with the same id.
             * Warning: this method assumes the given node has an id. That's done for performance reasons; it allows
             * us to cache info by node id in a hash; otherwise, we'd have to cache the node handle, which could be
             * risky for memory leaks, and would require using a cache array instead of hash, which would mean
             * slower performance for cache lookups.
             * Warning: buffered events will callback the given function with no arguments, so only use for
             * specific cases when your callback doesn't need the native DOM event object (because it will be long gone).
             *
             * @param {HTMLElement} el
             * @param {string} eventName
             * @param {Function} f
             * @param {number=} bufferSize
             *
             */
            attachBufferedEvent: function dom_attchbuf(el, eventName, f, bufferSize) {

                var key = el.id + '-' + eventName,
                    info = this._bufferConnects[key];

                if (!info) {
                    info = this._bufferConnects[key] = {
                        elId: el.id,
                        eventName: eventName,
                        timer: null,
                        bufferSize: bufferSize,
                        listeners: [],
                        callback: function (e) {
                            mstrmojo.dom._callback(e, mstrmojo.global, key);
                            return true;
                        }
                    };
                    this.attachEvent(el, eventName, info.callback);
                }
                info.listeners.push(f);
            },

            /**
             *
             * @param {Event} e
             * @param {Window} hWin
             * @param {string} key
             */
            _callback: function _callback(e, hWin, key) {
                var info = this._bufferConnects[key],
                    timer = info && info.timer;

                if (info && !timer) {
                    var ms = (info.bufferSize === null) ? this._bufferSize : info.bufferSize;

                    if (info.bufferSize) {
                        info.timer = hWin.setTimeout(function () {
                            mstrmojo.dom.updateBuffers(key);
                        }, ms);
                    } else {
                        // instant callback.
                        mstrmojo.dom.updateBuffers(key);
                    }
                }
            },

            /**
             *
             * @param {string} key
             */
            updateBuffers: function updateBuffers(key) {
                var info = this._bufferConnects[key],
                    ls = info && info.listeners,
                    len = (ls && ls.length) || 0,
                    i;

                for (i = 0; i < len; i++) {
                    ls[i]();
                }
                if (info && info.timer) {
                    delete info.timer;
                }
            },

            /**
             *
             * @param {HTMLElement} el
             * @param {string} eventName
             * @param {Function} f
             */
            detachBufferedEvent: function detachBufferedEvent(el, eventName, f) {
                if (!el) {
                    return;
                }

                var key = el.id + '-' + eventName,
                    info = this._bufferConnects[key],
                    ls = info && info.listeners,
                    len = (ls && ls.length) || 0,
                    i;

                if (len) {
                    for (i = len - 1; i > -1; i--) {
                        if (ls[i] === f) {
                            ls.splice(i, 1);
                        }
                    }

                    // if no listeners left, detach the callback and
                    // remove its entry in our lookup so we can reconnect in the future if needed.
                    if (!ls.length) {
                        this.detachEvent(el, eventName, info.callback);
                        delete this._bufferConnects[key];
                        if (info.timer) {
                            var global = /** @type {Window} **/ mstrmojo.global;
                            global.clearTimeout(info.timer);
                        }
                    }
                }
            },

            /**
             * Returns the target DOM node of a given DOM event.
             *
             * @param {Window} hWin
             * @param {Event} e
             *
             * @returns {EventTarget|Node}
             */
            eventTarget: function evtTgt(hWin, e) {
                e = getEvent(hWin, e);
                return e.target || e.srcElement;
            },

            isMac: function isMac() {
                return this.getOSInfo().name.toLowerCase().indexOf('mac') >= 0;
            },

            /**
             * Returns true if the CTRL key was pressed on Windows or the Command Key on a Mac during given DOM event.
             *
             * @param {Window} hWin
             * @param {Event} e
             *
             * @returns {boolean}
             */
            isMetaKey: function isMetaKey(hWin, e) {
                var isMac = this.getOSInfo().name.toLowerCase().indexOf('mac') >= 0,
                    evt = getEvent(hWin, e) || {};

                // Exclusively use the Ctrl Key on non-Macs and the meta key on Macs.
                return (evt.ctrlKey && !isMac) || (evt.metaKey && isMac);
            },

            /**
             * Returns true if the CTRL key was pressed during given DOM event.
             *
             * @param {Window} hWin
             * @param {Event} e
             *
             * @returns {boolean}
             */
            ctrlKey: function ctrl(hWin, e) {
                return (getEvent(hWin, e) || {}).ctrlKey;
            },

            /**
             * Returns true if the SHIFT key was pressed during given DOM event.
             *
             * @param {Window} hWin
             * @param {Event} e
             *
             * @returns {boolean}
             */
            shiftKey: function shift(hWin, e) {
                return (getEvent(hWin, e) || {}).shiftKey;
            },

            /**
             * Returns true if the META key was pressed during given DOM event.
             *
             * @param {window} hWin
             * @param {Event} e
             *
             * @returns {boolean}
             */
            metaKey: function meta(hWin, e) {
                return (getEvent(hWin, e) || {}).metaKey;
            },

            /**
             * Returns mouse button of event, 1 for left-click, 2 for right (middle is considered as left)
             *
             * @param {Window} hWin
             * @param {Event} e
             *
             * @returns {int}
             */
            getButton: function getButton(hWin, e) {
                return ((Number(getEvent(hWin, e).button)) === 2) ? 2 : 1;    // IE, Firefox, Chrome all treat right button as 2
            },

            /**
             * Determines if the mouse button associated with the Event is the primary button or not.
             *
             * @param {Event} e The mouse event.
             * @param {Window} [hWin=window] An optional containing window.
             *
             * @returns {boolean}
             */
            isPrimaryMouseBtn: function isPrimaryMouseBtn(e, hWin) {
                return this.getButton(hWin || window, e) === 1;
            },

            /**
             * Determines if the mouse action associated with the event is supposed to trigger the context menu.
             *
             * @param {Event} e The mouse event.
             * @param {Window} hWin The window.
             *
             * @returns {boolean}
             */
            isRMC: function isRMC(e, hWin) {
                return e && (e.button === 2 || e.type === "contextmenu" || // DE88918: Using e.type to detect mouse press for mobile
                    this.isMac() && this.ctrlKey(hWin, e) && e.button === 0); // DE3858: Mac Context menu CTRL+LMC
            },

            /**
             * Returns an object with the x and y positions of the mouse.
             *
             * @param {Event} e The HTML Event.
             * @param {Window=} hWin The window.
             *
             * @returns {{x: number, y: number}}
             */
            getMousePosition: function getMousePosition(e, hWin) {
                hWin = hWin || window;

                var x,
                    y;


                if (mstrmojo.dom.isIE) {
                    e = e || hWin.event;
                    // In IE, clientX and clientY are relative to the current scroll position, not to the document.
                    var d = document,
                        b = d.body,
                        de = d.documentElement;
                    x = e.clientX + b.scrollLeft + (de.scrollLeft || 0);
                    y = e.clientY + b.scrollTop + (de.scrollTop || 0);
                } else {
                    // In other browsers, pageX & pageY are relative to the document, independent of the scroll position.
                    x = e.pageX;
                    y = e.pageY;
                }

                return {
                    x: x,
                    y: y
                };
            },

            /**
             * Return the position and size of a dom node.
             * The position is relative to its owner document, if includeScroll = true.
             * Otherwise, relative to its client view port.
             * TO-DO: Consider move it to boxmodel.js.
             *
             * @param {Node|HTMLElement} el
             * @param {boolean=} includeScroll
             *
             * @returns {mstrmojo.PositionType}
             */
            position: function position(el, includeScroll) {
                var p = {
                    x: 0,
                    y: 0,
                    w: 0,
                    h: 0
                };

                // Does the browser support getBoundingClientRect?
                if (el && el.getBoundingClientRect) {
                    // Reset to client rect.
                    try {
                        // IE throws error if one of el's parents is removed from page and el becomes an orphan
                        p = el.getBoundingClientRect();
                    } catch (e) {
                        p = {
                            left: 0,
                            top: 0,
                            right: 0,
                            bottom: 0,
                            height: 0,
                            width: 0
                        };
                    }

                    // Change to x, y, w and h;
                    p = {
                        x: p.left,
                        y: p.top,
                        w: p.right - p.left,
                        h: p.bottom - p.top
                    };

                    // Is this IE7 and below?
                    if (this.isIE6 || this.isIE7) {
                        // Does the element have an owner document?
                        var ownerDocument = el.ownerDocument;
                        if (ownerDocument) {
                            // Adjust top and left.
                            var de = ownerDocument.documentElement,
                                deo = de.getBoundingClientRect();
                            p.x -= deo.left;
                            p.y -= deo.top;
                        }
                    }
                }

                // Should we adjust for scroll?
                if (includeScroll) {
                    var ds = docScroll();
                    p.x += ds.x;
                    p.y += ds.y;
                }

                return p;
            },

            /**
             * <p>Measures the delta position of one DOM node relative to another.</p>
             *
             * <p>Note: compared to offset, this one consider scroll.</p>
             *
             * @param {HTMLElement|Node} el
             * @param {HTMLElement|Node} elLimit
             *
             * @returns {{x: int, y: int}}
             */
            delta: function delta(el, elLimit) {
                elLimit = elLimit || document.body;
                var pe = this.position(el),
                    pr = this.position(elLimit);

                return {
                    x: Math.round(pe.x - pr.x),
                    y: Math.round(pe.y - pr.y)
                };
            },

            /**
             * Calculate the dimension of browser window.
             *
             * @returns {{w: int, h: int}}
             */
            windowDim: function windowDim() {
                var w = 0,
                    h = 0,
                    win = window,
                    d = document,
                    de = d.documentElement,
                    db = d.body;
                if (typeof(win.innerWidth) == 'number' && typeof(win.innerHeight) == 'number') {
                  w = win.innerWidth;
                  h = win.innerHeight;
                } else if (de  && (de.clientWidth || de.clientHeight)) {
                  w = de.clientWidth;
                  h = de.clientHeight;
                } else if (db && (db.clientWidth || db.clientHeight)) {
                    w = db.clientWidth;
                    h = db.clientHeight;
                }
                return {
                    w: w,
                    h: h
                };
            },

            /**
             * Position an element to the center of browser window.
             *
             * @param {HTMLElement} e The element to center.
             */
            center: function center(e) {
                alignDOM.call(this, e, CENTER, CENTER);
            },

            /**
             * Position an element to the bottom center of browser window.
             *
             * @param {HTMLElement} e The element to position.
             */
            bottomCenter: function bottomCenter(e) {
                alignDOM.call(this, e, CENTER, BOTTOM);
            },

            /**
             * Removes the native text highlight that browsers tend to do whenever
             * end-users do a SHIFT+click or CTRL+click.
             *
             * @param {Window=} hWin
             */
            clearBrowserHighlights: function clearBrowserHighlights(hWin) {
                hWin = hWin || self;

                if (!hWin.getSelection) {
                    var doc = hWin.document,
                        sel = doc && doc.selection,
                        em = sel && sel.empty;
                    if (em) {
                        try {
                            sel.empty();
                        } catch (ex) {
                            // TQMS# 337503: It seems that for an unknown reason the empty property sometimes can generate Runtime error, so swallow any errors.
                        }
                    }
                } else {
                    var gs = hWin.getSelection,
                        s = gs && hWin.getSelection();
                    if (s && !s.isCollapsed) {
                        if (s.empty) {
                            s.empty();
                        } else if (s.removeAllRanges) {
                            s.removeAllRanges();
                        }
                    }
                }
            },

            /**
             * <p>Searches for an ancestor of a given DOM node with a given HTML attribute.</p>
             *
             * <p>The attribute value may be any non-null value.   If a boolean flag is true,
             * the given DOM node is included in the search along with its ancestors.
             * If a limit node is given, the search stops when that limit is encountered (and
             * the limit itself is not tested).</p>
             *
             * @param {HTMLElement} el
             * @param {string} attr
             * @param {boolean} inclusive
             * @param {HTMLElement} elLimit
             * @returns {{node: HTMLElement, value: string}|null}
             */
            findAncestorByAttr: function fndAncAttr(el, attr, inclusive, elLimit) {
                var node = inclusive ? el : el && el.parentNode;
                while (node && (node !== elLimit)) {
                    var v = node.getAttribute && node.getAttribute(attr);
                    if (v != null) {
                        return {
                            node: node,
                            value: v
                        };
                    }
                    node = node.parentNode;
                }
                return null;
            },

            /**
             * Searches for an ancestor of a given DOM node with a given node name.
             * The attribute value may be any non-null value.   If a boolean flag is true,
             * the given DOM node is included in the search along with its ancestors.
             * If a limit node is given, the search stops when that limit is encountered (and
             * the limit itself is not tested).
             *
             * @param {HTMLElement} el
             * @param {string} nodeName
             * @param {boolean} inclusive
             * @param {HTMLElement} elLimit
             *
             * @returns {HTMLElement|null}
             */
            findAncestorByName: function fndAncNm(el, nodeName, inclusive, elLimit) {
                nodeName = nodeName && nodeName.toLowerCase();
                var node = inclusive ? el : el && el.parentNode;
                while (node && (node !== elLimit)) {
                    var n = node.nodeName;
                    if (n && (n.toLowerCase() === nodeName)) {
                        return node;
                    }
                    node = node.parentNode;
                }
                return null;
            },

            /**
             * <p>Returns true if a given DOM node is an ancestor of another given node.</p>
             *
             * <p>If a boolean flag is true, the latter node is included in the search.
             * If a limit node is given, the search stops when that limit is encountered (and
             * the limit itself is not tested).</p>
             *
             * @param {HTMLElement} elP The parent element to test.
             * @param {HTMLElement} elC The child element.
             * @param {boolean=} inclusive True if the search should start with the child element.
             * @param {HTMLElement=} elLimit An optional element that when encountered will stop the search.
             *
             * @returns {boolean}
             */
            contains: function cntns(elP, elC, inclusive, elLimit) {
                var node = elC;

                // Should we exclude the elC?
                if (!inclusive) {
                    // Start the search with the parent of elC.
                    node = node.parentNode;
                }

                while (node) {
                    // Is this node the target node?
                    if (node === elP) {
                        return true;
                    }

                    // Is the node the limit?
                    if (node === elLimit) {
                        break;
                    }

                    // Check the parent.
                    node = node.parentNode;
                }

                return false;
            },

            /**
             * Toggles the ability for text selection on the supplied {@link HTMLElement}.
             *
             * @param {HTMLElement} el The element whose selectability should be toggled.
             * @param {boolean} isSelectable Whether the item should be selectable.
             */
            toggleSelection: function toggleSelection(el, isSelectable) {
                // Set the unselectable attribute on the element.
                el.setAttribute('unselectable', isSelectable ? 'off' : 'on');

                // Toggle the unselectable CSS class on the element.
                mstrmojo.css.toggleClass(el, 'unselectable', !isSelectable);

                // Attach an event listener on select start to prevent any selections.
                el.onselectstart = function () {
                    return isSelectable;
                };

                // Clear previous highlight to deal with a timing issue.
                if (!isSelectable) {
                    this.clearBrowserHighlights();
                }

            },

            /**
             * Prevents the default event behavior.
             *
             * @param {Window|Object} hWin
             * @param {Event} e
             */
            preventDefault: function preventDefault(hWin, e) {
                e = e || hWin.event;

                if (e.preventDefault) {
                    e.preventDefault();
                } else {
                    e.returnValue = false;
                }
            },

            /**
             * Stops event propagation.
             *
             * @param {Window} hWin
             * @param {Event} e
             */
            stopPropogation: function stopPropogation(hWin, e) {
                e = e || hWin.event;

                if (e.stopPropagation) {
                    e.stopPropagation();
                } else {
                    e.cancelBubble = true;
                }
            },

            /**
             * Returns the first touch event from the touches collection.
             *
             * @param {Window} hWin
             * @param {{touches: Event[]}} e
             *
             * @returns {Event|undefined}
             */
            firstTouch: function firstTouch(hWin, e) {
                return e && e.touches && e.touches.length ? e.touches[0] : (e || hWin.event);
            },

            /**
             * Returns the first touch event from the changedTouches collection.
             *
             * @param {Window} hWin
             * @param {{changedTouches: Event[]}} e
             *
             * @returns {Event}
             */
            firstChangedTouch: function firstChangedTouch(hWin, e) {
                return e && e.changedTouches && e.changedTouches.length ? e.changedTouches[0] : (e || hWin.event);
            },

            /**
             * @returns {boolean}
             */
            isLandscape: function isLandscape() {
                return !this.supportsTouches || (Math.abs(window.orientation) === 90);
            },

            /**
             * <p>Finds the corresponding widget for a given DOM node.</p>
             *
             * <p>Searches the DOM node and its ancestors for an mstrmojoId expando property, which is assumed to
             * be set in the domNode of every widget to the widget's id.</p>
             *
             * @param {Node} el The DOM node.
             *
             * @returns {mstrmojo.Widget} The corresponding widget, if any; null otherwise.
             */
            findWidget: function findWidget(el) {
                while (el) {
                    var id = el.mstrmojoId;
                    if (id !== null && id !== undefined) {
                        return mstrmojo.all[id];
                    }
                    el = el.parentNode;
                }
                return null;
            },

            /**
             * Move caret to the specified position.
             *
             * @param {HTMLInputElement} el DOMNode to move its caret, like <INPUT>, <TextArea>
             * @param {int} pos  The number of character of the node's text content from the beginning
             */
            setCaret: function setCaret(el, pos) {
                if (el.setSelectionRange) {
                    el.focus();
                    el.setSelectionRange(pos, pos);

                } else if (el.createTextRange) { //IE7,8
                    var tr = el.createTextRange();
                    tr.move('character', pos);
                    tr.select();
                }
            },

            /**
             * Selects form control content. Not intended for other kinds of elements.
             *
             * @param {HTMLInputElement} el Form control to highlight, like <INPUT>, <TextArea>
             */
            setInputSelection: function setInputSelection(el) {
                if (el.select) {
                    el.focus();
                    el.select();
                } else if (el.createTextRange) { //IE7,8
                    el.createTextRange().select();
                }
            },

            /**
             * Selects element content.
             * NOTE: A side effect is that the element will get focused in IE7 and Chrome. IE8+ and Firefox don't have the problem.
             * @param {HTMLElement} el
             */
            setElementSelection: function setElementSelection(el) {
                if (window.getSelection) { // W3C
                    var range = document.createRange(),
                        selection = window.getSelection();

                    range.selectNodeContents(el);
                    selection.removeAllRanges();
                    selection.addRange(range);
                } else if (document.body.createTextRange) { // IE7,8
                    var textRange = document.body.createTextRange();
                    textRange.moveToElementText(el);
                    textRange.select();
                }
            },

            /**
             * Return the left position of the horizontal scroll bar
             *
             * @returns {number} x position
             */
            getHorizontalScroll: function getHorizontalScroll() {
                return docScroll().x;
            },

            /**
             * Return the top position of the vertical scroll bar
             *
             * @returns {number} y position
             */
            getVerticalScroll: function getVerticalScroll() {
                return docScroll().y;
            },

            /**
             *Return the max-height of scrollable popups
             *Since popup top/bottom border 1px, top/bottom padding 5px, and leave popup offset body top and body bottom 5px
             *@returns {number} the height of window minus 22px
             */
            getMaxScrollHeight: function getMaxScrollHeight() {
                return mstrmojo.dom.windowDim().h - 22;
            },

            /**
             *
             * @param scrollNode
             * @returns {*}
             */
            getComputedScrollbarWidth: function getComputedScrollbarWidth(scrollNode) {
                if (scrollNode) {
                    var style = mstrmojo.css.getComputedStyle(scrollNode);
                    if (style) {
                        return (scrollNode.offsetWidth - extractNumber(style.borderLeftWidth) - extractNumber(style.borderRightWidth) - scrollNode.clientWidth);
                    }
                }
                return null;
            },

            /**
             * Removes the element with the given id from the document
             * @param id - id of the element to be removed
             */
            removeNode: function removeNode(id) {
                var node = document.getElementById(id),
                    parentNode = node && node.parentNode;
                if (parentNode) {
                    return parentNode.removeChild(node);
                }
            },

            /*
             * Change the default behavior when click on the anchor element <a> for OneTier
             * Instead of opening the URL using current browser, we passing the href to formWrapper
             * and have one-tier controller to open the URL using system's default browser.
             * @param el - element that may contain anchor elements
             */
            redirectUrlToFormWrapper: function redirectUrlToFormWrapper(el) {
                var fn = function fn(evt) {
                    evt.preventDefault();
                    var anchor = evt.target,
                        href = anchor && anchor.href;
                    if (href && window && window.FormWrapper) {
                        window.FormWrapper.openPage(href.replace(/ /g, '%20'));
                    }
                };

                var achors = el && el.getElementsByTagName('a'),
                    cnt = achors.length;

                for (var i = 0; i < cnt; i++) {
                    if (!achors[i].openWithFormWrapper) {
                        achors[i].addEventListener('click', fn, true);
                        achors[i].openWithFormWrapper = true;
                    }
                }
            },

            /**
             * Check if the target node has the specified tag name
             * @param  {Node}  node    the target node
             * @param  {String}  tagName the specified tag name
             * @return {Boolean}
             */
            checkTagName: function checkTagName(node, tagName) {
                return node && node.tagName && node.tagName.toLowerCase() === tagName;
            },

            /**
             * 
             * Usage Example:
             * var computedMargin = mstrmojo.dom.getComputedMargin(targetNode);
             * computedMargin looks like [10, 10, 10, 10], in accordance with direction's definition for margin.
             * 
             * @desc Get target node's computed margin
             * @param {Node} node target DOM node to be processed
             * @return {Object} return an object with four properties: top/right/bottom/left.
             */
            getComputedMargin: function getComputedMargin(node) {
                var computedStyle = mstrmojo.css.getComputedStyle(node);

                return [
                    parseInt(computedStyle.marginTop, 10) || 0,
                    parseInt(computedStyle.marginRight, 10) || 0,
                    parseInt(computedStyle.marginBottom, 10) || 0,
                    parseInt(computedStyle.marginLeft, 10) || 0
                ];
            }
        }
    );
}());
(function () {
    var MOJO_REG_EXP = /^mstrmojo./;

    /**
     * Contains methods for dynamically creating class constructors.
     *
     * @namespace mstrmojo.DynamicClassFactory
     */
    mstrmojo.DynamicClassFactory = {

        /**
         * Creates a new class constructor.
         *
         * @param {Function} clazz The constructor to augment.
         * @param {Array.<Function>} mixins A collection of mixins for augmenting the supplied constructor.
         * @param {Object=} props Optional instance fields and methods for the new class.
         *
         * @returns {Function}
         */
        newComponent: function (clazz, mixins, props) {
            // Remove the front mstrmojo package name from constructor.
            var cacheName = clazz.prototype.scriptClass.replace(MOJO_REG_EXP, '');

            // Iterate mixins.
            for (var i = 0, cnt = mixins && mixins.length || 0; i < cnt; i++) {
                // Does the mixin NOT have a mixinName property?
                if (!mixins[i]._mixinName) {
                    // Throw.
                    throw new Error('Mixins must have a "_mixinName" property to be used with DynamicClassFactory');
                }

                // Remove the front mstrmojo package name from mixin and append to name.
                cacheName += '_' + mixins[i]._mixinName.replace(MOJO_REG_EXP, '');
            }

            // Does the constructor NOT already exist?
            var f = mstrmojo[cacheName];
            if (!f) {
                // Declare constructor and cache in mojo package (using derived name).
                f = mstrmojo.declare(clazz, mixins, props);
                mstrmojo[cacheName] = f;
            }

            // Return constructor.
            return f;
        }
    };
}());
(function () {



    function parseSetsAndCompareFunc(args) {
        var sets = [].slice.call(args),//make sure args is array
            last = sets[sets.length - 1],
            compareFunc = function (a, b) {
                return a === b;
            };

        // if the last parameter is a function|string, set it as compareFunc
        if (/function|string/.test(typeof last)) {
            compareFunc = typeof last === 'function' ? last : function (a, b) {
                return a[last] === b[last];
            };
            sets = sets.slice(0, sets.length - 1);
        }

        return {
            sets: sets,
            compareFunc: compareFunc
        };
    }

    /**
     * A utility class for working with arrays.
     *
     * @type {Object}
     */
    mstrmojo.array = mstrmojo.provide(
        "mstrmojo.array",

        /**
         * @lends mstrmojo.array
         */
        {

            /**
             * Searches a given array for a given item.
             *
             * @param {Array.<*>} arr The array to search.
             * @param {*} item The item to search for.
             *
             * @return {number} The index of the item if found; -1 otherwise.
             */
            indexOf: function indexOf(arr, item) {
                var len = (arr && arr.length) || 0,
                    i;

                for (i = 0; i < len; i++) {
                    if (arr[i] == item) {
                        return i;
                    }
                }
                return -1;
            },

            /**
             * <p>Searches a given array for given set of items and returns an object with:</p>
             *
             * <ul>
             *     <li>"indices": an array of indices, one for each given item (null, if not found);</li>
             *     <li>"map": a mapping of each found item, keyed by its index in "items" param, to the index where it was found in the "arr" param.</li>
             *     <li>"count": the number of items found, possibly 0;</li>
             * </ul>
             *
             * @returns {{
             *     indices: int[],
             *     map: Object.<int, *>,
             *     count: int
             * }}
             */
            indexOfMulti: function indexOfMulti(arr, items) {
                var indices = [],
                    map = {},
                    count = 0,
                    me = this;

                // Iterate source array.
                me.forEach(arr, function (srcItem, srcIdx) {
                    // Iterate test items array.
                    me.forEach(items, function (testItem, testIdx) {
                        // Do the items match?
                        var isItem = (testItem === srcItem);
                        if (isItem) {
                            // Cached index in indices and map and increment count.
                            indices[testIdx] = map[testIdx] = srcIdx;
                            count++;
                        }

                        // Return true if item was found so iteration halts.
                        return !isItem;
                    });
                });

                // Return result.
                return {
                    indices: indices.length ? indices : null,
                    map: map,
                    count: count
                };
            },

            /**
             * Calls a given function once per each item in a given array,
             * passing into that function 3 arguments: the item value, the
             * item index, and the array itself.
             *
             * @param {Array.<*>|NodeList} arr The Array to be iterated.
             * @param {function(value, index:int, arr:Array)} f The function to be run for each iteration.  The function will accept three parameters (value, index, arr) and if it explicitly returns false the
             *        iteration will be canceled.
             * @param {mstrmojo.Obj=} scope An optional scope for the passed function.
             * @returns {Array.<*>|NodeList}
             */
            forEach: function forEach(arr, f, scope) {
                var len = (arr && arr.length) || 0,
                    i;

                for (i = 0; i < len; i++) {
                    var isLast = i === (len - 1);

                    if (scope) {
                        if (f.call(scope, arr[i], i, arr, isLast) === false) {
                            break;
                        }
                    } else {
                        if (f(arr[i], i, arr, isLast) === false) {
                            break;
                        }
                    }
                }
                return arr;
            },


            /**
             *  <p> Creates a new array with the results of calling a provided function on every element in this array.</p>
             *
             *  @param {Array.<*>} arr The array to loop through.
             *  @param {function(element)} f The function to use to apply each element. The function must have a return value.
             *
             *  @return {Array.<*>}
             */
            map: function map(arr, f) {
                var len = (arr && arr.length) || 0,
                    ret = [],
                    i;

                for (i = 0; i < len; i++) {
                    ret[i] = f(arr[i], i);
                }

                return ret;
            },

            /**
             * <p>Returns the subset of a given array.</p>
             *
             * <p>The items of the subset are determined by a given filter function. The function receives
             * each item as the sole argument to the function, and those items
             * for whom the function returns truthy are included in the subset.</p>
             *
             * @param {Array.<*>} arr The array to filter.
             * @param {function(*, number, Array.<*>)} fnFilter The function to use to test each element.
             * @param {{max: int}=} config An optional configuration object with a max value corresponding to the number of elements to find.
             *
             * @returns {Array.<*>}
             */
            filter: function filter(arr, fnFilter, config) {
                var subset = [],
                    cnt = 0,
                    len = (arr && arr.length) || 0,
                    max = (config && config.max) || 0,
                    i;

                // Iterate array.
                for (i = 0; i < len; i++) {
                    // Should this element be included in the subset?
                    if (fnFilter(arr[i], i, arr)) {
                        // Add to subset.
                        subset[cnt] = arr[i];

                        // Increment counter.
                        cnt++;

                        // Is there a max AND have we exceeded it?
                        if (max && cnt >= max) {
                            // Halt iteration.
                            break;
                        }
                    }
                }

                return subset;
            },

            /**
             * Returns a single element from the given array using the fnFilter function to test.
             *
             * @param {Array} arr The array to filter.
             * @param {function(element)} fnFilter The function to use to test each element.
             *
             * @returns {*}
             */
            filterOne: function filterOne(arr, fnFilter) {
                // Use filter to find one element.
                var subset = this.filter(arr, fnFilter, {
                    max: 1
                });

                // Did we get a subset array back with at least one element?
                if (subset.length) {
                    // Return first element.
                    return subset[0];
                }

                // No item found so return null.
                return null;
            },

            /**
             * Wraps the parameter in an array if it's not already an array.
             *
             * @param {Array.<Object>|Object|undefined} arr
             *
             * @returns {Array.<Object>}
             */
            ensureArray: function ensureArray(arr) {
                return [].concat(arr || []);
            },

            /**
             * Returns the index of the first item in a given array whose given
             * property name matches a given value.  This is a faster alternative to
             * using filter() for a simple property-value search.
             *
             * @param {Array.<*>} arr The array to search.
             * @param {string} n The name of the property to match.
             * @param {*} v The value to match on.
             *
             * @return {number} The index of the found item (or -1 if not found).
             */
            find: function find(arr, n, v) {
                var len = (arr && arr.length) || 0,
                    i;

                for (i = 0; i < len; i++) {
                    var obj = arr[i];
                    if (obj && obj[n] == v) {
                        return i;
                    }
                }
                return -1;
            },

            /**
             * Returns the subset of a given array which removes the repetition (on a given property name if provided).
             * This is an algorithm with n^2 time complexity and improvement is needed in future.
             *
             * @param {Array.<*>} arr The array to search.
             * @param {string=} n Optional. The name of the property to match.
             *
             * @return {Array.<*>} The subset of the input array without repetition (on property n if provided).
             */
            distinct: function distinct(arr, n) {
                if (arr.reduce && !n) {
                    return arr.reduce(function (reducedArray, currentValue) {
                        // Does the current value exist in the reduced array ?
                        if (reducedArray.indexOf(currentValue) < 0) {
                            // If not - add it to the collection.
                            reducedArray.push(currentValue);
                        }

                        // Return the reduced array.
                        return reducedArray;
                    }, []);
                }

                var len = (arr && arr.length) || 0,
                    i,
                    obj,
                    subset = [];
                for (i = 0; i < len; i++) {
                    obj = arr[i];
                    if ((obj !== undefined) && ((n && this.find(subset, n, obj[n]) < 0) || (!n && this.indexOf(subset, obj) < 0))) {
                        subset.push(obj);
                    }
                }
                return subset;
            },

            /**
             * Binary search for an array item via comparison of a property.
             * Assumes the array is sorted (ascending) via the given property's value.
             * @param {Array.<*>} arr Array of items to be searched.
             * @param {Object} item Item whose property value is to be matched.
             * @param {string} p Name of property whose value is to be matched.
             * @param {number} [len] Length of given array; can be supplied as a performance optimization.
             */
            findBin: function fBin(arr, item, p, len) {
                var h = (len || arr.length) - 1,    // high
                    l = 0,                          // low
                    m,                              // medium
                    v = item[p];                    // value
                while (h - l > 1) {
                    if (arr[m = h + l >> 1][p] < v) { // a+b >> 1 is shortcut for parseInt((a+b)/2,10)
                        l = m;
                    } else {
                        h = m;
                    }
                }

                if (arr[l][p] === v) {
                    return l;
                }

                return arr[h][p] === v ? h : -1;
            },

            /**
             * Searches the provided array for an item that has a property p with a specified value.  The array must be
             * sorted in ascending order by the property p otherwise the results are undefined.  Both the property values
             * and the test value are assumed to be strings. The search is case INSENSITIVE.
             * The comparison of item property value against the test value is limited to the length on the test value.
             * If no match is found, this method returns the index into the array where an object with property p == test value
             * should be inserted to keep the array sorted.
             *
             * @param {Array.<*>} o Array to search
             * @param {string} v Value to search for in the array items property p
             * @param {string} p Name of property to use in comparisons
             * @return {number} The index of matching string or place to insert object with test value.
             */
            search: function search(o, v, p) {
                var h = o.length,
                    l = -1,
                    m,
                    val = v.toUpperCase(),
                    len = v.length;

                while (h - l > 1) {
                    if (o[m = h + l >> 1][p].substr(0, len).toUpperCase() < val) {
                        l = m;
                    } else {
                        h = m;
                    }
                }
                return h;
            },

            /**
             * Searches a given array for items which match a given set of items on a given property.
             *
             * @param {Array.<*>} arr The items to be searched.
             * @param {string} n The property name which will be used to match items.
             * @param {Array.<*>} items The items to be searched for.
             *
             * @return {Object} The search results object, with the following properties:
             *
             * <ul>
             *     <li>"indices": an array of indices, one for each given item (null, if not found);</li>
             *     <li>"count": the number of items found, possibly 0;</li>
             *     <li>"map": a mapping of each found item, keyed by its index in "items" param, to the index where it was found
             *                in the "arr" param.</li>
             * </ul>
             */
            findMulti: function idxOf(arr, n, items) {
                if (!items) {
                    return {
                        indices: null,
                        map: {},
                        count: 0
                    };
                }
                var len = items.length,
                    indices = [], // new Array(len), can not create fixed length array, since the items may have item not in the arr range.
                    map = {},
                    c = 0,
                    j = (arr && arr.length) || 0,
                    i;

                for (i = 0; i < j; i++) {
                    var a = arr[i][n],
                        k;

                    for (k = 0; k < len; k++) {
                        if (items[k][n] === a) {
                            indices[k] = i;
                            map[k] = i;
                            c++;
                            break;  // Assumes item won't be repeat in items
                        }
                    }
                }
                return {
                    indices: indices,
                    map: map,
                    count: c
                };
            },

            /**
             * Removes a given item from a given array, if found.
             *
             * @param {Array.<*>} arr The array to remove from.
             * @param {*} item The item to removed.
             *
             * @return {number} The index of the item that was removed (or -1 if not found).
             */
            removeItem: function removeItem(arr, item) {
                var i = this.indexOf(arr, item);
                if (i > -1) {
                    this.removeIndices(arr, i, 1);
                }
                return i;
            },

            /**
             * Searches a given array for items which match a given set of items on a given property, and
             * removes any of the matches found.
             *
             * @param {Array.<*>} arr The items to be searched.
             * @param {string} n The property name which will be used to match items.
             * @param {Array.<*>} items The items to be searched for.
             */
            removeItems: function removeItems(arr, n, items) {
                var ret = this.findMulti(arr, n, items);
                if (ret.count) {
                    // Sort the indices in ascending order, slice off the nulls (i.e., the not found).
                    var indices = ret.indices.concat().sort(this.numSorter).slice(0, ret.count),
                        i;
                    for (i = indices.length - 1; i > -1; i--) {
                        // TO DO: optimize this function to do splices in ranges, not individual items.
                        arr.splice(indices[i], 1);
                    }
                }
            },

            /**
             * Comparison function for sorting number data types. Used with Array.prototype.sort.
             */
            numSorter: function numSorter(a, b) {
                return Number(a) - Number(b);
            },

            stringSorter: function stringSorter(a, b) {
                var A = a.toLowerCase(),
                    B = b.toLowerCase();

                if (A < B) {
                    return -1;
                }

                if (A > B) {
                    return 1;
                }

                return 0;
            },

            /**
             * Removes a given range of indices from a given array.
             *
             * @param {Array.<*>} arr The array whose indices should be removed.
             * @param {number} start The starting index (0-based) of the indices to be removed.
             * @param {number} count The number of indices to be removed.
             */
            removeIndices: function removeIds(arr, start, count) {
                arr.splice(start, count);
            },

            /**
             * Inserts a given array of items into a given array at a given index.
             *
             * @param {Array.<*>} [arr] The array to be inserted into; if missing, a new array is created.
             * @param {number} idx The index at which to insert the new items.
             * @param {Array.<*>} items The items to be inserted.
             *
             * @return {Array.<*>} The array after insertion.
             */
            insert: function inst(arr, idx, items) {
                if (!arr) {
                    arr = [];
                }
                if (idx === null || idx === undefined) {
                    idx = arr.length;
                }
                Array.prototype.splice.apply(arr, [idx, 0].concat(items));
                return arr;
            },

            /**
             * <p>Creates a hash table of booleans from the contents of a given array.</p>
             *
             * <p>The array values are used as the hash keys; the hash values are all set to true.</p>
             *
             * @param {Array.<*>} arr The array from which to read the hash keys.
             * @param {Object=} h An optional hash that will be populated with the array properties.
             *
             * @return {Object} The new (or modified) hash table.
             */
            hash: function hash(arr, h) {
                h = h || {};
                var len = (arr && arr.length) || 0,
                    i;

                for (i = 0; i < len; i++) {
                    h[arr[i]] = true;
                }

                return h;
            },

            /**
             * Returns a list of the items at the given indices of an array.
             * @param {Array.<*>} arr The array whose items are to be read.
             * @param {Array.<int>} indices The list of indices at which the array will be read. If null, null is returned. If empty, an empty array is returned.
             *
             * @return {Array.<*>} The subset of array items at the requested indices; possibly empty or null.
             */
            get: function get(arr, indices) {
                if (!indices) {
                    return null;
                }
                var ret = [],
                    len = indices.length,
                    i;

                for (i = 0; i < len; i++) {
                    ret[i] = arr[indices[i]];
                }
                return ret;
            },

            /**
             * This function do a deep sort on array of array of objects based on a sortable object property.
             *
             * The object in the innermost array could have depth 2 or higher.
             *
             * @param {Array.<*>} arr Array to sort
             * @param {string} prop Property to sort on
             * @param {number} idx Index of the property in the object (0-based).
             * @param {boolean} asc
             *
             * var data = [ //all rows
             [ //row 1
             { //col 1
               text: 'r1 text 1',//text to display
               icon: 'r1 icon 1'
             },
             { //col 2
               text: 'r1 text 2',//text to display
               icon: 'icon 2'
             },

             { //col 3
               text: 'r1 text 3',//text to display
               icon: 'icon 3'
             }

             ],//end row1

             [ //row 2

             { //col 1
               text: 'r2 text 1',//text to display
               icon: 'r2 icon 1'
             },
             { //col 2
               text: 'r2 text 2',//text to display
               icon: 'r2 icon 2'
             },

             { //col 3
               text: 'r2 text 3',//text to display
               icon: ' r2 icon 3'
             }


             ], //end row2
             [ //row 3

             { //col 1
               text: 'ar3 text 1',//text to display
               icon: 'r3 icon 1'
             },
             { //col 2
               text: 'r3 text 2',//text to display
               icon: 'r3 icon 2'
             },

             { //col 3
               text: 'r3 text 3',//text to display
               icon: ' r3 icon 3'
             }


             ]//end row3
             ];

             Usage: Sort on 'text' whose index is 0 in the sample data 'col' object.
             deepSort(data, 'text', 0, true);
             */
            deepSortArr: function deepSortArr(arr, prop, idx, asc) {
                return arr.sort(function (a, b) {
                    var aProp = a[idx][prop],
                        bProp = b[idx][prop];

                    if (!asc) {
                        return (aProp <= bProp);
                    }

                    return (aProp > bProp) ? -1 : 1;
                });
            },

            isArray: function (obj) {
                var isa = Array.isArray;
                if (isa) {
                    return isa(obj);
                }
                //ie8
                return Object.prototype.toString.call(obj) === '[object Array]';
            },

            /**
             * <p>This method tests whether any element in the array will pass the test implemented by the provided function.</p>
             *
             * @param {Array.<*>} arr The array to validate.
             * @param {function(*, number=, Array.<*>=):boolean} fnSome The function used to test each element.
             *
             * @returns {boolean}
             */
            some: function some(arr, fnSome) {
                // Is the array undefined or null?
                if (!arr) {
                    // Not found.
                    return false;
                }

                // Does the array support the native some method?
                if (arr.some) {
                    // Use the native method.
                    return arr.some(fnSome);
                }

                // Assume result is false.
                var result = false;

                // Iterate array.
                this.forEach(arr, function (element, idx) {
                    // Evaluate current element.
                    result = fnSome(element, idx, arr);

                    // Return false if found (so iteration halts).
                    return !result;
                });

                // Return result.
                return result;
            },

            /**
             * Compute the set-theoretic difference for several arrays.
             * NOTE: The passed-in arrays should be sets, not multi-sets.
             *       The result of multi-sets is unpredictable.
             *       Passing [1,2,6,8,9] is fine, but passing [1,1,3,3,5] is not recommended.
             *
             * The result must be a subset of the first array.
             * For example:
             * - difference([1,2,3,4], [2,4,7,9]) will return [1,3]
             * - difference([1,2,3,5,6,7], [2,3,4], [4,5,6]) will return [1, 7]
             *
             * Moreover, you can pass a function as the last parameter, this function will
             * act as a compare function to determine whether two items are identical.
             *
             * For example:
             * - difference([{n: 1}, {n:2}, {n:3}], [{n:2}], function(a,b){return a.n === b.n})
             *   will get [{n: 1}, {n: 3}]
             *
             * Also, if you think your compare function is too simple to write a function, pass
             * a string to indicate the property you are comparing to is fine.
             *
             * For example:
             * - difference([{n: 1}, {n:2}, {n:3}], [{n:2}], 'n')
             *   will get [{n: 1}, {n: 3}]
             *
             * @returns Array
             */
            difference: function difference() {
                if (arguments.length < 2) {
                    throw new Error("difference should get at least 2 parameters");
                }

                var obj = parseSetsAndCompareFunc(arguments),
                    sets = obj.sets,
                    compareFunc = obj.compareFunc,
                    first = sets[0],
                    rest = [].concat.apply([], sets.slice(1)); // flatten the rest sets

                return first.filter(function (item) {
                    return !rest.some(function (rest_item) {
                        return compareFunc(item, rest_item);
                    });
                });
            },

            /**
             * Compute the set-theoretic intersection for several arrays.
             * NOTE: The passed-in arrays should be sets, not multi-sets.
             *       passing [1,2,6,8,9] is fine, but passing [1,1,3,3,5] is not recommended.
             *
             * For example:
             * - intersection([1,2,3,4], [2,4,7,9]) will return [2, 4]
             * - intersection([1,2,3,5,6,7], [2,3,4], [2,4,5,6]) will return [2]
             *
             * Moreover, you can pass a function as the last parameter, this function will
             * act as a compare function to determine whether two items are identical.
             *
             * For example:
             * - intersection([{n: 1}, {n:2}, {n:3}], [{n:2}], function(a,b){return a.n === b.n})
             *   will get [{n: 2}]
             *
             * Also, if you think your compare function is too simple to write a function, pass
             * a string to indicate the property you are comparing to is fine.
             *
             * For example:
             * - intersection([{n: 1}, {n:2}, {n:3}], [{n:2}], 'n')
             *   will get [{n: 2}]
             *
             * @returns Array
             */
            intersection: function intersect() {
                if (arguments.length < 2) {
                    throw new Error("intersection should get at least 2 parameters");
                }

                var obj = parseSetsAndCompareFunc(arguments),
                    sets = obj.sets,
                    compareFunc = obj.compareFunc,
                    result = sets[0],
                    rest = sets.slice(1);

                // intersect with every sets
                rest.forEach(function (_set) {
                    result = result.filter(function (item) {
                        return _set.some(function (item2) {
                            return compareFunc(item, item2);
                        });
                    });
                });

                return result;
            },

            /**
             * Static function used with Array.prototype.reduce to reduce a collection of numbers.
             *
             * @param {number} sum
             * @param {number} value
             *
             * @returns {Number}
             */
            fnReduceNumber: function fnReduceNumber(sum, value) {
                return sum + value;
            },

            /**
             * This function is used when calling fn.apply using a large array
             * (greater than 60k in some browsers) to prevent stack overflow.
             *
             * When we call fn.apply(ctx, array), the browser serializes it out to
             * fn(array[0], array[1], ..., array[n-1]). For really large arrays, this
             * will overflow the stack with arguments.
             * see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply
             *
             * @param arr - arguments array
             * @param fn - fn we want to call apply on
             * @param init - the default value to be returned. In most cases this can just be fn.apply(ctx, [])
             * @param ctx - the context for the apply function call
             */
            applyLargeArray: function applyLargeArray(arr, fn, init, ctx) {
                var len = arr.length,
                    blockCount = 1000,
                    start,
                    end,
                    tmp,
                    ret = init;

                if (len) {
                    for (start = 0, end = blockCount; start < len; start = end, end += blockCount) {
                        tmp = fn.apply(ctx, arr.slice(start, end));
                        ret = fn.apply(ctx, [ret, tmp]);
                    }
                } else {
                    // if the array is empty then return whatever the empty array value is for this function.
                    ret = fn.apply(ctx, arr);
                }

                return ret;
            }
        }
    );
}());
(function () {

    /**
     * A utility class to hold common box model operations.
     *
     * @namespace mstrmojo.boxmodel
     */
    mstrmojo.boxmodel = mstrmojo.provide(
        "mstrmojo.boxmodel",

        /**
         * @lends mstrmojo.boxmodel
         */
        {
            /**
             * Determines if two sets of points intersect.
             *
             * @param {int} top1
             * @param {int} bot1
             * @param {int} top2
             * @param {int} bot2
             *
             * @returns {boolean}
             */
            rangeIntersect: function rangeInt(top1, bot1, top2, bot2) {
                if (top1 < top2) {
                    return top2 <= bot1;
                }

                if (top1 > top2) {
                    return top1 <= bot2;
                }

                return true;
            },

            /**
             * Converts pixel units to inches.
             *
             * @param {{zf: number, dpi: int}} di A object with properties for zoom factor (zf) and DPI (dpi).
             * @param {string|int} v The pixel value.
             */
            px2Inches: function px2Inches(di, v) {
                // Convert to an integer.
                v = parseInt(v, 10);

                // Divide by zoom and dpi (limit to 4 decimals).
                //DE15100 format the number with locale
                return mstrmojo.NumberFormat.getInstance(mstrConfig.decimalSep, mstrConfig.thousandsSep).format(parseFloat((v / di.zf / di.dpi).toFixed(4)));
            },

            /**
             * Measures the offsetLeft and offsetTop of one DOM node relative to another.
             *
             * @param {HTMLElement} el The element whose offsets should be calculated.
             * @param {HTMLElement=} elLimit An optional element to be used as the basis for offset calculations.
             *
             * @returns {{left: int, top: int}}
             */
            offset: function offst(el, elLimit) {
                var org = el,
                    x = 0,
                    y = 0;

                while (el) {
                    x += el.offsetLeft;
                    y += el.offsetTop;
                    el = el.offsetParent;
                    if (el === elLimit) {
                        break;
                    }
                }
                // Now loop through the ancestors of the element, looking for any that have scrollTop/Left set.
                // Subtract these scrolling values from the total offset. However, we must be sure to stop the loop
                // before we reach document.body, or we'll take document scrolling into account
                // and end up converting our offset ot window coordinates.
                // TQMS 716812 Zhang, Hongchao 20130201
                var e;
                for (e = org && org.parentNode; e && e !== elLimit; e = e.parentNode) {
                    if (e.scrollTop) {
                        y -= e.scrollTop;
                    }
                    if (e.scrollLeft) {
                        x -= e.scrollLeft;
                    }
                }
                return {
                    left: x,
                    top: y
                };
            },

            /**
             * Converts em to pixels.
             *
             * @param {HTMLElement} el The dom node where the relative unit value associated.
             * @param {string} v The em values string.
             *
             * @returns {string} The supplied value, in pixels.
             */
            convert2px: function convert2px(el, v) {
                // Is the value NOT already in pixels?
                if (!/px$/.test(v)) {
                    var img = document.createElement('img'),
                        imgStyle = img.style,
                        pl;

                    imgStyle.zIndex = -1;
                    imgStyle.left = v;

                    el.appendChild(img);

                    // Get the pixel value.
                    pl = imgStyle.pixelLeft;
                    el.removeChild(img);

                    return pl + 'px';
                }

                return v;
            },

            /**
             * <p>Uses the diagonal lines equation to calculate which edge of the given position the given point is closest to.
             *
             * @param {mstrmojo.PositionType} position The position to test.
             * @param {{x: int, y: int}} point The point to test.
             *
             * @returns {String} Either 'Top', 'Right', 'Bottom' or 'Left', depending on which is closer to the point.
             */
            getEdgeQuadrantByPoint: function getEdgeQuadrantByPoint(position, point) {
                var x = point.x - position.x,
                    y = point.y - position.y,
                    w = position.w,
                    h = position.h,
                    quadrants = [
                        ['Left', 'Bottom'],
                        ['Top', 'Right']
                    ];

                // Is it less than the mid point?
                if (y > h / w * x) {
                    // Use left and bottom.
                    quadrants = quadrants[0];
                } else {
                    // Use top and right.
                    quadrants = quadrants[1];
                }

                return (y < -h / w * x + h) ? quadrants[0] : quadrants[1];
            },

            /**
             * Determines if a given point is contained within a polygon.
             *
             * @param {{x: int, y: int}} pt The point to test.
             * @param {Array.<{x: int, y: int}>} polygonVertices An array of polygon vertices.
             *
             * @returns {boolean}
             */
            isPtInPolygon: function isPtInPolygon(pt, polygonVertices) {
                // Extract point values and assume it doesn't intersect.
                var x = pt.x,
                    y = pt.y,
                    intersects = false;

                // Iterate vertices.
                polygonVertices.forEach(function (currentVertex, idx) {
                    // Get previous (or last) vertex.
                    var previousVertex = polygonVertices[idx - 1] || polygonVertices[polygonVertices.length - 1];

                    // Is y NOT on the same side of both vertices?
                    if ((currentVertex.y >= y) !== (previousVertex.y >= y)) {

                        if ((x < (previousVertex.x - currentVertex.x) * (y - currentVertex.y) / (previousVertex.y - currentVertex.y) + currentVertex.x)) {
                            intersects = !intersects;
                        }
                    }
                });

                return intersects;
            }
        }
    );
}());
(function () {
    //This class is borrowed from http://www.webtoolkit.info/javascript-base64.html
    var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        $FROM_CHAR_CODE = String.fromCharCode;

    function utf8Encode(string) {
        string = string.replace(/\r\n/g, "\n");
        var utfText = "";

        for (var n = 0; n < string.length; n++) {
            var c = string.charCodeAt(n);
            if (c < 128) {
                utfText += $FROM_CHAR_CODE(c);
            } else if ((c > 127) && (c < 2048)) {
                utfText += $FROM_CHAR_CODE((c >> 6) | 192);
                utfText += $FROM_CHAR_CODE((c & 63) | 128);
            } else {
                utfText += $FROM_CHAR_CODE((c >> 12) | 224);
                utfText += $FROM_CHAR_CODE(((c >> 6) & 63) | 128);
                utfText += $FROM_CHAR_CODE((c & 63) | 128);
            }
        }

        return utfText;
    }

    function utf8Decode(utfText) {
        var string = "",
            i = 0,
            c = 0, c1 = 0, c2 = 0;

        while (i < utfText.length) {
            c = utfText.charCodeAt(i);
            if (c < 128) {
                string += $FROM_CHAR_CODE(c);
                i++;
            } else if ((c > 191) && (c < 224)) {
                c1 = utfText.charCodeAt(i + 1);
                string += $FROM_CHAR_CODE(((c & 31) << 6) | (c1 & 63));
                i += 2;
            } else {
                c1 = utfText.charCodeAt(i + 1);
                c2 = utfText.charCodeAt(i + 2);
                string += $FROM_CHAR_CODE(((c & 15) << 12) | ((c1 & 63) << 6) | (c2 & 63));
                i += 3;
            }
        }
        return string;
    }

    /**
     * @namespace mstrmojo.base64
     */
    mstrmojo.base64 = mstrmojo.provide(
        "mstrmojo.base64",

        /**
         * @lends mstrmojo.base64
         */
        {
            /**
             * <p> Decode the Base64-encoded response header whose value are in the following format: "=?UTF-8?B?EncodedText?=" </p>
             *
             * @param {String} value The value of a response header.
             *
             * @returns {String} The decoded response header.
             */
            decodeHttpHeader: function decodeHttpHeader(value) {
                var rEncoded = /\=\?UTF-8\?B\?(.+?)\?\=/g;
                if (value && value.indexOf("=?UTF-8?B?") === 0) {
                    var decMsg = "", result;
                    while ((result = rEncoded.exec(value)) !== null) {
                        decMsg += mstrmojo.base64.decode(result[1]);
                    }
                    return decMsg;
                }
                return value;
            },

            /**
             * Use Base64 to encode a string input.
             *
             * @param {String} input A string value.
             *
             * @returns {String} The Base64 encoded string.
             */
            encode: function encode(input) {
                var output = "";
                var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
                var i = 0;

                input = utf8Encode(input);
                while (i < input.length) {
                    chr1 = input.charCodeAt(i++);
                    chr2 = input.charCodeAt(i++);
                    chr3 = input.charCodeAt(i++);

                    enc1 = chr1 >> 2;
                    enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                    enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                    enc4 = chr3 & 63;

                    if (isNaN(chr2)) {
                        enc3 = enc4 = 64;
                    } else if (isNaN(chr3)) {
                        enc4 = 64;
                    }

                    output += _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4);

                }
                return output;
            },

            /**
             * Decode a Base64 encoded string.
             *
             * @param {String} input A Base64 encoded string value.
             *
             * @returns {String} The decoded string.
             */
            decode: function decode(input) {
                var output = "", i = 0;
                var chr1, chr2, chr3, enc1, enc2, enc3, enc4;

                input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
                while (i < input.length) {
                    enc1 = _keyStr.indexOf(input.charAt(i++));
                    enc2 = _keyStr.indexOf(input.charAt(i++));
                    enc3 = _keyStr.indexOf(input.charAt(i++));
                    enc4 = _keyStr.indexOf(input.charAt(i++));

                    chr1 = (enc1 << 2) | (enc2 >> 4);
                    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
                    chr3 = ((enc3 & 3) << 6) | enc4;

                    output += $FROM_CHAR_CODE(chr1);

                    if (enc3 !== 64) {
                        output += $FROM_CHAR_CODE(chr2);
                    }
                    if (enc4 !== 64) {
                        output += $FROM_CHAR_CODE(chr3);
                    }
                }
                output = utf8Decode(output);
                return output;
            }
        }
    );
})();
(function () {

    /**
     * This mixin provides methods for opening and closing popups.
     *
     * @mixin
     * @public
     */
    mstrmojo._HasPopup = mstrmojo.provide(
        'mstrmojo._HasPopup',

        /**
         * @lends mstrmojo._HasPopup#
         */
        {
            _mixinName: 'mstrmojo._HasPopup',

            /**
             * The last opened popup.
             *
             * @type {Object}
             */
            _lastOpened: null,

            /**
             * <p>Opens a popup, applying a given (optional) config hash table of properties.</p>
             *
             * <p>A reference to the popup is provided, which may be either the ID of a widget, a config for a widget, or a handle to a widget.
             * The widget is assumed to implement the {@link mstrmojo._IsPopup} API.</p>
             *
             * @param {String|Object|Widget} ref The reference for the widget.
             * @param {Object} [config=undefined] An optional configuration for the popup.
             */
            openPopup: function openPopup(ref, config) {
                // If the given ref is a string with no periods, it is a property name which
                // holds the popup config.
                var isProp = !!ref && (typeof ref === "string") && !ref.match(/\./) && !!this[ref],
                    // Resolve the reference to the popup.
                    popup = mstrmojo.registry.ref(isProp ? this[ref] : ref);

                // Did the ref resolve to an object with an open method?
                if (popup && popup.open) {
                    // Dont cache popup handle in this._popup because this widget might support
                    // multiple popups.  If we want caching, we have to supply a property name for the ref.
                    // The resolve reference to the popup will be cached there.
                    if (isProp) {
                        this[ref] = popup;
                    }

                    // Push into the disposables array so that the popup would be destroyed when the host widget being destroyed.
                    if (popup.disposable !== false) {
                        this.addDisposable(popup);
                    }

                    // If the popup has a slot, insert the child into the slot.
                    var slot = popup.slot && this[popup.slot];
                    if (slot) {
                        if (popup.parent !== this) {
                            // The popup is not our child already.
                            if (this.addChildren) {
                                // We are a container, so add the popup as our child.
                                // That will ensure that its DOM gets inserted into our slot.
                                this.addChildren([ popup ]);
                            } else {
                                // We are not a container, so instead just manually insert the popup's
                                // domNode into our slot.  If the popup has no domNode yet, create a placeholder
                                // node for it in our slot.
                                // Warning: Don't call appendChild if the domNode is already in this slot; it
                                // causes repaint issues, such as resetting scrollTop = 0.
                                var skipCheck = false,
                                    el = popup.domNode || popup.placeholder;
                                if (el && typeof el === 'string') {
                                    el = document.getElementById(el);
                                }
                                if (!el) {
                                    skipCheck = true;
                                    el = document.createElement('span');
                                    popup.placeholder = el;
                                }
                                if (skipCheck || (el.parentNode !== slot)) {
                                    slot.appendChild(el);
                                }
                            }
                        }
                    }

                    // Catch the error so it doesn't affect the setting of the lastOpened property.
                    try {
                        popup.open(this, config);
                    } catch (e) {
                        console.log('Error opening popup: ' + e);
                    }
                    this._lastOpened = popup;
                }
            },

            /**
             * Closes the currently open popup, if any.
             */
            closePopup: function closePopup() {
                var popup = this._lastOpened;
                if (popup && popup.visible && popup.close) {
                    popup.close();
                    delete this._lastOpened;
                }
            }
        }
    );
}());
(function () {

    /**
     * <p>Helper class for working with hash objects..</p>
     *
     * @namespace mstrmojo.hash
     */
    mstrmojo.hash = mstrmojo.provide(
        "mstrmojo.hash",

        /**
         * @lends mstrmojo.hash
         */
        {
            /**
             * <p>Copies all of the members of a given source hash to another given destination hash.</p>
             *
             * <p>Any existing members in the destination whose names conflict will be overwritten.</p>
             *
             * @param {Object} src The source object whose properties/values should be copied.
             * @param {Object=} dest An optional hash to receive the copied properties/values.  If this parameter is undefined, an empty hash will be used.
             *
             * @returns {Object} The modified destination hash.
             */
            copy: function copy(src, dest) {
                if (src) {
                    dest = dest || {};

                    var n;
                    for (n in src) {
                        dest[n] = src[n];
                    }
                }
                return dest;
            },

            /**
             * <p>Copies an enumerated list of members of a given source hash to another given destination hash.</p>
             *
             * <p>Any existing members in the destination whose names conflict will be overwritten.  Only overwrites the value if the property is present in the source hash.</p>
             *
             * @param {string[]} ns An array of property names to be copied.
             * @param {Object} src The hash from which the property values should be copied.
             * @param {Object=} dest An optional hash to which the property values should be copied.  If this parameter is undefined, an empty hash will be used.
             *
             * @returns {Object} The modified destination hash.
             */
            copyProps: function copyProps(ns, src, dest) {
                // If destination is not there create one.
                dest = dest || {};

                if (src) {
                    // Iterate properties.
                    var length = (ns && ns.length) || 0,
                        i;

                    for (i = 0; i < length; i++) {
                        var n = ns[i];
                        // Does the property exist in the source hash?
                        if (src[n] !== undefined) {
                            // Overwrite the property value in the destination hash.
                            dest[n] = src[n];
                        }
                    }
                }
                return dest;
            },

            /**
             * <p>Iterates the supplied hash and calls the supplied function once for each item in the hash.</p>
             *
             * <p>The function is passed three parameters:</p>
             *
             * <ol>
             *  <li>The member value</li>
             *  <li>The member key</li>
             *  <li>The hash itself</li>
             * </ol>

             * @param {Object} hash The hash to be iterated.
             * @param {Function} f The function to be run for each iteration.
             * @param {Object=} scope An optional scope for the passed function.
             *
             * @returns {Object} The iterated hash object.
             */
            forEach: function forEach(hash, f, scope) {
                if (hash) {
                    var key;
                    for (key in hash) {
                        if (scope) {
                            if (f.call(scope, hash[key], key, hash) === false) {
                                break;
                            }
                        } else {
                            if (f(hash[key], key, hash) === false) {
                                break;
                            }
                        }
                    }
                }

                return hash;
            },

            /**
             * <p>Walks a given path of property names, starting with a context object.  If no context is given, the global context is assumed.</p>
             *
             * @param {string} path The path to be walked.
             * @param {Object} context The object to be walked.
             *
             * @returns {Object} The resolved path within the supplied context.
             */
            walk: function walk(path, context) {
                if (!context) {
                    context = mstrmojo.global;
                }

                var parts = path.split('.');
                if (parts.length === 1) {
                    return context[path];
                }

                var length = (parts && parts.length) || 0,
                    i;
                for (i = 0; i < length; i++) {
                    context = context[parts[i]];
                    if (!context) {
                        break;
                    }
                }
                return context;
            },

            /**
             * <p>Returns true if a given hash either:</p>
             *
             *  <ol>
             *      <li>is null or</li>
             *      <li>has no non-null property values.</li>
             *  </ol>
             *
             *  @param {Object} hash The hash object to evaluate.
             *
             *  @return {boolean}
             */
            isEmpty: function isEmpty(hash) {
                if (!hash) {
                    return true;
                }

                var k;
                for (k in hash) {
                    if (hash[k] !== null && hash[k] !== undefined) {  // is not null and not undefined
                        return false;
                    }
                }

                return true;
            },

            /**
             * <p>Removes all the properties of a given hash table.</p>
             *
             * @param {Object} h The hash table.
             * @returns {Object} The given hash table.
             */
            clear: function clear(h) {
                if (h) {
                    var k;
                    for (k in h) {
                        delete h[k];
                    }
                }

                return h;
            },

            /**
             * <p>Returns any (the first) property value encountered in a given hash if any; <i>undefined</i> otherwise.</p>
             *
             * <p>Similar in concept to reading the first item in an array, however no order is guaranteed for a hash's properties.</p>
             *
             * @param {Object} hash The hash to examine.
             * @param {boolean} [keyOrValue=false] Whether to look for the key (true) or the value (undefined|false).
             *
             * @returns {string|number|Object|undefined} Either the key, the value or <i>undefined</i>.
             */
            any: function any(hash, keyOrValue) {
                var rtn;

                // Was a hash provided?
                if (hash) {
                    // Get keys.
                    var keys = this.keyarray(hash); //Object.keys(hash); //IE8 does not support this api

                    // Is there at least one key?
                    if (keys.length > 0) {
                        // Set return value to either key or the value of the hash at that key.
                        var k = keys[0];
                        rtn = keyOrValue ? k : hash[k];
                    }
                }

                return rtn;
            },

            /**
             * <p>Creates a deep clone of a given hash (or array), meaning that any contained hash object (or arrays) are also cloned.</p>
             *
             * @param {Object|Array} obj The object (or array) to be cloned.
             *
             * @returns {Object|Array} The cloned object (or array).
             */
            clone: function clone(obj) {
                if (!obj) {
                    return null;
                }

                var c;
                if (obj.constructor === Array) {
                    // An array can be duplicated by concat, but that's only a shallow clone.
                    c = obj.concat();
                    // Check if we need to clone the array items too.
                    var first = c[0];
                    if (first && typeof first === 'object') {
                        var len = c.length,
                            i;
                        for (i = 0; i < len; i++) {
                            c[i] = this.clone(obj[i]);
                        }
                    }
                } else {
                    // Assume its a hash.
                    c = {};
                    var k;
                    for (k in obj) {
                        var v = obj[k];
                        // Check if we have a subobject/subarray to clone.
                        if (v && typeof v === 'object') {
                            // Nested object/array, clone recursively.
                            c[k] = this.clone(v);
                        } else {
                            // Scalar, just copy by value.
                            c[k] = v;
                        }
                    }
                }

                return c;
            },

            /**
             * <p>Clones an array.</p>
             *
             * @param {Array} arr The array to clone.
             *
             * @returns {Array} The cloned array.
             */
            cloneArray: function cloneArray(arr) {
                var arr2 = [],
                    len = (arr && arr.length) || 0,
                    i;

                for (i = 0; i < len; i++) {
                    arr2[i] = this.clone(arr[i]);
                }

                return arr2;
            },

            /**
             * Generates an array of the keys in a given hash.
             *
             * @param {Object} h The hash whose keys are to be inspected.
             * @param {boolean} [nums=false] If true, the values are treated as numbers for comparison.
             *
             * @returns {number[]|string[]} The array of hash keys.
             */
            keyarray: function kyarr(h, nums) {

                var arr = [],
                    k;
                if (h) {
                    if (Object.keys && !nums) {
                        arr = Object.keys(h);
                    } else {
                        for (k in h) {
                            arr.push(nums ? Number(k) : k);
                        }
                    }
                }
                return arr;
            },

            /**
             * Generates an array of the values in a given hash.
             * @param {Object} h The hash whose values are to be inspected.
             * @returns {Array} The array of hash values.
             */
            valarray: function varr(h) {
                var arr = [];
                if (h) {
                    var k;
                    for (k in h) {
                        arr.push(h[k]);
                    }
                }
                return arr;
            },
            /**
             * Returns whether the two hashes are the same.
             */
            equals: function eq(h1, h2) {
                // check null, equals when either both not null or both null
                var $HASH = mstrmojo.hash,
                    rtn = (h1 && h2) || (!h1 && !h2 && (h1 === h2));

                // for not null
                if (rtn && h1) {
                    // check constructor
                    rtn = (h1.constructor === h2.constructor);
                    if (rtn) {
                        // array type
                        if (h1.constructor === Array) {
                            var len = h1.length;
                            // check length
                            rtn = (len === h2.length);
                            // for same length and has items
                            if (rtn && len) {
                                // check each individual item
                                var i;
                                for (i = 0; i < len; i++) {
                                    rtn = rtn && $HASH.equals(h1[i], h2[i]);
                                }
                            }

                        // object type
                        } else if (typeof h1 === 'object') {
                            // check keys
                            var h1k = $HASH.keyarray(h1),
                                h2k = $HASH.keyarray(h2);

                            rtn = h1k.length === h2k.length;

                            if (rtn) {
                                var p;
                                for (p in h1) {
                                    rtn = rtn && ($HASH.equals(h1[p], h2[p]));
                                }
                            }

                        // primitive type
                        } else {
                            rtn = (h1 === h2);
                        }
                    }
                }

                return rtn;
            },
            /**
             * Traverse a json object and transform any of its Object property into an array
             * if it has a boolean property called "isArray" with value = true. It also assumes that this
             * Object property has another property called "length" indicating the length of the array.
             *
             * @param {{isArray:boolean}} o The hash to be transformed.
             *
             * @return {Array|Object} The object after being transformed.
             */
            obj2array: function obj2array(o) {
                var n;
                for (n in o) {
                    var p = o[n];
                    if (p && typeof p === 'object') {
                        o[n] = this.obj2array(p);
                    }
                }

                var isArray = o.isArray;
                if (isArray !== undefined && isArray === true) {
                    var r = [],
                        len = o.length,
                        i;

                    for (i = 0; i < len; i++) {
                        r.push(o[i]);
                    }

                    return r;
                }

                return o;
            },

            /**
             * Returns the smallest value in a given hash.
             *
             * @param {Object} h The hash to be inspected.
             * @param {boolean} [vals=false] If true, the hash values are inspected; otherwise, the hash keys are.
             * @param {boolean} [nums=false] If true, hash entries are treated as numbers for comparison.
             *
             * @returns {*}
             */
            min: function min(h, vals, nums) {
                var m = null,
                    k;

                if (h) {
                    for (k in h) {
                        var v = vals ? h[k] : k;
                        if (nums) {
                            v = Number(v);
                        }
                        if ((m === null) || (v < m)) {
                            m = v;
                        }
                    }
                }
                return m;
            },

            /**
             * Returns the largest value in a given hash.
             *
             * @param {Object} h The hash to be inspected.
             * @param {boolean} [vals=false] If true, the hash values are inspected; otherwise, the hash keys are.
             * @param {boolean} [nums=false] If true, hash entries are treated as numbers for comparison.
             *
             * @returns {*}
             */
            max: function max(h, vals, nums) {
                var m = null,
                    k;

                if (h) {
                    for (k in h) {
                        var v = vals ? h[k] : k;
                        if (nums) {
                            v = Number(v);
                        }
                        if ((m === null) || (v > m)) {
                            m = v;
                        }
                    }
                }
                return m;
            },

            /**
             * <p>Converts a given hash into an instance of a given javascript class.</p>
             *
             * <p>This method is typically used to make a native javascript Object into an observable object.
             * Unlike using a class constructor, this call enhances the given object rather than creating a new object.</p>
             *
             * @param {mstrmojo.Obj|{attachEventListener: function, init: function}} h The object (hash) to be converted.
             * @param {mstrmojo.Obj|{makeObservable: function, init: function}} c The instantiated class to which the given object will be converted.
             * @param {Object=} props Hash of properties to apply to the resulting class instance. Only used if the instance has an "init" method,
             *                     in which case the hash is passed in as a single argument to that method.
             *
             * @returns {Object} The same object passed in.
             * @static
             */
            make: function make(h, c, props) {
                if (!h || !c) {
                    return null;
                }

                if (h.attachEventListener) {
                    // Object is already observable. Don't try to re-register it.
                    return h;
                }

                if (c.makeObservable) {
                    h = c.makeObservable(h, props) || h;
                } else {
                    this.copy(c.prototype, h);
                    if (h.init) {
                        h = h.init(props) || h;
                    }
                }
                return h;
            },

            /**
             * Merges the hashes of the data and delta object which includes copying over primitive data properties,
             * concatenating arrays and recursively merging objects.
             *
             * @param {Object} data
             * @param {Object} delta
             *
             * @returns {Object} The merged hash.
             */
            mergeHashes: function mergeHashes(data, delta) {
                // Clone the data object so as to not change the original data.
                data = this.clone(data) || {};

                // Do we have a delta ? (If not there's no merge necessary.)
                if (delta) {
                    // Loop through all the object keys without duplicates
                    mstrmojo.array.forEach(mstrmojo.array.distinct(this.keyarray(delta).concat(this.keyarray(data))), function (k) {
                        // Do we have a key for it in the data ?
                        var dataValue = data[k],
                            deltaValue = delta[k];

                        // Does the key not exist on the data object ?
                        // US58460;dataValue is 0, should be kept
                        if (dataValue === undefined) {
                            // Add the delta value to the data object.
                            data[k] = deltaValue;

                        } else if (dataValue && deltaValue) {
                            // If we're dealing with objects - we may need to merge them recursively.
                            if (typeof dataValue === 'object') {
                                // Is this an array ?
                                if (dataValue.constructor === Array) {
                                    // Concatenate the two arrays.
                                    data[k] = dataValue.concat(deltaValue);
                                } else {
                                    // Recursively call merge hashes to merge them recursively.
                                    data[k] = this.mergeHashes(dataValue, deltaValue);
                                }
                            } else {
                                // For primitive data types - save it on the data.
                                data[k] = deltaValue;
                            }
                        }
                    }, this);
                }

                return data;
            },

            /**
             * Invert the key and value of a hash. Only invert number and string. Omit the others
             * @param {Object} h target hash
             * @returns {Object} The inverted hash
             */
            invert: function (h) {
                var o = {};

                if (h) {
                    var k;
                    for (k in h) {
                        if (h.hasOwnProperty(k)) {
                            if (typeof k === "number" || typeof k ==="string"){
                                o[h[k].toString()] = k;
                            }
                        }
                    }
                }

                return o;

            }
        }
    );
}());
(function() {

    mstrmojo.requiresDescs(9380, 9381, 9382, 9383, 9384, 9385, 9379, 15106, 15107, 10639, 10159, 9705, 9704);

    /**
     * @namespace
     */
    mstrmojo.DI.DIConstants = mstrmojo.provide("mstrmojo.DI.DIConstants",

        /**
         * @lends mstrmojo.DI.DIConstants
         */
        {

            invalidObjectNameChars: "\\\"[]",
            invalidObjectNameCharsRegex: /[\\"\[\]]/,

            /**
             * //mizhang TQMS 926462
             * Flags used to identify the link type for DISourceItem.
             */
            sourceItemLinkType: {
                dbList: 0,
                oauthPara: 1
            },
            //Default OAuth param value for building setting default value cmd.
            setDefaultOAuthParamCMD: "MSTR_DEFAULT_OAUTH_PARAMS",

            /**
             * Flags used to indicate imported Data from EMMA.
             */
            actions: {
                none: 0,
                importSource: 1,
                editImport: 2, //change sheets, insert column headers etc
                transform: 3,
                changeSheet: 4,
                publish: 5,
                changeMappings: 6,
                refine: 7,
                quickPreview: 8,
                savePublish: 9,
                getFlatPreview: 10,
                refreshData: 11,
                mergeCube: 12
            },

            /**
             * LocalStorage KeyName
             */
            localStorageKey: {
                HGOSFileTypeTooltipPop: "HGOSFileTypeTooltipPop"
            },
            /**
             * Flags used to indicate what information we want about the report definition from the backend.
             */
            requestFlag: {
                mapping: 0x01,
                preview: 0x02,
                sourceInfo: 0x04,
                refineSourceInfo: 0x08,
                sheets: 0x10,
                crb: 0x20,
                transformations: 0x40,
                transformedPreview: 0x80,
                relationship: 0x100,
                stateInfo: 0x200,
                anyState: 0x10000000,
                fullData: 0x400,
                refineInnerData: 0x800
            },

            /**
             * Flags used to indicate what information we want about the remove form mapping.
             */
            formMappingFlag: {
                formMappingFlagReserved: 0x00000000,
                formMappingFlagRemoveGeoRole: 0x00000001,
                formMappingFlagRemoveTimeRole: 0x00000002,
                formMappingFlagRemoveDeriveFlags: 0x00000004
            },

            /**
             * Browse flags used to indicate what information we want about the report definition from the backend.
             */
            browseFlag: {
                reportBindingTable: 0x01, // indicate we need the get btb property of data
                dataPreview: 0x04,
                publish: 0x10,
                cubeConfig: 0x44,
                reportLevelProperty: 0x100
            },

            /**
             * EnumDSSXMLBehaviorChangeFlags
             * Controlling certain aspects of the Data Import (Red Rocket) process.
             * These flags come through the IDC command's XML attribute: 'flags' ('fg')
             */
            importBehaviorFlag: {
                reserved: 0x0,

                // Specifies that the backend need not interrupt on republish when it finds new columns
                newColumnsSilent: 0x1,

                // Specifies that the backend need not interrupt on republish when it finds data type mismatches
                dataTypeSilent: 0x2
            },

            /**
             * Flags for Save As
             */
            saveAsFlags: {
                saveAsOverWrite: 0x20,
                saveAsManaged: 0x00080000,
                saveAsDDA: 0x02000000,
                saveAsInMemory: 0x04000000,
                saveAsWithPrompts: 0x1000,
                saveAsWithAnswers: 0x04
            },

            connectLiveSupport: {
                connectLiveSupportUnknown: 0,
                connectLiveSupportDDAOrInMemory: 1,
                connectLiveSupportInMemoryOnly: 2,
                connectLiveSupportDDAOnly: 3
            },

            /**
             * xda type of the data import cube
             */
            xdaType: {
                excel: 272,
                text: 288,
                refine: 384,
                salesforce: 337,
                querybuilder: 352,
                ffsql: 304,
                mdx: 2,
                customFreeFormSQL: 3,
                googleAnalytics: 390,
                googleBigQuery: 341,
                googleBigQueryFFSQL: 342,
                googleBigQuerySingleTable: 345,
                qbSingleTable: 368,
                twitter: 343,
                facebook: 344,
                dataImport: 0x00000100,
                projectsImport: 400,
                sparkDataset: 416,

                dataImportFileExcel: 0x00000010 | 0x00000100,
                dataImportFileText: 0x00000020 | 0x00000100,
                dataImportCustomSQL: 0x00000030 | 0x00000100,
                dataImportTable: 0x00000040 | 0x00000100,
                dataImportOAuth: 0x00000050 | 0x00000100,
                // a false xda type used only in client side.
                dataImportBISource: 0x00000090 | 0x00000100,

                dataImportOAuthSalesforce: 0x00000001 | 0x00000150,
                dataImportOAuthGDocs: 0x00000002 | 0x00000150,
                dataImportOAuthGDrive: 0x00000002 | 0x00000150,
                dataImportOAuthDropbox: 0x00000003 | 0x00000150,
                dataImportOAuthGAnalytics: 0x00000004 | 0x00000150,
                dataImportOAuthGBigQuery: 0x00000005 | 0x00000150,
                dataImportOAuthGBigQueryFFSQL: 0x00000006 | 0x00000150,
                dataImportOAuthGBigQuerySingleTable: 0x00000009 | 0x00000150,
                spark: 0x000000A0 | 0x00000100
            },

            fileTypes: [
                { "n": "CSV/TXT", "v": "CSV" },
                { "n": "PARQUET", "v": "PARQUET" },
                { "n": "AVRO", "v": "AVRO" },
                { "n": "ORC", "v": "ORC" },
                { "n": "JSON", "v": "JSON" },
                { "n": "PARQ", "v": "PARQUET", "visible": false }
            ],
            /**
             * backend source info des type
             */
            sourceInfoDesc: {
                json: "DB_FILE_TYPE_JSON"
            },

            /**
             * The type of the source that is used for data import
             */
            sourceType: {
                file: 1,
                salesforce: 2,
                dropbox: 3,
                googleDrive: 4,
                googleAnalytics: 5,
                googleBigQuery: 6,
                querybuilder: 7,
                mstrFile: 8,
                mdx: 9,
                hadoop: 10,
                twitter: 11,
                facebook: 12,
                bisource: 13,
                remoteProject: 14,
                //US56534: Import From Cube
                importfromcube: 15,
                // US61110: Web change for the new type connection cube
                dataFromPushApi: 16,
                newConnector: 17,
                cloudElement: 18
            },

            /**
             * The subtype of the source that is used for data import
             */
            sourceSubtype: {
                localFile: 1,
                url: 2,
                salesforce: 3,
                dropbox: 4,
                googleDrive: 5,
                googleAnalytics: 6,
                googleBigQuery: 7,
                querybuilder: 8,
                samplefile: 9,
                clipboard: 10,
                googleBigQueryFFSQL: 11,
                searchOnSource: 12,
                mdx: 13,
                hadoop: 14,
                twitter: 15,
                facebook: 16,
                bisource: 17,
                remoteProject: 18,
                googleBigQuerySingleTable: 19,
                hanaSingleTable: 20,
                publicData: 21,
                //US56534: Import From Cube
                importfromcube: 22,
                // US61110: Web change for the new type connection cube
                dataFromPushApi: 23,
                // Cloud Element Source
                cloudElement: 24,
            },

            /**
             * The subtype of the source as per the backend enumeration
             */
            backendSourceSubtype: {
                localFile: 65537,
                url: 65539,
                samplefile: 65540,
                clipboard: 65538,
                newConnector: 65544,
                cloudElement: 65552,
                hadoopFileBrowser: 0x00010005,
                customSQL: 0x00020001,
                customSQLWizard: 0x00020002,
                singleTable: 0x00020003,
                bISources: 0x00020004,
                searchAsASource: 0x00020006,
                salesforce: 0x00030001,
                dropbox: 0x00030002,
                facebook: 0x00030003,
                twitter: 0x00030004,
                googleDrive: 0x00030005,
                googleAnalytics: 0x00030006,
                googleBigQuery: 0x00030007,
                googleBigQueryFFSQLModel: 0x00030008,
                googleBigQuerySingleTable: 0x00030009,
                OLAPSources: 0x00050001,
                publicData: 0x00010006,
                // US61110: Web change for the new type connection cube
                dataFromPushApi: 0x00010007,
                // DE84292: Push Data Api V2
                dataFromPushApiV2: 0x00010009,
                // Cloud Element Source
                cloudElement: 0x00010010,
            },

            /**
             * Identifier for source items defined in _DISources.js
             */
            sourceItemType: {
                file: 0,
                url: 1,
                database: 2,
                hadoop: 3,
                olap: 4,
                publicData: 5,
                salesforce: 6,
                googleAnalytics: 7,
                googleBigQuery: 8,
                googleDrive: 9,
                dropbox: 10,
                searchAsASource: 11,
                clipboard: 12,
                bISources: 13,
                facebook: 14,
                twitter: 15,
                samplefile: 16,
                //US56534: Import From Cube
                importFromCube: 17,
                addNewConnector: 18,
                newConnector: 19,
                cloudElement: 20,
                unknow: -1
            },

            /**
             * State of the columns that are being imported. The main ones are new and missing.
             * We indicate whether the column is selected or nor using a separate property.
             */
            columnState: {
                reserved: 0,
                unchanged: 1,
                newColumn: 2,
                missing: 4,
                changed: 8
            },

            /**
             * Operation mode is the current operation done in data import
             *
             */
            operationMode: {
                create: 0,
                edit: 1,
                refresh: 2,
                subscribe: 3,
                enterCredentials: 4,
                oauth: 5, // OAuth landing
                pickTable: 6,
                hadoopPickTable: 7,
                ffsql: 8,
                hadoopFFsql: 9
            },

            /**
             * Special status code obtained when the data import is launched indicating why it is launched:
             * obtainSource: We could not obtain the source during refresh because the file is pointing to a local file.
             * xformsError: Transformations don't make sense during refresh.
             * mappingError: Some columns are missing during refresh
             * edit: Launched for editing an existing cube
             */
            statusCode: {
                obtainSource: -2147071874,
                xformsError: -2147071872,
                mappingError: -2147071871,
                edit: 1,
                republish: 2,
                schedule: 3,
                enterCredentials: 4,
                pickTable: 5,
                hadoopPickTable: 6,
                ffsql: 7,
                hadoopFFsql: 8
            },

            /**
             * Type of the page in the wizard
             *
             */
            pageType: {
                intro: 0,
                file: 1,
                database: 2,
                emmaPreview: 3,
                redirect: 4,
                analytics: 5,
                dataSelection: 6,
                suggestNewSource: 7,
                sourceIntro: 8,
                sourceObjects: 10,
                sampleFiles: 11,
                dataset: 12,
                externalPage: 13,
                preview: 14,
                clipboard: 15,
                refine: 16,
                parse: 17,
                mstrFile: 18,
                allProjectSource: 19,
                hadoop: 20,
                twitter: 21,
                facebook: 22,
                sourceObjectsDnD: 23,
                schedule: 24,
                publicData: 25,
                republish: 26,
                sourceAdmin: 27,
                //US56534: Import From Cube
                importFromCube: 28,
                addNewConnector: 29,
                newConnector: 30,
                addConnectorList: 31,
                cloudElement: 32
            },

            /**
             * Backend errors
             *
             */
            backendError: {
                // Overwrite an existing object which is not a cube error.
                overwriteObject: -2147212339,
                // No permission to overwrite an existing object.
                noPermission: -2147214579,
                // No permission to overwrite an existing object.
                invalidObjectName: -2147213715,
                // Unexpected data type error
                unexpectedDataType: -2147212539,
                // External Source session either does not exist or has expired
                noExternalSession: -2147071844,
                // You do not have sufficient privileges to perform the operation requested. Please contact your administrator.
                noPrivilege: -2147212082,
                // Cannot perform the operation requested because the report has not been saved. Please save the report and try again.
                salesforceUnsavedReport: -2147212081,
                // The report can no longer be edited or run. Your Salesforce administrator has disabled all reports for the custom object, or its relationships have changed.
                salesforceObsoleteReport: -2147212080,
                // Error in loading file. The governing maximum file size is exceeded. Check the file to import."
                maxSizeExceeded: -2147212076,
                // Error in uploading file from URL. The governing maximum file size is exceeded. Check the file to import."
                maxSizeExceededURL: -2147212121,
                // Error running a Salesforce report with any unresolved filter.
                salesforceUnresolvedFilter: -2147212074,
                // Incremental refresh of cube failed because the set of attributes is not the same as before. Please select Replace.
                incrementalRefresh: -2147212287,
                // Invalid URL error
                invalidUrl: -2147212062,
                // Excel 5.0/7.0 files are not supported. Save the file to Excel version 97/2000/XP/2003 or higher.
                fileVersionError: -2147212064,
                // Empty sheet
                emptySheet: -2147212144,
                // Error indicating that the External source user's refresh token is not in the backend datastructure.
                refreshTokenUnavailable: -2147202875,
                // Error indicating that the cube quota of teh user has exceeded the limit when they publish the cube.
                cubeQuotaExceeded: -2147071825,
                // ikakushadze 01/29/2014
                notEnoughSpace: -2147071811,
                //Error in loading file from URL. Check the URL.
                importedURLInvalid: -2147212122,
                // ikakushadze 12/03/2013 - TQMS 817155 - File being imported has unsupported CSV/text format.
                unsupportedFileFormat: -2147212063,
                // Object name too long. Only 250 characters allowed.
                objectNameTooLong: -2147217407,
                // Error in accessing information from the external data source
                noExternalSourceInfo: -2147215346,
                // ikakushadze 01/03/2014 - TQMS 818894. Memory consumption during data fetching limit is exceeded.
                // This may only for Dropbox
                memoryConsumptionExceeded: -2147215346,
                // ikakushadze 01/16/2014
                cubeQuotaReached: -2147071870,
                // ikakushadze 02/12/2014 - TQMS 8444023.
                switchingFileType: -2147212140,
                // YGUO TQMS-827151.Memory consumption during data fetching limit is exceeded.
                memoryGovernSizeExceeded: -2147181051,
                // String too long error
                stringTooLong: -2147213718,
                // AutoMapping Error: when we tried to to map the new dataset, we detected that some columns are missing or the data type change, etc
                missingColumn: -2147071871,
                //When publishing/republishing the cube and during polling, if there are any data discovery errors - missing columns, missing URL etc, then
                //backend throws this error.
                dataDiscoveryError: -2147211998,
                // refine: Apply operations failed
                refineApplyError: -2147202299,
                // muli. TQMS 902612.
                serverOutOfMemory: -2147212055,
                //Column count mismatch error
                columnCountMatchError: -2147467259,
                // Incompatible Data types
                incompatibleDataTypeError: -2147211983,
                // The job execution time limit set in MicroStrategy Intelligence Server has been exceeded
                reportTimeout: -2147212335,
                // Request timeout error when the backend takes too long to respond to a task
                requestTimeout: -2147206497,
                //We could not obtain the data because the database connection or warehouse table is changed
                databaseCredentialsNotAvailable: -2147212037,
                //Cannot perform the action since one of the cube support Direct Data Access only while the other is In-Memory only.
                ddasupportIncompatible: -2147215326,
                //Import from a cube of some XDAType is not supported, such as MDX, Search Engine Indices.
                mergeInvalidXdatype: -2147215325,
                //user don’t have full control for the merge cube.
                notFullyControl: -2147214579,
                //Error type: Data Import Error. For net work file, we only support importing through URL. Please check the location of the file.
                shouldBeIgnored: -2147212123,
                //Error when user don't have correct CE secret
                CECredentialNotAvailable: -2147215317,
                // authentication failed error
                AuthenticationError: -2147215346,
                //general error code from query engine:
                queryEngineGeneralError: -2147212544

            },

            /**
             * Type of the transformation
             *
             */
            transformation: {
                xtab: 1,
                delimiter: 2
            },

            /**
             * Type of the application
             *
             */
            application: {
                platform: "Platform",
                cloudPersonal: "Personal",
                cloudProfessional: "Professional"
            },

            /**
             * The type of refresh that needs to be done on the cube
             */
            refreshOptions: {
                replace: 1, //overwrite everything.
                append: 2, // keep exiting data and add to it.
                update: 4 //update existing data and add to it.
            },

            /**
             * EMMA table level refresh policy
             */
            cubeRefreshType: {
                dummy: -1, // only used in the refresh policy of All table level when some tables refresh policy are differnt from others
                reserved: 0,
                add: 1,
                remove: 2, // delete
                update: 3, // used, show in Status Dialog as Update
                upsert: 4, // used, show in Status Dialog as Upsert
                addNewTable: 5,
                deleteTable: 6,
                replaceTable: 7, // used, show in Status Dialog as Replace
                preserve: 8 // used, when user un-check the table, keep as it is
            },

            /**
             * EnumDSSTableStateExecutionAction
             * used for "Refresh Data" in edit mode
             */
            tableStatsExecutionAction: {
                reserved: 0,
                forceExecution: 0x1,
                ignore: 0x4,
                requireFreshData: 0x10000000
            },

            /**
             * The flags that can be passed to backedn when getting information about the external source
             */
            sourcesInfoFlags: {
                none: 0,
                getReports: 1,
                getUserName: 2,
                getTokensInfo: 4,
                revokeSession: 8,
                getGAnalyticsAccount: 64
            },

            /**
             * The type of query builder that launched from DI
             */
            queryBuilderType: {
                individualTable: 1,
                multipleTables: 2,
                queryScript: 3
            },

            relationshipEditType: {
                create: 1,
                changeERType: 2,
                remove: 3,
                // following types are defined by web server task
                flip: 8001
            },

            ERType: {
                reserved: 0,
                ERType11: 1,
                ERType1M: 2,
                ERTypeM1: 3,
                ERTypeMM: 4,
                ERTypeParallel: 5,
                ERTypePerpendicular: 6
            },

            RSType: {
                reserved: 0,
                auto: 1,
                geo: 2,
                defined: 3
            },

            /**
             * Table state enum to indicate if this table is a newly added table or existing table
             */
            tableStates: {
                newly: 1,
                old: 2
            },

            /**
             * fg of Auto-Mapping RM
             */
            behaviorChangeFlag: {
                multiSheet: 0x04,
                remapping: 0x08,
                refreshData: 0x10
            },

            menuItems: {
                SEPARATOR: -1,
                NONE: 0,
                TABLE_RENAME: 1,
                DO_NOT_IMPORT: 2,
                FLIP_ORDER: 3,
                DELETE: 4,
                RELATIONSHIP_TYPE: 5,
                ONE_TO_ONE: 6,
                ONE_TO_MANY: 7,
                MANY_TO_ONE: 8,
                MANY_TO_MANY: 9,
                REMOVE: 10,
                REFRESH_DATA: 11,
                REFINE: 12,
                CANCEL_REFINE: 13,
                UNLINK: 14,
                CHANGE_DATA_TYPE: 15,
                MARK_GEO_ROLES: 16,
                CREATE_TIME_ATTRIBUTES: 17,
                TO_METRIC: 18,
                TO_ATTRIBUTE: 19,
                MAP_TO_PROJECT_ATTRIBUTE: 20,
                UNMAP: 21,
                MODIFY_ATTRIBUTE_GROUP: 22,
                CREATE_ATTRIBUTE_GROUP: 23,
                HIDE_ALL_ATTRIBUTE_FORMS: 24,
                //REFRESH_DATA_OPTIONS: 24,
                DEFINE_RELATIONSHIPS: 25,
                LINK: 26,
                ITEM_RENAME: 27,
                CREATE_MULTIFORM_ATTRIBUTE: 28,
                EDIT_MULTIFORM_ATTRIBUTE: 29,
                ADDTO_MULTIFORM_ATTRIBUTE: 30,
                SHOW_ALL_ATTRIBUTE_FORMS: 31,
                SHOW_ALL_COLUMNS: 32,
                PARTITION: 33,
                REFINE_RENAME: 34,
                REFINE_DELETE: 35,
                REFINE_DELETE_ALL: 36,
                REFINE_RESET: 37,
                REFINE_RESET_ALL: 38,
                PARSE: 39,
                IMPORT: 40,
                UNLINK_ALL: 41,
                CREATE_HIERARCHY_ATTRIBUTE: 42,
                EDIT_HIERARCHY_ATTRIBUTE: 43,
                RESET_HIERARCHY_ATTRIBUTE: 44

            },

            /**
             * Baseform Type Enum
             */
            dataTypeMenuItems: {
                DATE_TIME: '1',
                NUMBER: '2',
                TEXT: '3',
                URL: '5',
                EMAIL: '6',
                HTML_TAG: '7',
                DATE: '8',
                TIME: '9',
                SYMBOL: '10',
                BIG_DECIMAL: '11',
                PHONE_NUMBER: '12'
            },

            /**
             * Column Data Type Enum
             * @link http://vm-xda-btc/wiki/index.php/TABLE:EnumDSSDataType
             */
            columnDataTypes: {
                reserved: 0, //unknown
                integer: 1, //signed integer
                unsigned: 2, //unsigned integer
                numeric: 3, //number with exact precision and scale
                decimal: 4, //similar to ric , actual precision may be larger
                real: 5, //single precision real number, 4 bytes
                dtdouble: 6, //double precision real number, 8 bytes
                dtfloat: 7, //floating point number with precision
                dtchar: 8, //fixed length character string
                varChar: 9, //variable length character string
                longVarChar: 10, //variable length char data up to 2GB
                binary: 11, //fixed length binary data
                varBin: 12, //variable length binary data
                longVarBin: 13, //variable length binary data, up to 2GB
                date: 14, //date: containing year, month and day
                dttime: 15, //time: hour, minute, second and fraction of second
                timeStamp: 16, //include both data and time.
                nChar: 17,
                nVarChar: 18,
                nlong: 22,
                bigDecimal: 30,
                cellFormatData: 31,
                utf8Char: 33,
                int64: 34 //big integer
            },

            formsOptions: {
                CREATE_MULTIFORM_ATTRIBUTE: 1,
                EDIT_MULTIFORM_ATTRIBUTE: 2,
                ADDTO_MULTIFORM_ATTRIBUTE: 3
            },

            hierarchyOptions: {
                CREATE_HIERARCHY_ATTRIBUTE: 1,
                EDIT_HIERARCHY_ATTRIBUTE: 2,
                RESET_HIERARCHY_ATTRIBUTE: 3
            },

            rdcsFlag: {
                ID: 1,
                JOIN_ID: 2,
                FILTER_ID: 3,
                DISTANCE: 4
            },

            timeRoles: {
                NONE: 0,
                DATE: 1,
                DATE_TIME: 2,
                TIME: 3,
                SECOND: 4,
                MINUTE: 5,
                HOUR: 6,
                DAY: 7,
                WEEK: 8,
                MONTH: 9,
                QUARTER: 10,
                YEAR: 11
            },

            contextMenuType: {
                ITEM_MENU: 0,
                TABLE_MENU: 1,
                PREVIEW_ITEM_MENU: 2,
                LINK_MENU: 3
            },

            dialogType: {
                fixRefreshErrorDialog: 1,
                allObjectsViewDialog: 2,
                missingColumnsDialog: 3,
                diPageDialog: 4,
                refreshHistoryDialog: 5,
                alternateSourceValidateDialog: 6,
                ddaConfirmDialog: 7,
                publishStatusDialog: 8,
                saveAsDialog: 9,
                cubesList: 10,
                refinePage: 11,
                multiFormEditor: 12,
                sheetsSelectionDialog: 13,
                partitionGroupDialog: 14,
                parseDataDialog: 15,
                errorDialog: 16,
                warningDialog: 17,
                relationDefineDialog: 18,
                qbImportOptionDialog: 19,
                previewRenameDialog: 20,
                mapProjectsAttributeDialog: 21,
                setOAuthParaDialog: 22,
                objectPicker: 23,
                refineClusteringPage: 24,
                refineExtractDialog: 25,
                refineImportDialog: 26,
                twitterAdvOptDialog: 27,
                credentialsDialog: 28,
                mapProjectsAttributeDialog2: 29,
                setWhiteListDialog: 30,
                binaryUploadDialog: 31,
                authenticationDialog: 32,
                sharingDialog: 33,
                hadoopGatewayManagerDialog: 34,
                hadoopGatewayDialog: 35,
                addConnectorDialog: 36,
                hierarchyAttributeDialog: 37,
                hierarchyAttributeResetDialog: 38
            },

            dataEvents: {
                DATA_PREVIEW_EVENT: "dataReturned",
                NO_DATA_RETURNED_EVENT: "noDataReturned"
            },

            cubeSchedStatus: { // TQMS 988933: change enum order to adjust default sort order
                unexecuted: 1,
                successful: 2,
                unscheduled: 3,
                failed: 4
            },

            /**
             * The constants for the different data import privileges
             */
            privilegeType: {
                accessDatabase: 1,
                accessFile: 2,
                accessCloud: 3
            },

            dbType: {
                MS_ACCESS: 100,
                ORACLE: 200,
                SQL_SERVER: 300,
                INFORMIX: 400,
                SYBASE: 500,
                REDBRICK: 600,
                DB2: 700,
                TANDEM: 800,
                TERADATA: 900,
                UNKNOWN: 1000,
                GENERIC: 1100,
                SAP: 1200,
                NETEZZA: 1300,
                EXCEL: 1400,
                MSFT_AS: 1500,
                ESSBASE: 1600,
                MYSQL: 1700,
                POSTGRESQL: 1800,
                HPNEOVIEW: 1900,
                METAMATRIX: 2000,
                DATALLEGRO: 2100,
                COMPOSITE: 2200,
                ASTER: 2300,
                VERTICA: 2400,
                OPENACCESS: 2500,
                SYBASE_SQL_ANY: 2600,
                SYBASE_IQ: 2700,
                PARACCEL: 2800,
                TM1: 2900,
                XQUERY: 3000,
                HIVE: 3100,
                SAND: 3200,
                SALESFORCE: 3300,
                HIVETHRIFT: 3400,
                VECTORWISE: 3500,
                ENTERPRISEDB: 3600,
                KOGNITIOWX2: 3700,
                EXASOLUTION: 3800,
                INFORMATICA: 3900,
                SAPHANA: 4000,
                IMPALA: 4100,
                AMAZON_REDSHIFT: 4200,
                DENODO: 4300,
                GOOGLE_DRIVE: 4400,
                DROPBOX: 4500,
                GOOGLE_ANALYTICS: 4600,
                GOOGLE_BIGQUERY: 4700,
                CONNECTION_CLOUD: 4800,
                GOOGLE_BIG_QUERY_FFSQL_MODEL: 4900,
                PARSTREAM: 5100,
                MONGODB: 5200,
                MARKLOGIC: 5300,
                BIG_DATA_ENGINE: 5400,
                SEARCH_ENGINE_SOLR: 5500,
                SPLUNK: 5600,
                TWITTER: 5700,
                FACEBOOK: 5800,
                PIG: 6400,
                URL: 7700,
                newConnector: 7900,
                LOACLFILE: 8200
            },

            /**
             * Option flag to indicate which objects are required.
             */
            getCubeQuotaAndInfosOptions: {
                GetCubeQuotaAndInfosReserved: 0,
                GetCubeQuotaAndInfosDefault: 1,
                GetCubeQuotaAndInfosQuotaOnly: 2,
                GetCubeQuotaAndInfosAll: 3,
                GetCubeQuotaAndInfosVI: 4
            },
            /**
             * View mode of DI homepage
             */
            homepageViewMode: {
                GRID_VIEW: 0,
                LIST_VIEW: 1
            },

            /**
             * Dataset serve mode enum
             */
            datasetServeMode: {
                inMemory: 1,
                dda: 2,
                unknow: 3
            },

            /**
             * report/cube execute status, part of EnumDSSXMLStatus
             */
            cubePollStatus: {
                msgID: 0,
                result: 1,
                prompt: 2,
                error: 3,
                xmlResult: 21
            },

            // all IBM DB2 versions
            ibmDb2Versions: [17, 18, 21, 22, 23, 24, 25, 37, 45, 46, 47, 48, 63, 66, 74, 89, 92, 101, 103, 105, 123, 134, 157, 172, 202, 232],

            // db types of Hadoop
            hadoopDbTypes: [3100, 1100, 700, 4100, 7300, 6800, 6400, 8100],


            // form category lookup
            formCategory: {
                longitude: "2345134F4F5E261C3BB902A874467080",
                latitude: "B191051C48221A6AE44CA2B65B1B65E3"
            },

            urlAuthDBRoles: {
                anonymous: "CB1CB472A07E41D5AE038232839F2064",
                windows: "95A5ACC02FE94CBABCB65E4F2D2415B2",
                kerberos: "317D6F016D784836A724AD4D739E1E9C",
                integrated: "E966E1A0A4C949108287B2E5086B68EB"
            },

            urlAuthDBMSId: "497F2406FA154B86810C71EA3D401D6D",

            newConnectorDBMSId: "565D5DC3A1124726B85FE53EF992472A",

            hadoopGateWay: {
                HGoS_CONFIG_HAS_EXIT: 1510,
                CONNOT_AUTHENTICATE: 1511,
                SPACE_OVER: 1512,
                FAIL_COPY_TO_HOST: 1513,
                INSUFFICIENT: 1514,
                DIRECTORY_NO_EXIST: 1515,
                HGOS_DEPLOYED: 1518,
                HGOS_DEPLOYING: 1519,
                CONNOT_AUTHENTICATE2: 1520,
                HGOS_RUNNING: 1521,
                HGOS_STOPPED: 1522,
                HGOS_NOT_DEPLOYING: 1523,
                HGOST_TAR_NOT_EXIST: 1524,
                HGOS_CONF_NOT_EXIST: 1530
            },

            workstation: {
                filerBreakLine: new RegExp('[\r\n]', 'g'),
                utils: {
                    shouldShowTitleBar: function() {
                        var inPageDialog = mstrApp.getRootController().rootView.inPageDialog;
                        return !!mstrApp.isWorkstation && (!!mstrApp.isPopup || !!inPageDialog);
                    },
                    setNativeWindow: function(w, h) {
                        var minW = 1110,
                            minH = 590,
                            width = parseInt(w, 10),
                            height = parseInt(h, 10);

                        if (!window.FormWrapper || !window.FormWrapper.setWindowFrame) {
                            return;
                        }
                        if (w.match(/%$/) && h.match(/%$/)) {
                            /**
                             * @param width {number}
                             * @param height {number}
                             */
                            window.FormWrapper.setWindowContentSize(1200, 680);
                        } else {
                            width = width < minW ? minW : width;
                            height = height < minH ? minH : height;
                            window.FormWrapper.setWindowContentSize(width, height);
                        }

                    },
                    lockResize: function() {
                        if (!window.FormWrapper || !window.FormWrapper.lockResize) {
                            return;
                        }
                        window.FormWrapper.lockResize();
                    },
                    unlockResize: function() {
                        if (!window.FormWrapper || !window.FormWrapper.unlockResize) {
                            return;
                        }
                        window.FormWrapper.unlockResize();
                    }
                }

            },

            authMode: {
                ANONYMOUS: 0,
                USERNAME: 1,
                OAUTH: 2
            },

            authModePrefix: {
                ANONYMOUS: "AuthMode=Anonymous;URL=",
                USERNAME: "AuthMode=Basic;URL=",
                OAUTH: "AuthMode=OAuth;URL="
            },

            sdkUrl: {
                MARKPLACE_URL: "https://community.microstrategy.com/s/gallery?tabset-89baf=202df",
                QUICK_START_URL: "https://lw.microstrategy.com/msdz/MSDL/GARelease_Current/docs/projects/DataConnectorSDK/Content/topics/Quick_Start_Guide.htm"
            },

            originalConnector: {
                elastic: 'DE4A8E15405A36D80BF1E1A2BA6F9B66',
                tapClicks: '1E8ADD3975DA4609B8D00E6211ACAB6A'
            },

            googleAnalyticsUrl: {
                queryExplorer: 'https://ga-dev-tools.appspot.com/query-explorer/'
            },
            // US78530 generate the day list of one whole week
            weekDay: [
                { 'n': mstrmojo.desc(9380, "Monday"), 'v': 0 },
                { 'n': mstrmojo.desc(9381, "Tuesday"), 'v': 1 },
                { 'n': mstrmojo.desc(9382, "Wednesday"), 'v': 2 },
                { 'n': mstrmojo.desc(9383, "Thursday"), 'v': 3 },
                { 'n': mstrmojo.desc(9384, "Friday"), 'v': 4 },
                { 'n': mstrmojo.desc(9385, "Saturday"), 'v': 5 },
                { 'n': mstrmojo.desc(9379, "Sunday"), 'v': 6 }
            ],

            // US78530 return the day list allowed to set schedule in a month
            dateMon: [
                { 'n': mstrmojo.desc(15106, "1st day"), 'v': '1' },
                { 'n': mstrmojo.desc(15107, "15th day"), 'v': '15' }
            ],

            // US78530 returns the whole time list of one day
            timeOfDay: [
                { 'n': '12:00AM', 'v': '12:00AM' },
                { 'n': '1:00AM', 'v': '1:00AM' },
                { 'n': '2:00AM', 'v': '2:00AM' },
                { 'n': '3:00AM', 'v': '3:00AM' },
                { 'n': '4:00AM', 'v': '4:00AM' },
                { 'n': '5:00AM', 'v': '5:00AM' },
                { 'n': '6:00AM', 'v': '6:00AM' },
                { 'n': '7:00AM', 'v': '7:00AM' },
                { 'n': '8:00AM', 'v': '8:00AM' },
                { 'n': '9:00AM', 'v': '9:00AM' },
                { 'n': '10:00AM', 'v': '10:00AM' },
                { 'n': '11:00AM', 'v': '11:00AM' },
                { 'n': '12:00PM', 'v': '12:00PM' },
                { 'n': '1:00PM', 'v': '1:00PM' },
                { 'n': '2:00PM', 'v': '2:00PM' },
                { 'n': '3:00PM', 'v': '3:00PM' },
                { 'n': '4:00PM', 'v': '4:00PM' },
                { 'n': '5:00PM', 'v': '5:00PM' },
                { 'n': '6:00PM', 'v': '6:00PM' },
                { 'n': '7:00PM', 'v': '7:00PM' },
                { 'n': '8:00PM', 'v': '8:00PM' },
                { 'n': '9:00PM', 'v': '9:00PM' },
                { 'n': '10:00PM', 'v': '10:00PM' },
                { 'n': '11:00PM', 'v': '11:00PM' }
            ],

            // US78530
            // schedule: {DAILY: mstrmojo.desc(10639, "Daily"), WEEKDAY: mstrmojo.desc(10159, "Weekday"), WEEKLY: mstrmojo.desc(9705, "Weekly"), MONTHLY: mstrmojo.desc(9704, "Monthly")}
            schedule: { DAILY: "Daily", WEEKDAY: "Weekday", WEEKLY: "Weekly", MONTHLY: "Monthly" },

            mainPage: {
                GRID_MODE: 0,
                LIST_MODE: 1
            },

            // mapping info from DBProperties.xml <dbIDs>
            sourceIconClsName: {
                0: "ds-Generic", //Generic
                1: "ds-DB2", //DB2Wire
                2: "ds-DB2", //DB2iSeries
                3: "ds-DB2", //DB2ZOS
                4: "ds-InformixWire", //InformixWire
                5: "ds-InformixXPS", //InformixXPS
                6: "ds-PostgreSQL", //PostgreSQL
                7: "ds-SAP", //SybaseASE
                8: "ds-SAP", //SybaseIQ
                9: "ds-Oracle", //Oracle
                10: "ds-MicroSoft", //SQLServer
                11: "ds-Teradata", //Teradata
                12: "ds-MySQL", //MySQL
                13: "ds-GreenPlum", //GreenPlum
                14: "ds-Netezza", //Netezza
                15: "ds-WebServices", //WebServices
                17: "ds-Infobright", //Infobright
                18: "ds-Salesforce", //Salesforce
                19: "ds-MicroSoft", //Access
                20: "ds-Actian-n", //ParAccel
                21: "ds-Amazon-Redshift", //AmazonRedShift
                22: "ds-Impala", //Impala
                23: "ds-Aster", //Aster
                25: "ds-Actian-n", //VectorWise
                26: "ds-EnterpriseDB", //EnterpriseDB
                27: "ds-Vertica", //Vertica
                28: "ds-Denodo", //Denodo
                29: "ds-CiscoDataVirtualization", //CiscoDataVirtualization
                31: "ds-MicroSoft", //Excel
                32: "ds-GoogleBigQuery", //GoogleBigQuery Driver
                33: "ds-SAP", //SapHana
                35: "ds-IBMBigInsights", //IBMBigInsights
                39: "ds-TM1", //TM1
                41: "ds-WebServices", //WebServicesBI
                43: "ds-Amazon-EMR", //AmazonElasticMapReduce
                44: "ds-Apache-Hive", //ApacheHive
                45: "ds-ClouderaHive", //ClouderaHive
                46: "ds-HortonworksHive", //HortonworksHive
                47: "ds-MapRHive", //MapRHive
                48: "ds-apache", //Pig
                49: "ds-SharkSpark", //SharkSpark
                50: "ds-MongoDB", //MongoDB
                52: "ds-MariaDB", //MariaDB
                51: "ds-MarkLogic", //MarkLogic
                54: "ds-Splunk", //Splunk
                55: "ds-DataDirectCloud", //DataDirectCloud
                56: "ds-ParStream", //ParStream
                58: "ds-Phoenix", //Phoenix
                59: "ds-MicroSoft", //SQLServerJDBC
                60: "ds-DB2", //DB2WireJDBC
                61: "ds-Oracle", //OracleJDBC
                62: "ds-Teradata", //TeradataJDBC
                63: "ds-SAP", //SapHanaJDBC
                65: "ds-PostgreSQL", //PostgreSQLJDBC
                66: "ds-MySQL", //MySQLJDBC
                67: "ds-MariaDB", //MariaDBJDBC
                68: "ds-Amazon-EMR", //AmazonElasticMapReduceJDBC
                69: "ds-Apache-Hive", //ApacheHiveJDBC
                70: "ds-ClouderaHive", //ClouderaHiveJDBC
                71: "ds-HortonworksHive", //HortonworksHiveJDBC
                72: "ds-MapRHive", //MapRHiveJDBC
                73: "ds-SharkSpark", //SharkSparkJDBC
                75: "ds-Amazon-Redshift", //AmazonRedShiftJDBC
                76: "ds-PIVOTALHAWQ", //PIVOTALHAWQ
                77: "ds-MemSQL", //MemSQL
                78: "ds-Arcadia-Platform", //ArcadiaPlatform
                79: "ds-Altibase", //Altibase
                80: "ds-MongoDB", //MongoDBJDBC
                81: "ds-Presto", //Presto
                82: "ds-DB2", //DB2iSeriesJDBC
                83: "ds-DB2", //DB2ZOSJDBC
                84: "ds-InformixWire", //InformixWireDBC
                85: "ds-SAP", //SybaseASEJDBC
                86: "ds-MicroSoft", //SQLDatabase
                87: "ds-MicroSoft", //SQLDatabaseJDBC
                88: "ds-MemSQL", //MemSQLJDBC
                90: "ds-GreenPlum", //GreenPlumJDBC
                91: "ds-PIVOTALHAWQ", //PIVOTALHAWQJDBC
                92: "ds-Netezza", //NetezzaJDBC
                93: "ds-Infobright", //InfobrightJDBC
                94: "ds-Actian-n", //ParAccelJDBC
                95: "ds-Impala", //ImpalaJDBC
                96: "ds-IBMBigInsights", //IBMBigInsightsJDBC
                97: "ds-Aster", //AsterJDBC
                99: "ds-Actian-n", //Actian VectorwiseJDBC
                100: "ds-EnterpriseDB", //EnterpriseDBJDBC
                101: "ds-Vertica", //VerticaJDBC
                102: "ds-Denodo", //DenodoJDBC
                103: "ds-CiscoDataVirtualization", //CiscoDataVirtualizationJDBC
                105: "ds-DataDirectCloud", //DataDirectCloudJDBC
                106: "ds-ParStream", //ParStreamJDBC
                107: "ds-Arcadia-Platform", //ArcadiaPlatformJDBC
                109: "ds-Presto", //Presto
                110: "ds-Phoenix", //PhoenixJDBC
                111: "ds-Kognitio", //Kognitio
                112: "ds-Kognitio", //KognitioJDBC
                113: "ds-Informatica", //Informatica
                114: "ds-Informatica", //InformaticaJDBC
                115: "ds-Apache-Cassandra-JDBC", //CassandraJDBC
                116: "ds-SAP", //SybaseIQJDBC
                117: "ds-Actian", //VectorWise
                118: "ds-Actian", //VectorWise
                119: "ds-InformixXPS", //InformixXPSJDBC
                120: "ds-Apache-Cassandra-JDBC", //Cassandra
                121: "ds-MapRDrill", //MapRDrill
                122: "ds-Cirro", //Cirro
                123: "ds-EXASolution", //EXASolution
                124: "ds-EXASolution", //EXASolutionJDBC
                125: "ds-Oracle", //Oracle
                126: "ds-Oracle", //OracleJDBC
                127: "ds-Snowflake", //Snowflake
                128: "ds-Snowflake", //SnowflakeJDBC
                129: "ds-Amazon-Aurora", //AmazonAurora
                130: "ds-Amazon-Aurora", //AmazonAuroraJDBC
                131: "ds-Amazon-Athena", //AMAZONATHEN
                132: "ds-Amazon-Athena", //AMAZONATHENJDBC
                133: "ds-MapRDrill", //MapRDrillJDBC,
                134: "ds-Druid", //Druid
                135: "ds-Druid", //DruidJDBC
                139: "ds-MongoBI", //MongoBI
                157: "ds-GoogleBigQuery", //GoogleBigQuery JDBC
                161: "ds-MapD", //MapD
                168: "ds-HortonworksSpark", // HortonworksSpark
                169: "ds-HortonworksSpark", // HortonworksSpark JDBC
                170: "ds-Yellowbrick", //Yellowbrick
            },

            /**
             relational = 1
             MDX = 2
             SearchEngine = 4
             web services = 8
             Pig/Hive/Impala = 16
             Hadoop = 32
             */
            dispTag: {
                1: "Database",
                2: "OLAP",
                4: "BigData",
                8: "Database",
                16: "BigData",
                32: "BigData"
            },

            searchTags: {
                100: ["Database", "ODBC"],
                200: ["Database", "ODBC"],
                300: ["Database", "ODBC"],
                400: ["Database", "ODBC"],
                500: ["Database", "ODBC"],
                600: ["Database", "ODBC"],
                700: ["Database", "ODBC"],
                900: ["Database", "ODBC"],
                1100: ["Database", "ODBC"],
                1200: ["OLAP", "Cube"],
                1300: ["Database", "ODBC"],
                1400: ["Database"],
                1500: ["OLAP", "Cube"],
                1600: ["OLAP", "Cube"],
                1700: ["Database", "ODBC"],
                1800: ["Database", "ODBC"],
                2200: ["Database", "ODBC"],
                2300: ["Database", "ODBC"],
                2400: ["Database", "ODBC"],
                2800: ["Database", "ODBC"],
                2900: ["OLAP", "Cube"],
                3000: ["Database"],
                3100: ["Database", "BigData", "Hadoop"],
                3300: ["Cloud"],
                3500: ["Database", "ODBC"],
                3600: ["Database", "ODBC", "BigData"],
                3800: ["Database"],
                3900: ["Database"],
                4000: ["Database", "ODBC"],
                4100: ["Database", "BigData", "Hadoop"],
                4200: ["Database", "ODBC"],
                4300: ["Database", "ODBC"],
                4700: ["Database", "Cloud", "BigData"],
                4800: ["Cloud"],
                5200: ["Database", "NoSQL"],
                5300: ["Database", "NoSQL"],
                5400: ["Hadoop"],
                6400: ["Database", "BigData", "Hadoop"],
                6600: ["Database"],
                6700: ["Database"],
                6800: ["BigData"],
                6900: ["BigData"],
                7100: ["NoSQL"],
                7200: ["Database"],
                7300: ["BigData", "Hadoop"],
                7500: ["Database"],
                7600: ["Database"],
                8000: ["Database"],
                8100: ["BigData"],
            },

            srcItemTypes: {
                /** this could be fired multiple times by searching and filtering **/
                ALL_SOURCES : "ALL_SOURCES",
                /** the fallowing type of event could only be fired once in the lifecycle of the DI **/
                STATIC_SOURCE : "STATIC_SOURCE",
                DBTYPE_SOURCE : "DBTYPE_SOURCE",
                CUSTOM_CONNECTOR : "CUSTOM_CONNECTOR",
                CLOUDELEMENT_CONNECTOR: "CLOUDELEMENT_CONNECTOR"
            },

            combination: {
                BigData: ['BigData', 'NoSQL', 'Search', 'Hadoop'],
                Apps: ['Apps', 'oAuth', 'Cloud', 'Social', 'BI', 'PublicData', 'CE']
            },

            GenericDBStr: "Generic",

            dataSourceType: {
                MONGODB: "mongodb",
                FILE_URL: "fileUrl",
                FILE_LOCAL: "fileLocal",
                ES: "elasticsearch",
                DROPBOX: "dropbox",
                GOOGLE_DRIVE: "googleDrive",
                GOOGLE_ANALYTICS: "googleAnalytics",
                GOOGLE_BIGQUERY: "googleBigQuery",
                SALESFORCE: "salesforce",
                FILE: "file",
                GENERIC_JDBC: "genericJdbc"
            },

            /* Enum for loading report definition flag */
            ERDF: {
                ENUM_LOAD_REPORT_BROWSE_TYPE_BINDINGTABLE: 1,
                //ENUM_LOAD_REPORT_BROWSE_TYPE_SQLPREVIEW : 2,
                ENUM_LOAD_REPORT_BROWSE_TYPE_DATAPREVIEW: 4,
                ENUM_LOAD_REPORT_BINDING_FLAG_ALL: 15, //from COM definition default is 0. however it contains some extra info, so default 15 is good for QB/FFSQL
                /*ENUM_LOAD_REPORT_BINDING_FLAG_TABLE_AND_DBTABLE : 1,
                ENUM_LOAD_REPORT_BINDING_FLAG_REPORT : 2,
                ENUM_LOAD_REPORT_BINDING_FLAG_TEMPLATE : 4,
                ENUM_LOAD_REPORT_BINDING_FLAG_COLUMN : 8,*/
                ENUM_LOAD_REPORT_PREVIEW_FLAG_MappingInfo: 1,
                ENUM_LOAD_REPORT_PREVIEW_FLAG_DataInfo: 2, //default
                ENUM_LOAD_REPORT_PREVIEW_FLAG_SourceInfo: 4,
                ENUM_LOAD_REPORT_PREVIEW_FLAG_InnerDataInfo: 2048,
                /*ENUM_LOAD_REPORT_PREVIEW_FLAG_SheetsInfo : 16,
                ENUM_LOAD_REPORT_AUTOMAP_TRIGGER : 1,
                ENUM_LOAD_REPORT_AUTOMAP_NOT_TRIGGER : 0,*/
            },

            DSSSubType: {
                DSSSUBTYPEATTRIBUTE: 3072,
                DSSSUBTYPEATTRIBUTEROLE: 3073,
                DSSSUBTYPEATTRIBUTETRANSFORMATION: 3074,
                DSSSUBTYPEATTRIBUTEABSTRACT: 3075,
                DSSSUBTYPEATTRIBUTERECURSIVE: 3076
            },

            DSSExType: {
                DSSEXDISPARK: 416
            },

            URLMode: {
                NormalUrl: 0,
                NewConnector: 1,
                NewConnectorEdit: 2,
                CloudElement: 3
            },

            disableFeatures: {
                DISABLE_CUSTOM_CONNECTOR: 'disableCustomerConnector',
                DISABLE_DDA: 'disableDDA',
                DISABLE_QUOTA: 'disableQuota',
                DISABLE_HADOOP: 'disableHadoop',
                DISABLE_BI_TOOLS: 'disableBITools',
                DISABLE_CLIP_BOARD: 'disableClipboard',
                DISABLE_FACE_BOOK: 'disableFacebook',
                DISABLE_TWITTER: 'disableTwitter',
                DISABLE_SAMPLE_FILES: 'disableSampleFiles',
                DISABLE_PUBLIC_DATA: 'disablePublicData',
                DISABLE_MERGE_CUBE: 'disableMergeCube',
                DISABLE_CE_SOURCE: 'disableCESource',
                DISABLE_FLATTERN_DB_SOURCE: 'disabledSources'
            },

            DssXmlPrivileges: {
                DssXmlPrivilegesUseDatabaseInstanceManager: 57
            },

            Enum_SourceCategoryType: {
                File : 1,
                BigData : 2,
                Database : 3,
                OLAP : 4,
                Customized : 5,
                Apps : 6,
            }
        });
}());
/**
 * Created by jmi on 9/16/2014.
 */
(function () {
    mstrmojo.vi.ui.theme = mstrmojo.provide(
        "mstrmojo.vi.ui.theme",
        {
            getThemeClass: function getThemeClass() {
                var ancestor = this.parent || this.opener,
                    result = '',
                    nextAncestor;

                // Iterate ancestors.
                while (ancestor) {
                    // Does this ancestor have a theme class name?
                    var themeClassName = ancestor.themeClassName;
                    if (themeClassName) {
                        // Add theme class to css class collection and halt iteration.
                        result = themeClassName;
                        break;
                    }

                    // Get next ancestor.
                    nextAncestor = ancestor.parent || ancestor.opener;
                    //DE65968; exit if they are the same to avoid dead loop, like case for window
                    if (nextAncestor === ancestor) {
                        break;
                    }
                    ancestor = nextAncestor;
                }

                return result;
            }
        }
    );
}());
(function () {
    /**
     * <p>Static class with helper methods for using Function objects.</p>
     *
     * @namespace mstrmojo.func
     */
    mstrmojo.func = mstrmojo.provide(
        "mstrmojo.func",

        /**
         * @lends mstrmojo.func
         */
        {
            /**
             * <p>Utility function for combining multiple function calls.</p>
             *
             * @param {Function[]} fn An array of functions to call.
             *
             * @returns {Function} The wrapper function that will call each of the supplied functions in the order they appear in the <strong>fn</strong> parameter.
             */
            composite: function composite(fn) {
                // Is the 'fn' parameter invalid?
                if (!fn || !fn.length) {
                    // Return an empty function
                    return mstrmojo.emptyFn;
                }

                return function () {
                    var len = fn.length,
                        i;

                    for (i = 0; i < len; i++) {
                        fn[i].apply(this, arguments);
                    }
                };
            },

            /**
             * Creates (or modifies destination) object with the combined methods of the any number of parameters objects where all methods will be called.
             * The first [arguments.length - 1] become the sources array
             * The last argument should be the destination
             * @param {...Object} var_args respresenting sources and destination
             * @returns {Object}
             */
            wrapMethods: function wrapMethods(src, dest) {

                /**
                 * inner wrapMethods that take one or two arguments.
                 * Creates (or modifies destination) object with the combined methods of the two parameters objects where all methods will be called.
                 *
                 * @param {Object} source
                 * @param {Object=} destination
                 *
                 * @returns {Object}
                 */
                function wrap(source, destination) {
                    // Initialize callback (in case it was null).
                    destination = destination || {};

                    // Iterate the source object and wrap existing methods (if present in destination) or
                    // add source method if not present in destination.
                    mstrmojo.hash.forEach(source, function (fn, fnName) {
                        destination[fnName] = (destination.hasOwnProperty(fnName) && typeof fn === 'function') ? mstrmojo.func.composite([ fn, destination[fnName] ]) : fn;
                    });

                    return destination;
                }

                //if only two arguments or less, call wrap method directly.
                if (arguments.length < 3) {
                    return wrap(src, dest);
                }

                // extract arguments(when arguments more than 2):
                // The first [arguments.length - 1] become the sources array
                //    * call `reverse` here to make sure the first source to be put into destination last.
                //      when we call destination[fnName], sources[0][fnName] would be invoke first.
                // The last argument should be the destination
                var len = arguments.length,
                    sources = [].slice.call(arguments, 0, len - 1).reverse(),
                    destination = arguments[len - 1];

                // Iterate the sources array and wrap with destination
                mstrmojo.array.forEach(sources, function (source) {
                    destination = wrap(source, destination);
                });

                return destination;
            },

            /**
             * Overrides in destination methods provided by src. Methods from src can use
             * this._super to call overridden method
             * @param src {Object} an object containing overriding methods. Nothing but methods is allowed in src
             * @param destination {Object} an object whose methods will be overridden. If this parameter is omitted
             *                             a new object will be created
             * @returns {Object} the destination object.
             */
            override: function override(src, destination) {

                var fnWrapMethod = function (overwriting, inher) {
                    return function superwrap() {
                        var tmp = this._super,
                            ret;
                        this._super = inher || mstrmojo.emptyFn;
                        try {
                            ret = overwriting.apply(this, arguments || []);
                        } finally {
                            this._super = tmp;
                        }
                        return ret;
                    };
                };

                destination = destination || {};

                // #940083 Iterate the source object and wrap existing methods even destination is empty,
                //         so that the _super will be set correctly while executing.
                mstrmojo.hash.forEach(src, function (fn, fnName) {
                    destination[fnName] = fnWrapMethod(fn, destination[fnName]);
                });

                return destination;
            },

            /**
             * Creates and returns a new, throttled version of the passed function, that, when invoked repeatedly,
             * will only actually call the original function at most once per every wait milliseconds.
             * Useful for rate-limiting events that occur faster than you can keep up with.
             *
             * By default, throttle will execute the function as soon as you call it for the first time, and,
             * if you call it again any number of times during the wait period, as soon as that period is over.
             * If you'd like to disable the leading-edge call, pass {leading: false}, and if you'd like to
             * disable the execution on the trailing-edge, pass {trailing: false}.
             *
             * @param func {Function} the original function
             * @param wait {int} milliseconds to throttle
             * @param opts {leading:Boolean, trailing:Boolean}
             * @returns {Function}
             */
            throttle: function (func, wait, opts) {
                var context, args, result,
                    timeout = null,
                    previous = 0,
                    options = opts || {};

                var later = function () {
                    previous = options.leading === false ? 0 : mstrmojo.date.now();
                    timeout = null;
                    result = func.apply(context, args);
                    context = args = null;
                };
                return function () {
                    var now = mstrmojo.date.now();
                    if (!previous && options.leading === false) {
                        previous = now;
                    }
                    var remaining = wait - (now - previous);
                    context = this;
                    args = arguments;
                    if (remaining <= 0) {
                        clearTimeout(timeout);
                        timeout = null;
                        previous = now;
                        result = func.apply(context, args);
                        context = args = null;
                    } else if (!timeout && options.trailing !== false) {
                        timeout = setTimeout(later, remaining);
                    }
                    return result;
                };
            },

            /**
             * Creates and returns a new debounced version of the passed function which will postpone its execution until
             * after wait milliseconds have elapsed since the last time it was invoked. Useful for implementing behavior
             * that should only happen after the input has stopped arriving. For example: rendering a preview of a Markdown
             * comment, recalculating a layout after the window has stopped being resized, and so on.
             *
             * Pass true for the immediate parameter to cause debounce to trigger the function on the leading instead of the
             * trailing edge of the wait interval. Useful in circumstances like preventing accidental double-clicks on a
             * "submit" button from firing a second time.
             *
             * @param {Function} func the original function
             * @param {int} wait milliseconds to wait
             * @param {Boolean=} immediate trigger the function on the leading instead of the trailing edge
             * @returns {Function}
             */
            debounce: function (func, wait, immediate) {
                var timeout, args, context, timestamp, result, now = mstrmojo.date.now;

                var later = function () {
                    var last = now() - timestamp;
                    if (last < wait) {
                        timeout = setTimeout(later, wait - last);
                    } else {
                        timeout = null;
                        if (!immediate) {
                            result = func.apply(context, args);
                            context = args = null;
                        }
                    }
                };

                return function () {
                    context = this;
                    args = arguments;
                    timestamp = now();
                    var callNow = immediate && !timeout;
                    if (!timeout) {
                        timeout = setTimeout(later, wait);
                    }
                    if (callNow) {
                        result = func.apply(context, args);
                        context = args = null;
                    }

                    return result;
                };
            },

            /**
             * Creates (or modifies destination) object to have all the methods from the source object, provided those methods didn't already exist on the destination.
             *
             * @param {Object} source
             * @param {Object=} destination
             *
             * @returns {Object}
             */
            addMethods: function addMethods(source, destination) {
                // Initialize callback (in case it was null).
                destination = destination || {};

                // Iterate the source object and wrap existing methods (if present in destination) or
                // add source method if not present in destination.
                mstrmojo.hash.forEach(source, function (fn, fnName) {
                    if (!destination.hasOwnProperty(fnName) && typeof fn === 'function') {
                        destination[fnName] = fn;
                    }
                });

                return destination;
            }
        }
    );
}());
/**
 * Created by fding on 3/4/2016.
 */

/**
 * A utility class that provides utility functions related to images, such as compression
 *
 * @namespace mstrmojo.imageUtils
 */
(function () {
    mstrmojo.requiresCls(
        "mstrmojo.func",
        "mstrmojo.url"
    );

    var FUNC = mstrmojo.func,
        URL = mstrmojo.url;

    mstrmojo.imageUtils = mstrmojo.provide(
        "mstrmojo.imageUtils",
        {

            /**
             * Receives an Image Object (can be JPG OR PNG) and returns a new Image Object compressed
             * @param {Image} sourceImage The source Image Object
             * @param {Integer} quality The output quality of Image Object (1 - 100)
             * @param {String} outputFormat. Possible values are jpg and png
             * @return {Image} result_image_obj The compressed Image Object
             */
            compress: function(sourceImage, quality, outputFormat){

                var mimeType = "image/jpeg";
                if (outputFormat === "png" || outputFormat === "image/png") {
                    mimeType = "image/png";
                }

                var qualityValue = parseInt(quality);
                qualityValue = qualityValue > 1 && qualityValue <= 100 ? qualityValue : 100;

                var cvs = document.createElement("canvas");
                // in case browser dose not support canvas
                if (!!(cvs.getContext && cvs.getContext("2d"))) {
                    cvs.width = sourceImage.naturalWidth;
                    cvs.height = sourceImage.naturalHeight;
                    cvs.getContext("2d").drawImage(sourceImage, 0, 0);
                    var newImageData = cvs.toDataURL(mimeType, qualityValue / 100);
                    var resultImage = new Image();
                    resultImage.src = newImageData;
                    return resultImage;
                }
                return sourceImage;
            },

            /**
             * Creates and returns a blob from a data URL (either base64 encoded or not).
             *
             * @param {string} dataURL The data URL to convert.
             * like "data:image/png;base64,abcd"
             * "data:,abcd"
             * @return {Blob} A blob representing the array buffer data.
             */
            dataURLToBlob: function(dataURL) {
                var BASE64_MARKER = ';base64,',
                    parts,
                    contentType,
                    raw;
                dataURL = dataURL || "";
                if (dataURL.indexOf(BASE64_MARKER) === -1) {
                    parts = dataURL.split(',');
                    contentType = parts[0].split(':')[1];
                    raw = decodeURIComponent(parts[1]);
                    return new Blob([raw], {type: contentType});
                }

                parts = dataURL.split(BASE64_MARKER);
                contentType = parts[0].split(':')[1];
                raw = window.atob(parts[1]);
                var rawLength = raw.length;
                var uInt8Array = new Uint8Array(rawLength);
                for (var i = 0; i < rawLength; ++i) {
                    uInt8Array[i] = raw.charCodeAt(i);
                }
                return new Blob([uInt8Array], {type: contentType});
            },

            /**
             * Check if an image is accessible
             *
             * @param {string} src - the image url
             * @param {Object} callback - the callback
             * @param {Function} callback.success - the function to call when image is accessible
             * @param {Function} callback.failure - the function to call when image is not accessible
             */
            isImageAccessible: function isImageAccessible(src, callback) {
                var img = document.createElement('img');
                var deleteSelf = function () {
                    img = null;
                };
                if (mstrApp && mstrApp.getWSLiveMode && mstrApp.getWSLiveMode() && src.indexOf(';base64,') === -1) {
                    img.src = URL.getAbsoluteURL(src, window.FormWrapper.getDossierServerURL());
                } else {
                    img.src = src;
                }
                img.onload = FUNC.composite([callback && callback.success || mstrmojo.emptyFn, deleteSelf]);
                img.onerror = FUNC.composite([callback && callback.failure || mstrmojo.emptyFn, deleteSelf]);
            }
        }
    );
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.hash");

    mstrmojo.requiresDescs(521, 522, 523, 524, 525, 526, 529, 530, 534, 535, 546, 547, 587, 686, 687, 688, 696, 746,
	    1101, 1102, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 2171, 2202, 2203, 2204,
	    2219, 2220, 2784, 2785, 2786, 2795, 2796, 3086, 3344, 3852, 3853, 3854, 3855, 3856, 3857, 3858, 3859, 3860,
	    3861, 3862, 3863, 3945, 3946, 4406, 4407, 5282, 5283, 5924, 5925, 6076, 6077, 6078, 6079, 6080, 6081, 6082,
	    7899, 7900, 7901, 7902, 7903, 9379, 9380, 9381, 9382, 9383, 9384, 9385, 12298, 13889, 13890, 13896, 13897);

    /**
     * A utility class to load locale specific information from web server.
     *
     * @namespace mstrmojo.locales
     */
    mstrmojo.locales = mstrmojo.provide(
        "mstrmojo.locales",
            /**
             * @lends mstrmojo.locales
             */
            {
                /**
                 * Load locale specific information and callback if succeeded.
                 */
                load: function (callback) {
                    var me = this;
                    if (this.isLoaded) {
                        callback();
                        callback=null;
                    } else {
                    	var params = {
                            taskId: 'getLocaleInfo'
                        };
                    	if (mstrConfig && mstrConfig.isAddSessionState && mstrApp && mstrApp.sessionState) {
                    		params.sessionState = mstrApp.sessionState;
                    	}
                        mstrmojo.xhr.request('POST', mstrConfig.taskURL,
                        {
                            success: function (res) {
                                //copy result
                                me.update(res);

                                callback();
                                callback=null;

                                if (mstrmojo.expr) {
                                    mstrmojo.expr.onLocaleUpdated();
                                }
                                mstrmojo.locales.isLoaded = true;

                            },
                            failure: function (res) {
                                alert(res.getResponseHeader('X-MSTR-TaskFailureMsg'));//can not use mstrmojo.alert because mstrmojo.Dialog may not be loaded yet.
                            }
                        },
                        // no parameter, load current user's all locale related info
                        params);
                    }
                },

                /**
                 * Updates locale specific information.
                 */
                update: function (props) {
                    //copy properties
                    if (props) {
                        mstrmojo.hash.copy(mstrmojo.hash.obj2array(props), this);
                    }
                },

                isLoaded: false,

                "datetime": {
                    "MONTHNAME_SHORT": [
                        mstrmojo.desc(3852, "Jan"),
                        mstrmojo.desc(3853, "Feb"),
                        mstrmojo.desc(3854, "Mar"),
                        mstrmojo.desc(3855, "Apr"),
                        mstrmojo.desc(3856, "May"),
                        mstrmojo.desc(3857, "Jun"),
                        mstrmojo.desc(3858, "Jul"),
                        mstrmojo.desc(3859, "Aug"),
                        mstrmojo.desc(3860, "Sep"),
                        mstrmojo.desc(3861, "Oct"),
                        mstrmojo.desc(3862, "Nov"),
                        mstrmojo.desc(3863, "Dec")
                    ],
                    "MONTHNAME_FULL": [
                        mstrmojo.desc(1956, "January"),
                        mstrmojo.desc(1957, "February"),
                        mstrmojo.desc(1958, "March"),
                        mstrmojo.desc(1959, "April"),
                        mstrmojo.desc(1960, "May"),
                        mstrmojo.desc(1961, "June"),
                        mstrmojo.desc(1962, "July"),
                        mstrmojo.desc(1963, "August"),
                        mstrmojo.desc(1964, "September"),
                        mstrmojo.desc(1965, "October"),
                        mstrmojo.desc(1966, "November"),
                        mstrmojo.desc(1967, "December")
                    ],
                    "dayShortNames": [
                        "S",
                        "M",
                        "T",
                        "W",
                        "T",
                        "F",
                        "S"
                    ],
                    "dayNames": [
                        mstrmojo.desc(9379, "Sunday"),
                        mstrmojo.desc(9380, "Monday"),
                        mstrmojo.desc(9381, "Tuesday"),
                        mstrmojo.desc(9382, "Wednesday"),
                        mstrmojo.desc(9383, "Thursday"),
                        mstrmojo.desc(9384, "Friday"),
                        mstrmojo.desc(9385, "Saturday")
                    ],
                    /*These are the acceptable input formats for the default locale.
                    Once the user starts the application a request will be sent to the backend passing the current locale as parameter for that request.
                    Then it receive the acceptable input formats defined for that locale. (These definition are defined in format_config.xml)*/
                    "DATEINPUTFORMATS": [
                        "M/d/yy",
                        "M/d/yyyy",
                        "MMM d, yy"
                    ],
                    "TIMEINPUTFORMATS": [
                        "h:mm a",
                        "H:mm",
                        "h:mm:ss a",
                        "H:mm:ss",
                        "h:mm:ss a z"
                    ],
                    /*Output formats is the format in which the iServer sends the date/time to web.*/
                    "DATEOUTPUTFORMAT": "M/d/yyyy",
                    "TIMEOUTPUTFORMAT": "h:mm:ss a",

                    // TQMS 927462 add the date/time output format in preferences
                    /*These DISPLAYFORMAT's were introduced to show the date and time stamps on the folders page*/
                    "DATEDISPLAYFORMAT":"M/d/yy",
                    "TIMEDISPLAYFORMAT":"h:mm:ss",

                    "AM_NAME": "AM",
                    "PM_NAME": "PM",
                    "TWODIGITYEARSTART": "2029"
                },
                "number": {
                    "NUMBERINPUTFORMATS": {
                        "0": "#,##0.###"
                    },
                    "INTEGERINPUTFORMATS": {
                        "0": "#,##0"
                    },
                    "NUMBEROUTPUTFORMAT": "#0.##########",
                    "INTEGEROUTPUTFORMAT": "#0",
                    "DECIMALSEPARATOR": ".",
                    "THOUSANDSEPARATOR": ","
                },
                "expression": {
                    "METRICVALIDATIONLEVEL": "0",
                    "PRESERVEWHITESPACE": false,
                    "Include": [
                        {
                            "did": "1",
                            "n": mstrmojo.desc(3945, "Include")
                        },
                        {
                            "did": "2",
                            "n": mstrmojo.desc(3946, "Exclude")
                        }
                    ],
                    "BranchQual": [
                        {
                            "did": "19",
                            "n": mstrmojo.desc(5282, "AND")
                        },
                        {
                            "did": "20",
                            "n": mstrmojo.desc(5283, "OR")
                        },
                        {
                            "did": "21",
                            "n": mstrmojo.desc(12298, "NOT")
                        },
                        {
                            "did": "19_21",
                            "n": mstrmojo.desc(5924, "AND NOT")
                        },
                        {
                            "did": "20_21",
                            "n": mstrmojo.desc(5925, "OR NOT")
                        }
                    ],
                    "RootOperator": [
                        {
                            "did": "19",
                            "n": mstrmojo.desc(534, "All selections")
                        },
                        {
                            "did": "20",
                            "n": mstrmojo.desc(535, "Any selection")
                        }
                    ],
                    "ExprType": [
                        {
                            "did": "2",
                            "n": mstrmojo.desc(546, "Qualify")
                        },
                        {
                            "did": "5",
                            "n": mstrmojo.desc(547, "Select")
                        }
                    ],
                    "DimtyLevels": [
                        {
                            "did": "1",
                            "n": mstrmojo.desc(2171, "Default")
                        },
                        {
                            "did": "2",
                            "n": mstrmojo.desc(3086, "Metric")
                        },
                        {
                            "did": "3",
                            "n": mstrmojo.desc(3344, "Report")
                        }
                    ],
                    "Attribute": [
                        {
                            "did": "1,6",
                            "n": mstrmojo.desc(2795, "Equals"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,7",
                            "n": mstrmojo.desc(2796, "Does not equal"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,8",
                            "n": mstrmojo.desc(521, "Greater than"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,10",
                            "n": mstrmojo.desc(522, "Greater than or equal to"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,9",
                            "n": mstrmojo.desc(523, "Less than"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,11",
                            "n": mstrmojo.desc(524, "Less than or equal to"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,17",
                            "n": mstrmojo.desc(696, "Between"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,44",
                            "n": mstrmojo.desc(746, "Not between"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,76",
                            "n": mstrmojo.desc(686, "Contains"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,79",
                            "n": mstrmojo.desc(2784, "Does not contain"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,77",
                            "n": mstrmojo.desc(687, "Begins with"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,80",
                            "n": mstrmojo.desc(2785, "Does not begin with"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,78",
                            "n": mstrmojo.desc(688, "Ends with"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,81",
                            "n": mstrmojo.desc(2786, "Does not end with"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,18",
                            "n": mstrmojo.desc(525, "Like"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,43",
                            "n": mstrmojo.desc(526, "Not Like"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,54",
                            "n": mstrmojo.desc(2202, "Is Null"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,55",
                            "n": mstrmojo.desc(2203, "Is Not Null"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,22",
                            "n": mstrmojo.desc(587, "In"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,57",
                            "n": mstrmojo.desc(2204, "Not In"),
                            "t": 1,
                            "tp": 1
                        }
                    ],
                    "Metric": [
                        {
                            "did": "1,6",
                            "n": mstrmojo.desc(2795, "Equals"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,7",
                            "n": mstrmojo.desc(2796, "Does not equal"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,8",
                            "n": mstrmojo.desc(521, "Greater than"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,10",
                            "n": mstrmojo.desc(522, "Greater than or equal to"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,9",
                            "n": mstrmojo.desc(523, "Less than"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,11",
                            "n": mstrmojo.desc(524, "Less than or equal to"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,17",
                            "n": mstrmojo.desc(696, "Between"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,44",
                            "n": mstrmojo.desc(746, "Not between"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,54",
                            "n": mstrmojo.desc(2202, "Is Null"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,55",
                            "n": mstrmojo.desc(2203, "Is Not Null"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,22",
                            "n": mstrmojo.desc(587, "In"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,57",
                            "n": mstrmojo.desc(2204, "Not In"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "2,1",
                            "n": mstrmojo.desc(529, "Highest"),
                            "t": 2,
                            "tp": 2
                        },
                        {
                            "did": "2,2",
                            "n": mstrmojo.desc(530, "Lowest"),
                            "t": 2,
                            "tp": 2
                        },
                        {
                            "did": "3,1",
                            "n": mstrmojo.desc(4407, "Highest %"),
                            "t": 3,
                            "tp": 3
                        },
                        {
                            "did": "3,2",
                            "n": mstrmojo.desc(4406, "Lowest %"),
                            "t": 3,
                            "tp": 3
                        }
                    ],
                    "MetricRP": [
                        {
                            "did": "2,13",
                            "n": mstrmojo.desc(13897, "Rank between highest"),
                            "t": 2,
                            "tp": 2
                        },
                        {
                            "did": "2,4",
                            "n": mstrmojo.desc(1101, "Exclude highest"),
                            "t": 2,
                            "tp": 2
                        },
                        {
                            "did": "2,3",
                            "n": mstrmojo.desc(13896, "Rank between lowest"),
                            "t": 2,
                            "tp": 2
                        },
                        {
                            "did": "2,5",
                            "n": mstrmojo.desc(1102, "Exclude lowest"),
                            "t": 2,
                            "tp": 2
                        },
                        {
                            "did": "3,13",
                            "n": mstrmojo.desc(13890, "Between highest") + '%',
                            "t": 3,
                            "tp": 3
                        },
                        {
                            "did": "3,4",
                            "n": mstrmojo.desc(1101, "Exclude highest") + '%',
                            "t": 3,
                            "tp": 3
                        },
                        {
                            "did": "3,3",
                            "n": mstrmojo.desc(13889, "Between lowest") + '%',
                            "t": 3,
                            "tp": 3
                        },
                        {
                            "did": "3,5",
                            "n": mstrmojo.desc(1102, "Exclude lowest") + '%',
                            "t": 3,
                            "tp": 3
                        }
                    ],
                    "MDXAttribute": [
                        {
                            "did": "1,6",
                            "n": mstrmojo.desc(2795, "Equals"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,7",
                            "n": mstrmojo.desc(2796, "Does not equal"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,8",
                            "n": mstrmojo.desc(521, "Greater than"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,10",
                            "n": mstrmojo.desc(522, "Greater than or equal to"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,9",
                            "n": mstrmojo.desc(523, "Less than"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,11",
                            "n": mstrmojo.desc(524, "Less than or equal to"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,17",
                            "n": mstrmojo.desc(696, "Between"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,44",
                            "n": mstrmojo.desc(746, "Not between"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,22",
                            "n": mstrmojo.desc(587, "In"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,57",
                            "n": mstrmojo.desc(2204, "Not In"),
                            "t": 1,
                            "tp": 1
                        }
                    ],
                    "MDXMetric": [
                        {
                            "did": "1,6",
                            "n": mstrmojo.desc(2795, "Equals"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,7",
                            "n": mstrmojo.desc(2796, "Does not equal"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,8",
                            "n": mstrmojo.desc(521, "Greater than"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,10",
                            "n": mstrmojo.desc(522, "Greater than or equal to"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,9",
                            "n": mstrmojo.desc(523, "Less than"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,11",
                            "n": mstrmojo.desc(524, "Less than or equal to"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,17",
                            "n": mstrmojo.desc(696, "Between"),
                            "t": 1,
                            "tp": 1
                        }
                    ],
                    "SAPAttribute": [
                        {
                            "did": "1,6",
                            "n": mstrmojo.desc(2795, "Equals"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,7",
                            "n": mstrmojo.desc(2796, "Does not equal"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,22",
                            "n": mstrmojo.desc(587, "In"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,57",
                            "n": mstrmojo.desc(2204, "Not In"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,8",
                            "n": mstrmojo.desc(521, "Greater than"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,10",
                            "n": mstrmojo.desc(522, "Greater than or equal to"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,9",
                            "n": mstrmojo.desc(523, "Less than"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,11",
                            "n": mstrmojo.desc(524, "Less than or equal to"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,17",
                            "n": mstrmojo.desc(696, "Between"),
                            "t": 1,
                            "tp": 1
                        }
                    ],
                    "Element": [
                        {
                            "did": "1,22",
                            "n": mstrmojo.desc(2219, "In List"),
                            "t": 1,
                            "tp": 1
                        },
                        {
                            "did": "1,57",
                            "n": mstrmojo.desc(2220, "Not In List"),
                            "t": 1,
                            "tp": 1
                        }
                    ]
                },
                "validation": {
                        "requiredFieldError": mstrmojo.desc(6078, "This field is required."),
                        "invalidCharError": mstrmojo.desc(7899, "This field contains invalid characters for #."),
                        "invalidDateStringError": mstrmojo.desc(7900, "This field contains invalid date/time string."),
                        "invalidNumericFormatError": mstrmojo.desc(7901, "This field contains numeric value with incorrect format."),
                        "outofRangeError": mstrmojo.desc(6079, "This field should be # between ## and ###."),
                        "noLessMinError": mstrmojo.desc(6081,  "This field should be # greater than or equal to ##."),
                        "noGreaterMaxError": mstrmojo.desc(6080, "This field should be # less than or equal to ###."),
                        "failRegexTestError": mstrmojo.desc(6082, "This field failed regular expression validation."),
                        "invalidValueInListError": mstrmojo.desc(7902, "One of the value (#) in this list is not valid."),
                        "integerDataType": mstrmojo.desc(6076, "an Integer value"),
                        "numericDataType": mstrmojo.desc(6077, "a Number value"),
                        "dateDataType": mstrmojo.desc(7903, "a Date/Time value")
                },
            'color': {
                'colors': [
                    {'n': 'Black', 'v': '#000000'},
                    {'n': 'Brown', 'v': '#993300'},
                    {'n': 'Olive Green', 'v': '#333300'},
                    {'n': 'Dark Green', 'v': '#003300'},
                    {'n': 'Dark Teal', 'v': '#003366'},
                    {'n': 'Dark Blue', 'v': '#000080'},
                    {'n': 'Indigo', 'v': '#333399'},
                    {'n': 'Grey-80%', 'v': '#333333'},
                    {'n': 'Dark Red', 'v': '#800000'},
                    {'n': 'Orange', 'v': '#FF6600'},
                    {'n': 'Dark Yellow', 'v': '#808000'},
                    {'n': 'Green', 'v': '#008000'},
                    {'n': 'Teal', 'v': '#008080'},
                    {'n': 'Blue', 'v': '#0000FF'},
                    {'n': 'Blue-Grey', 'v': '#666699'},
                    {'n': 'Grey-50%', 'v': '#808080'},
                    {'n': 'Red', 'v': '#FF0000'},
                    {'n': 'Light Orange', 'v': '#FF9900'},
                    {'n': 'Lime', 'v': '#99CC00'},
                    {'n': 'Sea Green', 'v': '#339966'},
                    {'n': 'Aqua', 'v': '#33CCCC'},
                    {'n': 'Light Blue', 'v': '#3366FF'},
                    {'n': 'Violet', 'v': '#800080'},
                    {'n': 'Grey-40%', 'v': '#969696'},
                    {'n': 'Pink', 'v': '#FF00FF'},
                    {'n': 'Gold', 'v': '#FFCC00'},
                    {'n': 'Yellow', 'v': '#FFFF00'},
                    {'n': 'Bright Green', 'v': '#00FF00'},
                    {'n': 'Turquoise', 'v': '#00FFFF'},
                    {'n': 'Sky Blue', 'v': '#00CCFF'},
                    {'n': 'Plum', 'v': '#993366'},
                    {'n': 'Grey-25%', 'v': '#C0C0C0'},
                    {'n': 'Rose', 'v': '#FF99CC'},
                    {'n': 'Tan', 'v': '#FFCC99'},
                    {'n': 'Light Yellow', 'v': '#FFFF99'},
                    {'n': 'Light Green', 'v': '#CCFFCC'},
                    {'n': 'Light Turquoise', 'v': '#CCFFFF'},
                    {'n': 'Pale Blue', 'v': '#99CCFF'},
                    {'n': 'Lavender', 'v': '#CC99FF'},
                    {'n': 'White', 'v': '#ffffff'}
                ],
                'userPalette': [
                    {'n': '#F00E0E', 'v': '#F00E0E'},
                    {'n': '#080000', 'v': '#080000'},
                    {'n': '#E81A1A', 'v': '#E81A1A'},
                    {'n': '#6E0909', 'v': '#6E0909'},
                    {'n': '#4F2828', 'v': '#4F2828'},
                    {'n': '#141212', 'v': '#141212'},
                    {'n': '#D60202', 'v': '#D60202'},
                    {'n': '#C40404', 'v': '#C40404'}
                ]
                }

        	}
        );
}());
(function () {

    mstrmojo.requiresCls('mstrmojo.array',
                         'mstrmojo.hash');

    /**
     * Internal regular expression used to match dynamic tokens in a string template.
     * @private
     */
    var _reTOKENS = /\{\@(en@)?([^\}]+)\}/gm,
        _reLT = /\</gm,
        _reGT = /\>/gm,
        _reNEm = /\S/,
        _regSpecials = ['$', '^', '=', '!', ':',
                    '/', '.', '*', '+', '?', '|',
            '(', ')', '[', ']', '{', '}', '\\'],
        _reRegEsc = new RegExp('(\\' + _regSpecials.join('|\\') + ')', 'g'),
        _xmlRep = {
            '&': { k: '&(?!#?\\w+;)', v: '&amp;'},
            '<': '&lt;',
            '>': '&gt;',
            '\u0009': '&#x09;',  // tab
            '\n': '&#x0A;',  // line feed
            '\r': '&#x0D;',  // carriage return
            '"': '&quot;'
        },
        _xmlDecodeRep = {
            '&amp;': '&',
            '&lt;': '<',
            '&gt;': '>',
            '&#x09;': '\u0009',  // tab
            '&#x0A;': '\n',  // line feed
            '&#x0D;': '\r',  // carriage return
            '&quot;': '"'
        },
        _htmlRep = {
            '&': { k: '&(?!#?\\w+;)', v: '&amp;'},
            '<': '&lt;',
            '>': '&gt;',
            ' ': '&nbsp;',
            '\n': '<br/>',  // line feed
            '\r': '&nbsp;&nbsp;&nbsp;&nbsp;',  // carriage return
            '\'': '&#39;',
            '"': '&#34;'
        },
        _htmlDecodeRep = {
            '&amp;': '&',
            '&lt;': '<',
            '&gt;': '>',
            '&nbsp;': ' ',
            '<br/>': '\n',  // line feed
            '&nbsp;&nbsp;&nbsp;&nbsp;': '\r',  // carriage return
            '&#39;': '\'',
            '&#34;': '"'
        },
        _basicHtmlRep = { // TQMS 839236, encode strings following the HTMLHelper.java rules.
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '\'': '&#39;',
            '"': '&#34;',
            '\u20ac': '&#8364;' //euro
        },
        _basicHtmlDecodeRep = { // TQMS 839236, decode strings following the HTMLHelper.java rules.
            '&amp;': '&',
            '&lt;': '<',
            '&gt;': '>',
            '&#39;': '\'',
            '&#34;': '"',
            '&#8364;': '\u20ac' //euro
        };

    /**
     * Internal method to determine the object type.
     * It will return primitive type as of built-in typeof returns.
     * It will return "array" for built-in JavaScript Array and mstrmojo.Arr.
     * It will return "object" for other
     */
    var _typeOf = function (v) {
        if (v === null) {
            return 'null';
        }

        var t = typeof v;
        if (t !== 'object') {
            return t;
        }

        if (v.length === undefined) {
            return 'object';
        }
        return 'array';
    };

    var parseUriOptions = {
        strictMode: false,

        key: [ 'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor' ],

        q: {
            name: 'queryKey',
            parser: /(?:^|&)([^&=]*)=?([^&]*)/g
        },

        parser: {
            strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
            loose:  /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
        }
    };

    /**
     * A static utility class for string operations.
     *
     * @namespace mstrmojo.string
     */
    mstrmojo.string = mstrmojo.provide(

        "mstrmojo.string",

        /**
         * @lends mstrmojo.string
         */
        {

            /**
             * Performs multiple replacement operations on a single string.
             *
             * @param {string} s The string whose values should be replaced.
             * @param {Object} hash A hash whose property names represent the strings that should be replaced and values represent the strings that should replace them.
             * @param {Array} [skip=[]] An optional array containing characters that will be skip during the encoding.
             *
             * @returns {string}
             */
            multiReplace: function multiReplace(s, hash, skip) {
                var k;
                skip = skip || [];

                if (!s) {
                    return '';
                }

                var keys = [];
                for (k in hash) {

                    if (mstrmojo.array.indexOf(skip, k) === -1) {
                        keys.push(k.k || k); // if has a key defined explicitly, using it
                    }
                }

                return s.replace(new RegExp(keys.join('|'), 'g'), function ($0) {
                    var v = hash[$0];
                    return v.v || v;           // return value, if it is defined explicitly
                });
            },

            /**
             * Removes white space from beginning & end of a given string.
             *
             * @param {string} s The string to trim.
             *
             * @returns {string} The trimmed string.
             */
            trim: function trim(s) {
                return (s && s.replace) ? s.replace(/^\s+/, "").replace(/\s+$/, "") : s;
            },

            /**
             * Check whether src string is starts with text string.
             * @param {string} src Source string to be tested.
             * @param {string} text The string be started with.
             *
             * @returns {boolean} whether startsWith
             */
            startsWith: function startsWith(src, text) {
            	return src.length >= text.length && src.substring(0, text.length) == text;
            },

            /**
             * Shortens the supplied text to the supplied length and adds HTML ellipsis (if needed).
             *
             * @param {string} text Header text item.
             * @param {int} length The length the text should be shortened to.
             *
             * @returns {string} Modified text.
             */
            ellipsize: function ellipsize(text, length) {
                // Shorten and trim string.
                var shortText = this.trim(text.substr(0, (length || 1) - 1));

                // Is shortened string NOT equal to original string?
                if (shortText !== text) {
                    // Add ellipsis.
                    shortText += '&hellip;';
                }

                return shortText;
            },

            /**
             * Check whether a string is empty.
             *
             * @param {string} v The string to check.
             *
             * @returns {boolean}
             */
            isEmpty: function isEmpty(v) {
                return (v === null) || (v === undefined) || !(_reNEm.test(v)); // Boolean
            },

            regEscape: function regEscape(text) {
                return text.replace(_reRegEsc, '\\$1');
            },

            /**
             * escape illegal character for xml
             * @param v
             * @returns {*}
             */
            escapeIllegalXML: function escapeIllegalXML(v) {
                if (!v || !v.replace) {
                    return v;
                }
                var SUBSTITUTE = /\u001a/gm,//\u001a, an invalid character in XML, non-print in xml, and ISERVER side has escaped this character
                    EMPTY = '';
                return v.replace(SUBSTITUTE, EMPTY);
            },

            /**
             * Creates an encoded attribute string for an XML element for the value passed.
             *
             * @param {string} v The value of the attribute.
             *
             * @returns {string} The encoded string that can be used as XML attribute.
             */
            encodeXMLAttribute: function (v) {
                return mstrmojo.string.multiReplace(v, _xmlRep);
            },

            /**
             * Decodes an attribute string from an XML element for the value passed.
             *
             * @param {string} v The value of the attribute.
             *
             * @returns {string} The decoded string that was an XML attribute.
             */
            decodeXMLAttribute: function (v) {
                return mstrmojo.string.multiReplace(v, _xmlDecodeRep);
            },

            /**
             * Creates an html encoded string from the value passed.
             *
             * @param {string} v The string to encode.
             * @param {boolean} [skipSpaces=false] An optional parameter indicates whether to convert spaces into &nbsp;.
             * @param {boolean} when basicHtmlEncode is true, encode v following the HTMLHelper.java rules(always skip encoding spaces).
             *
             * @returns {string} The encoded string that can be used as XML attribute.
             */
            encodeHtmlString: function (v, skipSpaces, basicHtmlEncode) {
                if (!v || !v.replace) {
                    return v;
                }
                // TQMS 839236, when basicHtmlEncode is true, encode v following the HTMLHelper.java rules(always skip encoding spaces).
                if (basicHtmlEncode) {
                    return mstrmojo.string.multiReplace(v, _basicHtmlRep);
                }
                return mstrmojo.string.multiReplace(v, _htmlRep, skipSpaces ? [" "] : []);
            },

            //TQMS 589864
            decodeHtmlString: function (v, basicHtmlDecode) {
                // TQMS 839236, when basicHtmlDecode is true, decode v following the HTMLHelper.java rules(always skip decoding spaces).
                return basicHtmlDecode ? mstrmojo.string.multiReplace(v, _basicHtmlDecodeRep) : mstrmojo.string.multiReplace(v, _htmlDecodeRep);
            },

            /**
             * <p>Replace angles brackets in a given string with the HTML equivalents "&lt;" and "&gt;".</p>
             *
             * <p>Used as a faster substitute for multiReplace.</p>
             *
             * @param {string} s String to be encoded.
             *
             * @returns {string} The encoded result; if null was provided, null is returned.
             */
            htmlAngles: function (s) {
                if (!mstrmojo.string.isEmpty(s)) {    // if is not null and not undefined
                    s = String(s);
                    return s.replace(_reLT, '&lt;').replace(_reGT, '&gt;');
                }
                return s;
            },


            /**
             * <p>Applies a given template string to a given object.</p>
             *
             * <p>This method replaces tokens in the given template with actual property values from the given
             * object. The token syntax is a dot (".") delimited string (e.g., "{@&lt;prop.foo&gt;}" where &lt;prop> is the name of a property and &lt;foo> is
             * a name of a property within &lt;prop>. If the property value is null, the token is replaced by an empty string.</p>
             *
             * @param {String} template The template to be applied.
             * @param {Object} obj The object to which the template is applied.
             *
             * @returns {string} The new string without tokens.
             */
            apply: function apl(template, obj) {
                if (!template) {
                    return "";
                }
                var me = this;
                return template.replace(_reTOKENS, function fnReplaceToken(token, encodeSymbol, prop) {

                    var propertyValue;
                    try {
                        propertyValue = mstrmojo.hash.walk(prop, obj);
                    } catch (ex) {}

                    propertyValue = (propertyValue === null || propertyValue === undefined) ? '' : propertyValue;

                    return (!!encodeSymbol) ? me.encodeHtmlString(propertyValue, true) : propertyValue;
                });
            },

            /**
             * <p>Converts JSON object into its XML representation.</p>
             *
             * <p>Primitive type of data will be serialized as attribute of the xml node;
             * Object type of data will be serialized as a child node of the current node, with node name the same as the property name;
             * Array type of data will be serialized as a child node of the current node, with the node name the same as the property name,
             * and each item in the array will be serialized as a child node of the array node, with the node name determined by config.getArrItemName.</p>
             *
             * @param {string} nodeName the name of the root node of the XML string
             * @param {Array|Object} jsons An array of JSON objects or a single JSON object. When it is an array, the properties of each
             *                             JSON object will be serialized as root node's attribute or child node.
             * @param {Object} config A config object to help customizing serializing. It can have following properties:
             *          getArrItemName(n,v,i): when an array is encountered, each item in the array will be serialized into a child node.
             *                                  But what to be used as child node name will be determined by the return value of this function.
             *                                  parameter 'n' is the name of the array property; parameter 'v' is the array; parameter 'i' is the index of the current item.
             *          isSerializable(nodeName, jsons): before json2xml serialize for any property of current node, it will refer to this method to
             *                                  check whether serialization in json2xml should be performed. If this method returns boolean "true", the regular
             *                                  serialization will keep going. If this method return boolean 'false', then serialization of this property will be skipped.
             *                                  If an object is returned, then the string value of its 'att' property will be put in as xml attribute for current node,
             *                                  and the string value of its 'child' property will be put as child node of current node.
             *                                  So, by using this method, caller can customize json2xml to skip serialization of certain nodes, or customize certain node's serialization result.
             *          convertBoolean: when serializing boolean properties whether to convert them to integers (-1/0) or not. Default to true
             *          skipFunctions: Whether to serialize function definitions or not. Default to false
             */
            json2xml: function (nodeName, jsons, config) {
                if (!(jsons instanceof Array)) {
                    jsons = [jsons];
                }

                var serial = config && config.isSerializable,
                    convertBoolean = (config.convertBoolean !== false),
                    skipFunctions = config && config.skipFunctions,
                    ji,
                    jlen;

                // serialize jsons
                var att = [],    // array of all attributes for this xml node
                    ch = [],    // array of all child nodes for this xml node
                    n,          // name of the property
                    v,          // value of the property
                    t;          // type of the property value
                // loop through all json objects
                for (ji = 0, jlen = jsons.length; ji < jlen; ji++) {
                    var json = jsons[ji];
                    // loop through each property
                    for (n in json) {
                        if (skipFunctions && typeof json[n] === "function") {
                            continue;  // skip current property
                        }
                        // config may have customized serialization for certain node
                        if (serial) {
                            var ret = serial(n, jsons, ji);

                            if (ret !== true) {
                                if (ret === false) {    // returned boolean 'false'

                                    continue; // skip current property.
                                } else {

                                    if (ret.att) {       // returned object contains attribute xml
                                        att.push(ret.att);
                                    }

                                    if (ret.child) {     // returned object contains child xml
                                        ch.push(ret.child);
                                    }
                                    continue;
                                }
                            }
                            // returned true, then keep going with regular serialization
                        }
                        v = json[n];
                        t = _typeOf(v);

                        switch (t) {
                        case 'array':
                            var i,
                                len;

                            ch.push('<' + n + '>');     // node for array
                            // loop through each array item
                            for (i = 0, len = v.length; i < len; i++) {
                                var cn = config.getArrItemName(n, v, i) || i; // child name
                                ch.push(this.json2xml(cn, v[i], config));   // node for each array item
                            }
                            ch.push('</' + n + '>'); // close the array node
                            break;
                        case 'object':
                            ch.push(this.json2xml(n, v, config));
                            break;
                        case 'string':
                            att.push(n + '="' + mstrmojo.string.encodeXMLAttribute(v) + '"');
                            break;
                        case 'boolean':
                            att.push(n + '="' + (convertBoolean ? (v ? '-1' : '0') : v) + '"');
                            break;
                        case 'null':
                            if (!config.skipNull) {
                                att.push(n + '="' + config.nullValue + '"');
                            }
                            break;
                        default:
                            att.push(n + '="' + v + '"');
                            break;
                        }
                    } // end of looping through each property
                } // end of looping through each json objects
                return '<' + nodeName + ' ' + att.join(' ') + '>' + ch.join('') + '</' + nodeName + '>';
            },

            escape4HTMLText: function escape4HTMLText(v) {
                if (!v || !v.replace) {
                    return v;
                }
                var QUOTE = /"/gm;
                var QUOTE_ENCODED = '&quot;';
                var AMP = /&/gm;
                var AMP_ENCODED = '&amp;';
                var LESSTHAN = /</gm;
                var LESSTHAN_ENCODED = '&lt;';
                var GREATERTHAN = />/gm;
                var GREATERTHAN_ENCODED = '&gt;';
                return v.replace(AMP, AMP_ENCODED
                    ).replace(QUOTE, QUOTE_ENCODED
                    ).replace(LESSTHAN, LESSTHAN_ENCODED
                    ).replace(GREATERTHAN, GREATERTHAN_ENCODED);
            },

            /**
             * <p>Parses a URI into an object containing it's component parts.</p>
             *
             * <p>Ported from Steven Levithan's parseURI 1.2.2</p>
             *
             * <ul>
             *  <li>parseUri 1.2.2</li>
             *  <li>(c) Steven Levithan &lt;stevenlevithan.com&gt;</li>
             *  <li>MIT License</li>
             * </ul>
             *
                 * @param {string} str The URI to parse.
                 * @param {Object=} options Optional parsing options (will default to standard options).
             *
                 * @returns {Object}
             */
            parseUri: function (str, options) {
                options = options || parseUriOptions;

                var m = options.parser[((options.strictMode) ? 'strict' : 'loose')].exec(str),
                    uri = {},
                    i = 14;

                while (i--) {
                    uri[options.key[i]] = m[i] || '';
                }

                uri[options.q.name] = {};
                uri[options.key[12]].replace(options.q.parser, function ($0, $1, $2) {
                    if ($1) {
                        uri[options.q.name][$1] = $2;
                    }
                });

                return uri;
            },

            /**
             * Removes all special characters in the given string
             * @param str - The string from which the special characters has to be removed
             * @returns {string} - String without special characters
             */
            removeSpecialChars: function (str) {
                return str.replace(/[^a-zA-Z0-9]/g, '');
            }

        }
    );

})();
/**
 * DOMSessionStorage.js 
 * Copyright 2010 MicroStrategy Incorporated. All rights reserved.
 *
 * @fileoverview Base class for objects that wrap HTML5 DOM storage APIs.  There is a sub-class for local and session storage.
 * @version 1.0
 */
 
(function(){
    
    mstrmojo.requiresCls( "mstrmojo.hash" );

    /**
     * @static Local static variable for quick access to globals
     * @private 
     */
    var _H = mstrmojo.hash;
    
    
    /**
     * Returns the elapsed time from specified timestamp until now
     * @private
     * @param {Date} ts Time stamp to measure time from
     * @returns number of milliseconds from timestamp until now
     * @type Integer
     */
    
    var elapsedTm = function(ts) {
        return ( mstrmojo.now() - ts.getTime());
    };
    
     /**
     * Base class for HTML5 DOM storage
     * 
     * @class
     */
    mstrmojo.storage.DOMStorage = mstrmojo.declare( null, null,     
    /**
     *  @lends mstrmojo.storage.DOMStorage.prototype
     */
    {
        scriptClass: "mstrmojo.storage.DOMStorage",
        
        /**
         * indicates whether browser supports HTML5 client-side storage
         * @type Boolean
         */
        mIsSupported: false,
        
        /**
         * Reference to HTML5 storage object; subclasses fill out with the appropriate reference
         * @type HTMLStorage
         */
        mStorageObj: null,
        
        /**
         * time-to-live (in seconds) for items stored in the cache
         * @type integer
         */        
        itemTimeToLive: 3600,

        /**
         * <p>Initializes the object by copying the supplied properties.</p>
         * @returns reference to self to allow for chaining
         * @type mstrmojo.storage.DOMStorage
         */
        init : function init(props) {
            // Apply the given properties to this instance.
            _H.copy(props, this);
            return this;
        },

        /**
         * <p>Returns TRUE if browser supports HTML5 storage</p>
         * @public
         * @returns TRUE if browser supports HTML5 storage.
         * @type Boolean
         */
        isSupported: function isSupported() { return this.mIsSupported; },


        checkVersion: function checkVersion(curVer) {
            
            var  existingVer = this.getItem('__version__');
            // if the data format version is older than we expect then we must clear the cache
            // or convert to the new format.  for now, no conversion is done and we blow away the existing data
            if ( existingVer && existingVer < curVer ) {
                mstrmojo.dbg( "DOMStorage data is old - clearing, v="+existingVer );
                this.clear();
            }
            // store the current version with no expiration
            this.setItem('__version__',curVer,-1);
            
            return this;
        },



        /**
         * <p>Returns the number of items in the HTML5 storage object.  If HTML5 storage is not supported this method returns 0.</p>
         * @public
         * @type Integer
         * @returns Count of name/value pairs in the store.
         */
        length: function() { return ( this.mIsSupported ? this.mStorageObj.length : 0 ); },

    
    
       /**
         * Checks the timestamp of the item data object
         * @private
         * @param {Object} d object containing the item data
         * @returns Returns TRUE if the item has expired and needs to be removed from storage
         * @type Boolean
         */
         
        _keyExpired: function _keyExpired(d) {
            return (d && (d.ts>0) && (mstrmojo.now() > d.ts));
        },
        
        /**
         * <p>Retrieves the key at the specified index in the HTML5 storage object or null if key is not present or HTML5 is not supported.</p>
         * @public

         * @param {Integer} A zero-based index of the list entry, up to the length of the collection.
         * @returns the key at the specified index in the HTML5 storage object
         * @type String 
         */
        key: function(index) { return ( this.mIsSupported ? this.mStorageObj.key(index) : null ); },
        
        /**
         * <p>Returns a string for the specified key or null if the item is not stored or we don't support DOM storage</p>
         *
         * @public
         * @param {String} key value to use as key to find desired data in the storage dictionary
         * @type String
         * @returns returns a JSON string for the data stored with the specfied key
         */     
        getItemAsString: function( key ) {
            var result = this.getItem(key);
            if (result){
                if ( typeof result == "object" ) {
                    // for objects use JSON to do a nice version to something useful
                    result = JSON.stringify(result);    
                } else {
                    // for all other types, appending an empty string will force type conversion
                    result = result + "";
                }
            }
            return result;
        },
        
        /**
         * <p>return a JSON object for the specified key or null if the item is not stored or we don't support DOM storage</p>
         *
         * @public

         * @param {String} key value to use as key to find desired data in the storage dictionary
         * @returns returns a JSON string for the data stored with the specfied key
         * @type Object
        */      

        getItem: function(key) { 
            var result = null;
            if (this.mIsSupported){            
                var d = this.mStorageObj.getItem(key);
                if ( d ) {
                    try { d = JSON.parse(d); } catch(e) { /* eat any parser errors we may come across */ }
                    if ( this._keyExpired( d ) ) {
                        this.removeItem(key);
                    } else {
                        // results are already parsed so we can just return
                        result = d.data;
                    }
                }
            }
            return result;
        },



        /**
         * <p>Adds specified key/value pair into the HTML5 storage.</p>
         *
         * @public

         * @param {String} key value to use as key to find desired data in the storage dictionary
         * @param {any} Data to be associated with the specified key. Data is converted to JSON before being added to the store.
         * @param {Integer} number of seconds that this item is valid in storage or -1 for no expiration
         * @returns reference to self to allow for chaining.
         * @type mstrmojo.storage.DOMStorage
         */     
         
        setItem: function(key,any_data,ttl) {
            ttl = ttl || this.itemTimeToLive;            
            try {
                // NOTE:  May throw QUOTA_EXCEEDED_ERR exceptions if the users storage is full
                if ( this.mIsSupported ) {
                    this.mStorageObj.removeItem(key);
                    
                    // store the caller's data and an expiration date
                    var exp = (ttl > 0) ? (mstrmojo.now() + (ttl*1000)) : -1;
                    var item = { ts: exp, data: any_data };
                    this.mStorageObj.setItem(key,JSON.stringify(item) );
                }
            } catch ( e ) {
                // we silently eat over quota errors and proceed knowing that our code will handle the
                // case where the requested item is not in the store; any other exception is rethrown for the caller to deal with
                if ( e !== QUOTA_EXCEEDED_ERR ) { throw e; }
            } finally {
            }
            return this;
        },


        /**
         * <p>Removes data value associated with specified key from the HTML5 storage.</p>
         *
         * @public

         * @param {String} key value to use as key to find desired data in the storage dictionary
         * @returns reference to self to allow for chaining.
         * @type mstrmojo.storage.DOMStorage
         */     
         
        removeItem: function(key) {
            if ( this.mIsSupported ) { this.mStorageObj.removeItem(key); }
            return this;
        },


        /**
         * <p>Removes all key/value pairs from the DOM Storage.</p>
         *
         * @public
         * @param {String} key value to use as key to find desired data in the storage dictionary
         * @param {any} Data to be associated with the specified key. Data is converted to JSON before being added to the store.
         * @returns reference to self to allow for chaining.
         * @type mstrmojo.storage.DOMStorage
         */     
         
        clear: function() {
            if ( this.mIsSupported ) { this.mStorageObj.clear(); }
            return this;
        }

    } );
    
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.hash");

    var $H = mstrmojo.hash;

    //    mstrmojo.mojoClasses = {};

    /**
     * <p>Base class for all Mojo objects.</p>
     * @class
     */
    mstrmojo.Base = mstrmojo.declare(
        // superclass
        null,

        // mixins
        null,

        /**
         * @lends mstrmojo.Base.prototype
         */
        {
            /**
             * The FQCN for this object.
             *
             * @type String
             */
            scriptClass: "mstrmojo.Base",

            /**
             * <p>Optional handler called during initialization.</p>
             *
             * <p>This handler is supported as a customization hook within the instance creation process.
             * If specified, the handler will be called from constructor after properties are applied to this object,
             * but before the object is registered in the "mstrmojo.all" collection.</p>
             *
             * @type Function
             */
            //postApplyProperties: null,

            /**
             * <p>Base class for all objects.</p>
             *
             * <p>Constructs a new instance by doing the following:</p>
             * <ol>
             * <li>applying all the property values in a given hashtable to the new instance,</li>
             * <li>calls the "postApplyProperties" handler, if any,</li>
             * </ol>
             *
             * @constructs
             * @param {Object} [props] Hash of property values to be applied to this instance.
             */
            init: function init(props) {

                // Apply the given properties to this instance.
                $H.copy(props, this);    // Optimization: use copy rather than mixin, unless truly needed.


                // DEBUG: uncomment to keep count of how many instances of each mojo class are created.
                //                var mc = mstrmojo.mojoClasses,
                //                    sc = this.scriptClass;
                //                mc[sc] ? mc[sc] += 1 :  mc[sc] = 1;

                // Hook for customizations before getting registered.
                if (this.postApplyProperties) {
                    this.postApplyProperties();
                }
            }
        }
    );

}());
/**
 * Singleton for adjusting layout configurations for consumers of the _HasLayout mixin based on DPI.
 *
 * @public
 */
mstrmojo.DPIManager = {

    /**
     * Collection of constructors to be modified.
     *
     * @type {Array.<{c:Function, d: String, s: String, v: Object}>}
     * @private
     */
    classes: [],

    /**
     * Registers a class that should be updated for DPI settings.
     *
     * @param {Function} clz The widget constructor to be modified.
     * @param {String} dimension The layout dimension to modify (h for height, w for width).
     * @param {String} slot The slot to modify.
     * @param {Object} dpiValues An object with a property for each possible DPI with the correct value for that DPI.
     */
    registerClass: function registerClass(clz, dimension, slot, dpiValues) {
        // Add this class to the classes collection.
        this.classes.push({
            c: clz,
            d: dimension,
            s: slot,
            v: dpiValues
        });
    },

    /**
     * Modifies previously registered classes.
     */
    setDPI: function () {
        // Get device DPI.
        var dpi = mstrMobileApp.getDeviceDPI();

        mstrmojo.array.forEach(this.classes, function (clz) {
            // Store DPI value on layout config.
            clz.c.prototype.layoutConfig[clz.d][clz.s] = clz.v[dpi] + 'px';
        });

        // Reset collection of classes.
        this.classes = [];
    }
};

(function () {

    // TQMS #888901: Turn on float metrics so _HasLayout works in IE10.
    document.msCSSOMElementFloatMetrics = true;

    mstrmojo.requiresCls("mstrmojo.hash");

    var $HASH = mstrmojo.hash,
        defaultSlot = 'containerNode',
        auto = 'auto',
        px = 'px';

    /**
     * The layout sizing info for a slot with no layout.
     *
     * @type {{v: string, c: undefined, sv: string}}
     * @static
     */
    var autoBlock = {
        v: auto,
        c: undefined,
        sv: auto
    };

    /**
     * <p>Calculates and returns the new height (or width) for the child.</p>
     *
     * <p>NOTE: Children in auto slots and percentage slots (if onlyPercentageSlots == true) will return the value from their height or width property.</p>
     *
     * @param {mstrmojo.Widget} child The child whose dimension should be calculated.
     * @param {string} dimension The dimension to calculate, either 'h' or 'w'.
     * @param {Boolean} onlyPercentageSlots True if the dimensions should be calculated for only percentage slots.
     *
     * @returns String The value for the indicated dimension (in pixels or 'auto').
     */
    function calcChildDimension(child, dimension, onlyPercentageSlots) {
        var dim = this._layoutWidgets[dimension],
            slot = child.slot || defaultSlot,
            fixedSlots = dim.f,
            percentageSlots = dim.p,
            isFixed = (fixedSlots && fixedSlots[slot] !== undefined),
            isPercent = (percentageSlots && percentageSlots[slot] !== undefined);

        // Does this child have a fixed or percentage slot, or only a percentage slot if onlyPercentageSlot is true?
        if (slot && ((!onlyPercentageSlots && isFixed) || isPercent)) {
            // Return the calculated size of this widget (either fixed or a percentage of the available height).
            return isFixed ? fixedSlots[slot] : (dim.x * parseInt(percentageSlots[slot], 10) / 100) + px;
        }

        return child[(dimension === 'h') ? 'height' : 'width'];
    }

    /**
     * Applies the height and width to the child.
     *
     * @param {mstrmojo._HasLayout|mstrmojo._Provider} child The child widget whose dimensions will be set.
     * @param {string} h The height of the child (in pixels, e.g. '31px').
     * @param {string} w The width of the child (in pixels, e.g. '31px').
     *
     */
    function applyChildDimensions(child, h, w) {
        // Does the child wish to ignore layout?
        if (child.ignoreLayout) {
            // Nothing to do.
            return;
        }

        // Check for auto.
        var hAuto = (h === auto) || h === 'NaNpx',
            wAuto = (w === auto) || w === 'NaNpx';

        // Does the child have offsets?
        var offsets = child.getLayoutOffsets && child.getLayoutOffsets();

        if (offsets) {
            // Is height NOT auto?
            if (!hAuto) {
                // Reduce height by height offset.
                h = (parseInt(h, 10) - offsets.h) + px;
            }

            // Is width NOT auto?
            if (!wAuto) {
                // Reduce width by width offset.
                w = (parseInt(w, 10) - offsets.w) + px;
            }
        }

        // Does the child have a setDimensions method?
        if (child.setDimensions) {

            // Set dimensions on child.
            child.setDimensions(h, w);
        } else {

            // Child doesn't have a setDimensions method so use "set" method.
            if (child.set) {
                if (!hAuto) {
                    child.set('height', h);
                }

                if (!wAuto) {
                    child.set('width', w);
                }
            }
        }
    }

    /**
     * <p>Applies calculated dimensions to slots and children by iterating children.</p>
     *
     * <p>This is the original default layout style where dimensions are only applied to slots that have children.</p>
     *
     * @param {Boolean} onlyPercentageSlots True if dimensions should be applied to percentage slots only, False to apply to both percentage and fixed slots.
     *
     * @private
     */
    function applyDimensionsFromChildren(onlyPercentageSlots) {
        var ch = this.children,
            i,
            len;

        // Iterate children again.
        for (i = 0, len = (ch && ch.length) || 0; i < len; i++) {
            var child = ch[i],
                slot = child.slot || defaultSlot;

            // Do we have a slot?
            if (slot) {
                // Get child sizes.
                var h = /** @type {string} **/ calcChildDimension.call(this, child, 'h', onlyPercentageSlots),
                    w = /** @type {string} **/ calcChildDimension.call(this, child, 'w', onlyPercentageSlots);

                // Apply initial slot dimensions.
                this.setSlotDimensions(slot, h, w);

                // Apply the sizes.
                applyChildDimensions(child, h, w);

                // Calculate child sizes again?
                var zh = /** @type {string} **/ calcChildDimension.call(this, child, 'h', onlyPercentageSlots),
                    zw = /** @type {string} **/ calcChildDimension.call(this, child, 'w', onlyPercentageSlots);

                // Did either dimension change?  This should only happen if auto slot to repaints when it (or a siblings) dimensions are applied.
                if (zh !== h || zw !== w) {
                    // Apply new sizes.
                    applyChildDimensions(child, zh, zw);
                }

                // Set the dimension on the slot (using new dimensions in case they changed).
                this.setSlotDimensions(slot, zh, zw);
            }
        }

        // Call the afterLayout handler.
        this.afterLayout();
    }

    /**
     * <p>Applies calculated dimensions to slots and children by iterating slots.</p>
     *
     * <p>This is a new experimental style where dimensions are applied to all slots, regardless of the presence of children.</p>
     *
     * @private
     */
    function applyDimensionsFromSlots() {
        var children = this.children,
            layoutWidgets = this._layoutWidgets;

        // Iterate all slots.
        $HASH.forEach(this.slotNames, function (isRendered, slot) {
            // Is the slot not rendered yet?
            // TQMS 972710: Or, is the slot unavailable for layout in current widget state?
            if (!isRendered || this.skipsSlotLayout(slot)) {
                // Skip this slot.
                return;
            }

            // Get slot size.
            var h = (layoutWidgets.h && layoutWidgets.h.getSlotSizeInfo(slot, children)) || autoBlock,
                w = (layoutWidgets.w && layoutWidgets.w.getSlotSizeInfo(slot, children)) || autoBlock,
                slotChildren = h.c || w.c;

            mstrmojo.array.forEach(slotChildren, function (slotChild) {
                // Apply the sizes to the child.
                applyChildDimensions(slotChild, h.v, w.v);
            });

            // Set the dimension on the slot.
            this.setSlotDimensions(slot, h.sv, w.sv);
        }, this);

        // Call the afterLayout handler.
        this.afterLayout();
    }

    /**
     * Applies dimensions to children and slots.
     *
     * @private
     */
    function applyDimensions(onlyPercentageSlots) {
        // Decide which style to use.
        var fn = this.layoutConfig.xt ? applyDimensionsFromSlots : applyDimensionsFromChildren;
        fn.call(this, onlyPercentageSlots);
    }

    /**
     * Adjusts the size of any percentage slots in the supplied container to account for newly rendered auto slots.
     *
     * @param {mstrmojo.Widget} child The newly rendered child.
     * @param {Object} lw The layout widget properties created during calculateDimension.
     * @param {string} d The dimension, either height or width.
     *
     * @private
     */
    function adjustDimension(child, lw, d) {
        // Which slot?
        var slot = child.slot || defaultSlot,
            autoSlots = lw && lw.a;

        // Is this NOT an 'auto' slot?
        if (!autoSlots || autoSlots[slot] === undefined) {
            // No, then return.
            return;
        }

        // Measure the size of the newly rendered slot.
        var x = this[slot]['offset' + d],
            size = autoSlots[slot];

        // Is the new size the same as the old size?
        if (x === size) {
            // No changes.
            return;
        }

        // Adjust the current dimension size by the delta of the old size and the new size.
        lw.x -= (x - size);

        // Store the new slot size.
        autoSlots[slot] = x;
    }

    /**
     * <p>Adjusts the layout to account for newly rendered children.</p>
     *
     * @param {mstrmojo.Event} evt The "childrenRendered" event.
     *
     * @private
     */
    function adjustLayout(evt) {
        // Call the beforeLayout handler.
        this.beforeLayout();

        var lw = this._layoutWidgets,
            child = evt.src;

        // Calculate adjusted dimensions for the newly rendered child.
        adjustDimension.call(this, child, lw.h, 'Height');
        adjustDimension.call(this, child, lw.w, 'Width');

        applyDimensions.call(this, true);
    }


    /**
     * Calculates and returns the dimensions for the containers slots and child widgets.
     *
     * @param {Object} dimensionConfig The layout config for this dimension.
     * @param {string} dimension The dimension to calculate, either 'Height' or 'Width' (case sensitive).
     *
     * @private
     * @returns {Object} An object with the following properties:
     * <dl>
     *  <dt>f</dt>
     *  <dd>An object containing fixed slots and their current size value.</dd>
     *  <dt>p</dt>
     *  <dd>An object containing percentage slots and their current size value.</dd>
     *  <dt>a</dt>
     *  <dd>An object containing auto slots and their current size value (zero since they haven't been measured yet).</dd>
     *  <dt>x</dt>
     *  <dd>The current size of this widget that will be devoted to percentage slots.</dd>
     * </dl>
     */
    function calculateDimension(dimensionConfig, dimension) {
        // Do we NOT have layout in this dimension?
        if (!dimensionConfig) {
            // Nothing to do.
            return null;
        }

        var ch = this.children,
            lcDimension = dimension.toLowerCase(),
            widgetDimensionValue = parseInt(this[lcDimension], 10),                     // The total size of this widget dimension (height or width).
            widgetRawValue = widgetDimensionValue,
            fixedSlots = {},
            percentageSlots = {},
            autoSlots = {},
            autoSlotValues = {},
            allSlots = {},
            i,
            len,
            child,
            v,
            slot;

        // Step through all slots in the layoutConfig dimension.
        for (slot in dimensionConfig) {
            if (!dimensionConfig.hasOwnProperty(slot)) {
                continue;
            }

            // The value for this slot.
            v = dimensionConfig[slot];

            // Is the value fixed for this slot?
            if (v.match(/px$/)) {
                // Reduce the total size by the amount of this slots fixed size.
                widgetDimensionValue -= parseInt(v, 10);

                // Store this slot as fixed.
                fixedSlots[slot] = v;

            // Is the value a percentage for this slot?
            } else if (v.match(/%$/)) {
                // Store this slot as a percentage.
                percentageSlots[slot] = v;

            // Is the value "all"?
            } else if (v.match(/all/)) {
                allSlots[slot] = widgetRawValue;

            // Otherwise, it's an auto value.
            } else {
                autoSlots[slot] = v;
            }
        }

        // Where both auto and percentage slots found?
        if (!$HASH.isEmpty(autoSlots) && !$HASH.isEmpty(percentageSlots)) {
            // Iterate the children.
            for (i = 0, len = (ch && ch.length) || 0; i < len; i++) {
                child = ch[i];
                slot = child.slot || defaultSlot;

                // Does this child have an auto slot and is it not ignoring layout?
                if (slot && autoSlots[slot] && !child.ignoreLayout) {
                    // Has it rendered?
                    if (child.hasRendered) {
                        // DE102855: Use getBoundingClientRect for accurate measurements - especially necessary with a zoom factor.
                        var elem = this[slot];
                        autoSlotValues[slot] = elem.getBoundingClientRect ? Math.round(elem.getBoundingClientRect()[dimension.toLowerCase()]) : elem['offset' + dimension];

                        // Reduce the measured height by the offsetHeight of the slot.
                        widgetDimensionValue -= autoSlotValues[slot];

                    } else {
                        // Cache the slot of this widget for later measurement.
                        autoSlotValues[slot] = 0;

                        // Add event listener to hear when this component is done rendering.
                        child.attachEventListener((child instanceof mstrmojo.Container) ? 'childrenRendered' : 'renderComplete', this.id, adjustLayout);
                    }
                }
            }
        }

        // Return measurements.
        return {
            f: $HASH.isEmpty(fixedSlots) ? undefined : fixedSlots,
            p: $HASH.isEmpty(percentageSlots) ? undefined : percentageSlots,
            a: $HASH.isEmpty(autoSlotValues) ? undefined : autoSlotValues,
            n: $HASH.isEmpty(allSlots) ? undefined : allSlots,
            x: widgetDimensionValue,
            getSlotSizeInfo: function (slot, children) {
                // Is there no layout for this slot?
                if (!dimensionConfig[slot]) {
                    // Return auto values.
                    return autoBlock;
                }

                // Look for child and initialize return values.
                var slotChildren = mstrmojo.array.filter(children, function (child) {
                        var childSlot = child.slot;
                        return childSlot === slot || (slot === defaultSlot && !childSlot);
                    }),
                    slotValue,
                    value;

                // Is this a fixed slot?
                var fixedValue = fixedSlots[slot];
                if (fixedValue) {
                    // Set value to fixed value.
                    value = fixedValue;
                }

                // Is this a percent slot?
                var percentValue = percentageSlots[slot];
                if (percentValue) {
                    // Set value to calculated value (percentage of available space).
                    value = (this.x * parseInt(percentValue, 10) / 100) + px;
                }

                // Is this an auto slot?
                if (autoSlots[slot]) {
                    // Do we have a value for this auto slot?
                    value = autoSlotValues[slot];
                    if (value) {
                        // Add unit.
                        value += px;
                    } else {
                        value = auto;
                    }

                    // Slot value should be auto.
                    slotValue = auto;
                }

                // Is this an all slot?
                var allSlotValue = allSlots[slot];
                if (allSlotValue) {
                    // Value and slot value will be entire dimension size.
                    value = slotValue = allSlotValue + px;
                }

                // Default to zero.
                value = value || '0px';

                return {
                    v: value,
                    c: slotChildren,
                    sv: slotValue || value
                };
            }
        };
    }

    /**
     * Updates the dimension on the domNode and calls doLayout.
     *
     * @param {string} dimension The dimension to update, either "height" or "width".
     */
    function handleDimensionChange(dimension) {
        var dn = this.domNode;
        if (!dn || !this.layoutConfig) {
            return;
        }

        dn.style[dimension] = this[dimension];
        this.doLayout();
    }

    /**
     * <p>A mixin for applying "layout" to a widget, it's slots and children within those slots.</p>
     *
     * @mixin
     * @public
     */
    mstrmojo._HasLayout = mstrmojo.provide(
        'mstrmojo._HasLayout',

        /**
         * @lends mstrmojo._HasLayout
         */
        {
            _mixinName: 'mstrmojo._HasLayout',

            /**
             * The inner height of the entire widget.
             *
             * @type String
             * @default auto
             */
            height: 'auto',

            /**
             * The inner width of the entire widget.
             *
             * @type String
             * @default auto
             */
            width: 'auto',

            /**
             * Indicates if this child should be ignored by it's parent for calculating slot layout.
             *
             * @type Boolean
             * @default false
             */
            ignoreLayout: false,

            /**
             * A custom hook that will be called before the widget is laid out.
             */
            beforeLayout: mstrmojo.emptyFn,

            /**
             * A custom hook that will be called after the widget is laid out.
             */
            afterLayout: mstrmojo.emptyFn,

            /**
             * Indicates if doLayout should be forcibly called on this child.
             * This flag overrides the width and height matching check in setDimensions. Please use this sparingly and 
             * reset it immediately afterwards. Introduced to fix DE50892, and set in DocumentView.onAppStateChange().
             *
             * @type Boolean
             * @default false
             */
            forceLayout: false,

            /**
             * <p>The configuration object for the layout of this component.</p>
             *
             * <p>This object has two optional properties: h (for height) and w (for width).  The values of these properties are an Object with any number
             * of properties.  Each property name corresponds to a slot within the component and it's value can either be fixed (in pixels), a percentage
             * (with % sign), auto or all.</p>
             *
             * <p>For example:</p>
             *
             * <pre>{
             *         h: {
             *             top: '31px',
             *             containerNode: '100%',
             *             bottom: 'auto',
             *             gutter: 'all'
             *         }
             * }</pre>
             *
             * <p>This configuration would set the top slot to have a height of 31 pixels, the bottom slot would be auto (or fit to content), the
             * containerNode height would expand to occupy whatever space is not occupied by the top and bottom and the gutter slot would be equal
             * to the entire eight of the component (or the sum of the top, containerNode and bottom slots).</p>
             *
             * <p><b>NOTE:</b> To do this, the bottom slot would be measured after it's children render and the height of the container node would
             * be adjusted by the measured height of the bottom slot.</p>
             *
             * <p>Adding an "xt" property with a value of true to the layoutConfig will signal that the widget wants to use a new
             * and improved layout style that will layout it's slots regardless of whether there are children or not.</p>
             *
             * @type {{h: {}, v: {}, xt: boolean}}
             */
            layoutConfig: null,

            init: function init(props) {
                this._super(props);

                // Clone the layout config so all instances won't share the same layout config.
                this.layoutConfig = $HASH.clone(this.layoutConfig);
            },

            preBuildRendering: function preBuildRendering() {
                var cssText = this.cssText || '';

                var height = this.height;
                if (height && height !== auto) {
                    cssText += 'height:' + this.height + ';';
                }

                var width = this.width;
                if (width && width !== auto) {
                    cssText += 'width:' + this.width + ';';
                }

                this.cssText = cssText;

                return (this._super) ? this._super() : true;
            },

            postBuildRendering: function postBuildRendering() {
                // Layout all child components.
                this.doLayout();

                return this._super();
            },

            /**
             * Modifies the existing layout configuration and then lays out all children.
             *
             * @param {Object.<string, string>=} hConfig The horizontal configuration nodes to change.
             * @param {Object.<string, string>=} vConfig The vertical configuration nodes to change.
             */
            modifyLayoutConfig: function modifyLayoutConfig(hConfig, vConfig) {
                // Clone the existing config because it may be static.
                var cfg = this.layoutConfig = this.layoutConfig || {};

                // Copy new configuration properties to layout.
                cfg.h = $HASH.copy(hConfig, cfg.h);
                cfg.w = $HASH.copy(vConfig, cfg.w);

                // Perform layout again.
                this.doLayout();
            },

            /**
             * Returns an object containing the height and width amounts that dimensions for this objects should be reduced
             * to account for borders, margin and padding.
             *
             * @returns {{h: int, w: int}}
             * @abstract
             */
            getLayoutOffsets: mstrmojo.emptyFn,

            set: function set(n, v) {
                // TQMS 1005458: Previously we attach an "visibleChange" event handler.
                // However, when it's invoked, the markup method is not called yet and thus the DOM subtree is still invisible.
                // Now we simply set a flag and override 'set' in _HasMarkup to handle visible change.
                var ret = this._super(n, v);
                if (n === 'visible' && this._pendingLayoutOnVisible) {
                    delete this._pendingLayoutOnVisible;
                    this.doLayout();
                }

                return ret;
            },

            /**
             * Lays out the children and slots of this widget.
             */
            doLayout: function doLayout() {
                // Do we NOT have a layout config OR are BOTH height and width still set to auto?
                var lc = this.layoutConfig;
                if (!lc || (this.height === auto && this.width === auto)) {
                    // No reason to perform layout (yet).
                    return;
                }

                // Is this the new style of layout?
                if (lc.xt) {
                    // Is the widget NOT visible?
                    if (!this.visible) {
                        // TQMS 1005458: Previously we attach an "visibleChange" event handler.
                        // However, when it's invoked, the markup method is not called yet and thus the DOM subtree is still invisible.
                        // Now we simply set a flag and intercept 'set' to handle visible change.
                        this._pendingLayoutOnVisible = true;

                        // Do not layout at this time.
                        return;
                    }
                }

                // Call the beforeLayout handler.
                this.beforeLayout();

                // Initialize the _layoutWidgets collection.
                this._layoutWidgets = {
                    h: calculateDimension.call(this, lc.h, 'Height'),
                    w: calculateDimension.call(this, lc.w, 'Width')
                };

                // Apply the dimensions.
                applyDimensions.call(this, false);

                // Call the custom hook to denote that the widget was resized.
                this.widgetResized();
            },

            browserResized: function browserResized(size) {
                // Call set dimensions.
                this.setDimensions(size.h, size.w);

                return true;
            },

            /**
             * Sets the width of the domNode and then calls doLayout.
             */
            onwidthChange: function onwidthChange() {
                handleDimensionChange.call(this, 'width');
            },

            /**
             * Sets the height of the domNode and then calls doLayout.
             */
            onheightChange: function onheightChange() {
                handleDimensionChange.call(this, 'height');
            },

            /**
             * Determines if we want to skip the slot during layout for the current widget state.
             * @param slotName
             * @returns {boolean}
             */
            skipsSlotLayout: function (slotName) {
                return false;
            },

            /**
             * <p>This method will adjust the layout dimensions of the parent.</p>
             *
             * <p>This method will NOT reapply the dimensions.  This method is intended to be used during layout when the application of dimension values to this child
             * require that the parent's slot values be adjusted.  Use with care.</p>
             *
             * @deprecated Suspect it's no longer used.
             */
            adjustParentDimensions: function adjustParentDimensions() {
                var p = this.parent,
                    lw = p && p._layoutWidgets;

                // Does the parent have widgets to be laid out.
                if (lw) {
                    // Adjust the parents dimensions.
                    adjustDimension.call(p, this, lw.h, 'Height');
                    adjustDimension.call(p, this, lw.w, 'Width');
                }
            },

            /**
             * Changes the widget dimensions and calls doLayout.
             *
             * @param {string} h The height of the widget in pixels, e.g. '31px'.
             * @param {string} w The width of the widget in pixels, e.g. '31px'.
             *
             * @returns {Boolean} True if either dimension changed, False if neither did.
             */
            setDimensions: function setDimensions(h, w) {
                var hAuto = (h === auto) || h === 'NaNpx',
                    wAuto = (w === auto) || w === 'NaNpx';

                // Has the height or width changed (excluding auto)?

                // TQMS# 972403 Normalize the height and widths before comparison.  Unfortunately due to a change made in Vis.js in 2011
                //              visualizations store their height and width WITHOUT the "px".  The rest of Mojo does the opposite.

                if ((!hAuto && parseInt(this.height, 10) !== parseInt(h, 10)) || (!wAuto && parseInt(this.width, 10) !== parseInt(w, 10)) || this.forceLayout) {
                    // Set new dimensions on instance.
                    if (!hAuto) {
                        this.height = h;
                    }

                    if (!wAuto) {
                        this.width = w;
                    }

                    // Do we have a DOM node?
                    var dn = this.domNode,
                        dnStyle = dn && dn.style;

                    if (dnStyle) {
                        // Resize DOM node.
                        if (!hAuto) {
                            dnStyle.height = h;
                        }

                        if (!wAuto) {
                            dnStyle.width = w;
                        }

                        // Layout children.
                        this.doLayout();
                    }

                    return true;
                }

                return false;
            },

            /**
             * Sets the height and width for the supplied slot.
             *
             * @param {string} slot The name of the slot whose dimension should be set.
             * @param {string=} h The new height value in pixels, e.g. '31px'.
             * @param {string=} w The new width value in pixels, e.g. '31px'.
             */
            setSlotDimensions: function setSlotDimensions(slot, h, w) {
                // Does the slot not have a style collection?
                var sl = this[slot] && this[slot].style;
                if (!sl) {
                    // Nothing to do.
                    return;
                }

                // Is the height NOT auto AND NOT undefined (IE compatible required check) and does it NOT match the current height?
                if (h !== auto && h !== undefined && h !== 'NaNpx' && sl.height !== h && parseInt(h) >= 0) {
                    // Apply the height.
                    sl.height = h;
                }

                // Is the width NOT auto AND NOT undefined (IE compatible required check) and does NOT match the current width?
                if (w !== auto && w !== undefined && w !== 'NaNpx' && sl.width !== w && parseInt(w) >= 0) {
                    // Apply the width.
                    sl.width = w;
                }
            }

        }
    );

    /**
     * Static method to get slot size once the device DIP is used to change the layout config height/width.
     *
     * @param {mstrmojo._HasLayout} constructor The constructor whose layout is requested.
     * @param {string} slot The slot whose layout is requested.
     *
     * @returns {{h: string, w: string}}
     * @static
     */
    mstrmojo._HasLayout.getSlotSize = function getSlotSize(constructor, slot) {
        var layoutCfg = constructor && constructor.prototype.layoutConfig;
        if (layoutCfg) {
            var h = layoutCfg.h,
                w = layoutCfg.w;

            return {
                h: (h && h[slot]) || undefined,
                w: (w && w[slot]) || undefined
            };
        }

        return null;
    };

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.dom",
                         "mstrmojo.hash");

    var $DOM = mstrmojo.dom,
        $HASH = mstrmojo.hash,
        $DND,
        $DOC = mstrmojo.global.document,
        EVT_MOUSE_DOWN = 'mousedown',
        EVT_MOUSE_MOVE = 'mousemove',
        EVT_MOUSE_UP = 'mouseup';

    /**
     * Begins checking for drag operations.
     *
     * @param {Event=} e The mouse down event.
     */
    function onMouseDown(e) {
        // Is this the primary mouse button?
        if ($DOM.isPrimaryMouseBtn(e)) {
            // Initiate drag.
            $DND.startDragCheck(self, e);
        }
    }

    var avatar,
        avatarFirstChild,
        CSS_AVATAR = 'mstrmojo-dnd-avatar',
        avatarStyle;

    /**
     * Updates the avatar with position and HTML.
     *
     * @param {{x: number, y: number}} pos The new position.
     * @param {string=} html The new HTML.
     *
     * @private
     */
    function updateAvatar(pos, html) {
        // Was new HTML provided (including empty string)?
        if (html !== undefined && html !== null) {
            // Set first child to supplied HTML.
            avatarFirstChild.innerHTML = html;
        }

        // Update position.
        avatarStyle.left = pos.x + 'px';
        avatarStyle.top = pos.y + 'px';
    }

    /**
     * Displays the avatar.
     *
     * @param {{x: number, y: number}} pos The position to display the avatar.
     * @param {string=} html The HTML for the avatar.
     *
     * @private
     */
    function showAvatar(pos, html) {
        // Have we NOT created the avatar yet?
        if (!avatar) {
            // Create and cache avatar and avatar style and append to body.
            avatar = $DOC.createElement('div');
            avatarStyle = avatar.style;
            avatar.className = CSS_AVATAR;
            avatar.innerHTML = '<div class="' + CSS_AVATAR + '-inner"></div>';
            avatarFirstChild = avatar.firstChild;
            $DOC.body.appendChild(avatar);
        }

        // Update the avatar position and HTML.
        updateAvatar(pos, html);

        // Show avatar.
        avatarStyle.display = 'block';
    }

    /**
     * Hides the avatar.
     */
    function hideAvatar() {
        // Do we have an avatar?
        if (avatarStyle) {
            // Hide it.
            avatarStyle.display = 'none';
        }
    }

    /**
     * <p>Callback for mouse moves that occur after a mouse down. If sufficient # of mouse moves are
     * captured, a drag is initiated.</p>
     *
     * @param {Event=} e The mouse move DOM event object; possibly null in some browsers.
     *
     * @private
     */
    function onMoveDuringCheck(e) {
        var c = ++$DND.ctxt.moveCount;
        if (c >= $DND.minMoves) {
            // Stop checking for a drag; initiate a drag.
            $DND.stopDragCheck();

            // Ensure left-button is still pressed to avoid scenarios where mouse is released during check but dnd does not receive it
            /*******************************/
            // DE23061
            // For IE 9, e.buttons is 0. The return value of e.buttons should be as follow. So I just use '$DOM.isIE9' here
            // 1  : Left button
            // 2  : Right button
            // 4  : Wheel button or middle button
            // 8  : 4th button (typically the "Browser Back" button)
            // 16 : 5th button (typically the "Browser Forward" button)
            if ((e.buttons === 1 || e.buttons === undefined || $DOM.isIE9) && (e.which === 1 || e.button === 0 || $DOM.isIE8)) {
                $DND.startDrag(self, e);
            }
        }
    }

    /**
     * <p>Callback for mouse up that occurs after a mouse down but before sufficient mouse moves to
     * initiate a drag.</p>
     *
     * <p>Detaches event listeners that were checking for the start of a drag, and
     * clears the context object of the controller.</p>
     *
     * @param {Event=} e The mouse up DOM event object; possibly null in some browsers.
     *
     * @private
     */
    function onUpDuringCheck(e) {
        // Is this the primary mouse button?
        if ($DOM.isPrimaryMouseBtn(e)) {
            $DND.stopDragCheck();

            // TQMS# 974205 delete the context as no drag occurred
            delete $DND.ctxt;
        }
    }

    /**
     * <p>Callback for mouse move that occurs during a drag.</p>
     *
     * @param {Event=} e The mouse up DOM event object; possibly null in some browsers.
     *
     * @private
     */
    function onMoveDuringDrag(e) {
        $DND.onDragMove(self, e);
    }

    /**
     * <p>Callback for mouse up that occurs during a drag, ending it.</p>
     *
     * @param {Event=} e The mouse up DOM event object; possibly null in some browsers.
     *
     * @private
     */
    function onUpDuringDrag(e) {
        // Is the mouse up the primary mouse button?
        if ($DOM.isPrimaryMouseBtn(e)) {
            // Stop the drag.
            $DND.stopDrag(window, e);
        }
    }

    /**
     * <p>Given a DOM node, returns the nearest draggable widget that contains that DOM node.</p>
     *
     * <p>Used to determine what widget is being dragged when a mouse down occurs.</p>
     *
     * @param {Node|HTMLElement} nd The DOM event target node.
     * @returns {mstrmojo.Widget} The corresponding widget, if any; null otherwise.
     */
    function findDraggable(nd) {
        var w = $DOM.findWidget(nd);
        while (w) {
            if (w.draggable) {
                return w;
            }
            w = w.parent;
        }
        return null;
    }

    /**
     * Searches the DOM tree for a widget that can handle the current drag operation and returns it if found.
     *
     * @param {Object} context The dragging context.
     * @returns {mstrmojo.Widget}
     *
     * @private
     */
    function getVerifiedDragWidget(context) {
        var src = context.src,
            widget = findDraggable(src.node);
        if (!widget) {
            return null;
        }

        // Can the widget supply a dnd action?
        if (widget.getDragAction) {
            // Get action from widget.
            context.action = widget.getDragAction(context);
        }

        // Ask the widget for any extra contextual data regarding this drag.
        src.widget = widget;
        src.data = widget.getDragData && widget.getDragData(context);

        // Does the widget have an isDragValid method?
        if (widget.isDragValid) {
            // Is the drag NOT valid?
            if (!widget.isDragValid(context)) {
                // Has the widget explicitly prevented drag bubbling?
                //vis filter consumption mode should not support configure template, so disable dnd for consumption mode
                if (!mstrApp.isInVFInteractMode && (!widget.shouldDragBubble || widget.shouldDragBubble(context) === true)) {
                    // Drag was cancelled by the source widget - so let's bubble it up.
                    context.src.node = widget.domNode.parentNode;
                    return getVerifiedDragWidget(context);
                }

                // Widget decided to prevent drag bubbling - return null for the drag widget.
                return null;
            }
        }

        // Does the widget have an drag start method?
        if (widget.ondragstart) {
            // Notify the widget it is being dragged.
            widget.ondragstart(context);
        }

        // Return widget as draggable.
        return widget;
    }

    /**
     * <p>Given a DOM node, returns the nearest widget that contains that DOM node and:</p>
     *
     * <ol>
     *     <li>is a drop zone, and,</li>
     *     <li>allows a drop with the given dragging context.</li>
     * </ol>
     *
     * <p>Used to determine what widget is being dragged when a mouse down occurs.</p>
     *
     * @param {Node|HTMLElement} node The DOM event target node.
     * @param {Object} context The dragging context.
     *
     * @returns {mstrmojo.Widget} The corresponding widget, if any; null otherwise.
     */
    function findDropWidget(node, context) {
        var w = $DOM.findWidget(node),
            targetWidget = context.tgt && context.tgt.widget;

        while (w) {
            // Is the widget a drop zone?
            if (w.dropZone) {
                // Is the widget already identified as the target?
                if (w === targetWidget) {
                    // Return widget as droppable.
                    return w;
                }

                // Does the widget have an allowDrop method AND does it return true when called?
                if (w.allowDrop && w.allowDrop(context)) {
                    // Return widget as droppable.
                    return w;
                }
            }

            // Reset to parent.
            w = w.parent;
        }

        return null;
    }

    /**
     * The default method applied to a drop zone if that drop zone widget has no ondragleave method.
     *
     */
    function defaultDragLeaveHandler() {
        if (this.set) {
            this.set("allowingDrop", false);
        }
    }

    /**
     * A singleton controller for managing drag-drop events across widgets.
     *
     * @namespace mstrmojo.dnd
     * @static
     */
    mstrmojo.dnd = mstrmojo.dnd || mstrmojo.provide(        // TQMS #927797: avoid being defined more than once.
        "mstrmojo.dnd",

        /**
         * @lends mstrmojo.dnd
         */
        {
            /**
             * <p>Minimum number of mouse moves required after a mouse down to start a drag.</p>
             *
             * @type {int}
             * @default 3
             */
            minMoves: 3,

            /**
             * <p>Attaches mouse down listener to the document in order to start capturing drags.</p>
             */
            enable: function () {
                // Is drag and drop NOT enabled already?
                if (!mstrmojo.dndEnabled) {
                    // Attach event listener to document and set DND as enabled.
                    $DOM.attachEvent($DOC, EVT_MOUSE_DOWN, onMouseDown);
                    mstrmojo.dndEnabled = true;
                }
            },

            /**
             * <p>Detaches mouse down listener to the document to stop capturing drags.</p>
             */
            disable: function () {
                mstrmojo.dndEnabled = false;
                $DOM.detachEvent($DOC, EVT_MOUSE_DOWN, onMouseDown);
            },

            /**
             * <p>Notifies this controller of a mouse down which may potentially turn into a drag if followed
             * by sufficient number of mouse moves.</p>
             *
             * <p>Attaches listeners for mouse move and mouse up in the document. If enough mouse moves are
             * then heard, the callback initiates a drag.</p>
             *
             * @param {window|Object} hWin The window the event occured in.
             * @param {Event=} e The event.
             */
            startDragCheck: function (hWin, e) {
                // Delete current context.
                delete this.ctxt;

                // Get event info.
                var src = $DOM.captureEventInfo({
                    hWin: hWin,
                    e: e
                });

                // Create new context.
                this.ctxt = {
                    src: src,
                    moveCount: 0,
                    last: $HASH.copy(src.pos),          // The last measured dnd position.
                    getDirection: function (axis) {     // Returns a boolean indicating if the drag is positive or negative along the supplied axis.
                        return !!this.dir[axis];
                    },
                    getCtxtDragData: function () {
                        var src = this.src;
                        return (src && src.data) || {};
                    },
                    getCtxtDropData: function () {
                        var tgt = this.tgt;
                        return (tgt && tgt.data) || {};
                    }
                };

                // Do we have a minimum moves threshold?
                if (this.minMoves) {
                    // Attach DOM event listeners to possibly initiate drag soon.
                    $DOM.attachEvent($DOC, EVT_MOUSE_MOVE, onMoveDuringCheck);
                    $DOM.attachEvent($DOC, EVT_MOUSE_UP, onUpDuringCheck);

                } else {
                    // Initiate drag immediately.
                    this.startDrag(hWin, e);
                }
            },

            /**
             * <p>Detaches listeners for mouse move and mouse up in the document that were waiting for
             * sufficient mouse moves after a mouse down to initiate a drag.</p>
             *
             */
            stopDragCheck: function () {
                $DOM.detachEvent($DOC, EVT_MOUSE_MOVE, onMoveDuringCheck);
                $DOM.detachEvent($DOC, EVT_MOUSE_UP, onUpDuringCheck);
            },

            /**
             * <p>Notifies the widget being dragged that a drag is starting, and attaches listeners for mouse move and
             * mouse up in the document to notify widgets that they are getting dragged-over and dropped-onto.</p>
             */
            startDrag: function (hWin, e) {
                // Give this drag context a new id so it can be uniquely identified.
                var context = this.ctxt;
                context.id = mstrmojo.now();

                // Is there NO widget that can handle this drag?
                var widget = getVerifiedDragWidget(context);
                if (!widget) {
                    return;
                }

                // In Firefox, this will stop native browser highlighting of text as we drag.
                // TO DO: IMPORTANT! test in other browsers (Safari, IE, Chrome).
                $DOM.clearBrowserHighlights(hWin);
                $DOM.preventDefault(self, e);

                $DOM.attachEvent($DOC, EVT_MOUSE_MOVE, onMoveDuringDrag);
                $DOM.attachEvent($DOC, EVT_MOUSE_UP, onUpDuringDrag);

                // Is there an application object?
                var app = window.mstrApp;
                // Is there a setInteractive method (E.g. in RWD editable mode) ?
                if (app && app.setInteractive) {
                    // Change application interactivity and cache whether it actually changed.
                    this._changeAppStatus = app.setInteractive(false);
                }

                if (!widget.ownAvatar) {
                    var src = context.src;
                    showAvatar(src.pos, src.data && src.data.html);
                }
            },

            /**
             * <p>Detaches listeners for mouse move and mouse up in the document, notifies the widget being dropped upon
             * (if any) and notifies the widget being dragged that a drag is ending.</p>
             *
             * @param {window|Object} hWin The DOM window in which the mouse up occurred.
             * @param {Event=} e The mouse up DOM event (possibly null in some browsers).
             */
            stopDrag: function (hWin, e) {
                // Detach event listeners.
                $DOM.detachEvent($DOC, EVT_MOUSE_MOVE, onMoveDuringDrag);
                $DOM.detachEvent($DOC, EVT_MOUSE_UP, onUpDuringDrag);

                // Compute the targeted widget.
                var context = this.ctxt,
                    lastTarget = context.tgt || {},
                    ct = $DOM.captureEventInfo({
                        hWin: hWin,
                        e: e,
                        data: lastTarget.data
                    }),
                    widget = findDropWidget(ct.node, context);

                ct.widget = widget;
                context.tgt = ct;

                // If drop is allowed, notify target widget of a drop on it.
                // We do this before calling the drag source widget's
                // ondragend because ondragend might remove the dragged items, which
                // could cause the entire drag target and/or drag source widgets to be
                // removed before we get a chance to do the ondrop!  (For example, in an
                // expression tree, ondragend will remove a node, which in turn consolidates
                // its parent, which could remove in the parent node being removed, as well
                // as some of its ancestors.)
                if (widget) {
                    // Call the widget's ondrop, our apply a default ondrop.
                    if (widget.ondrop) {
                        widget.ondrop(context);
                    } else {
                        defaultDragLeaveHandler.call(widget);
                    }
                }

                // Notify source widget that drag is over.
                var s = context.src.widget;
                if (s && s.ondragend) {
                    s.ondragend(context);
                }

                if (s && !s.ownAvatar) {
                    hideAvatar();
                }

                // Did we change the application interactivity?
                if (this._changeAppStatus) {
                    // Restore application interactivity and clear flag.
                    window.mstrApp.setInteractive(true);
                    delete this._changeAppStatus;
                }
            },

            /**
             * <p>Notifies drag source and target of a mouse move during a drag.</p>
             *
             * @param {window|Object} hWin The DOM window in which the mouse move occurred.
             * @param {Event=} e The mouse move DOM event (possibly null in some browsers).
             */
            onDragMove: function (hWin, e) {
                if ($DOM.isSafari) {
                    $DOM.clearBrowserHighlights();
                }

                var context = this.ctxt,
                    lastTarget = context.tgt || {},
                    lastTargetWidget = lastTarget.widget,
                    evtInfo = $DOM.captureEventInfo({
                        hWin: hWin,
                        e: e,
                        data: lastTarget.data
                    }),
                    dropWidget = evtInfo.widget = findDropWidget(evtInfo.node, context),
                    lastPosition = context.last,
                    currentPosition = evtInfo.pos;

                // Calculate drag directions.
                context.dir = {
                    x: currentPosition.x > lastPosition.x,
                    y: currentPosition.y > lastPosition.y
                };

                // Replace last position.
                context.last = $HASH.copy(evtInfo.pos);

                // Set target on context.
                context.tgt = evtInfo;

                // Has the drop widget changed?
                if (lastTargetWidget !== dropWidget) {
                    // Either this is the first drag move, or the target has changed since last drag move.

                    // Call ondragleave on the last target (if possible).
                    if (lastTargetWidget) {
                        // Call the widget's ondragleave, or if missing, apply a default handler.
                        if (lastTargetWidget.ondragleave) {
                            lastTargetWidget.ondragleave(context);
                        } else {
                            defaultDragLeaveHandler.call(lastTargetWidget);
                        }
                    }

                    // Call ondragenter on the new target (if possible).
                    if (dropWidget) {
                        // Add drop data (or replace if none).
                        context.tgt.data = (dropWidget.getDropData && dropWidget.getDropData(context)) || {};

                        // Call the widget's ondragenter, or if missing, apply a default handler.
                        if (dropWidget.ondragenter) {
                            dropWidget.ondragenter(context);
                        } else {
                            if (dropWidget.set) {
                                dropWidget.set("allowingDrop", true);
                            }
                        }
                    }
                }

                if (dropWidget) {
                    // Call drop widget ondragmoveto update its display and decide where exactly a drop is allowed.
                    // TO DO: only call ondragmove if cacheAllowDrop is not exactly true.
                    if (dropWidget.ondragover) {
                        dropWidget.ondragover(context);
                    }
                }

                // Let the source know that it is moving.
                var sourceWidget = context.src.widget;
                if (sourceWidget && sourceWidget.ondragmove) {
                    sourceWidget.ondragmove(context);
                }

                if (sourceWidget && !sourceWidget.ownAvatar) {
                    updateAvatar(evtInfo.pos);
                }
            }

        }
    );

    $DND = mstrmojo.dnd;

    // Wire up the document to start listening for drags.
    $DND.enable();
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.hash");

    /**
     * Public lookup of registered objects, keyed by id.
     *
     * @type {Object.<string, mstrmojo.Obj>}
     * @static
     */
    mstrmojo.all = {};

    var $REGISTRY = mstrmojo.all,
        $HASH = mstrmojo.hash;

    /**
     * <p>A counter used for auto-generated ids.</p>
     *
     * @type {int}
     */
    var freeIdCounter = 0;

    /**
     * <p>Returns a unique auto-generated id that is not currently used in the {@link mstrmojo.all} collection.</p>
     *
     * <p>The id will following the syntax "mstr#" where "#" is an integer.</p>
     *
     * @returns {string}
     */
    function getFreeID() {
        var id;
        while (!id) {
            // Create test ID.
            var testId = 'mstr' + (freeIdCounter++);

            // Is test ID NOT found in the registry?
            if (!$REGISTRY[testId]) {
                // Use this ID>
                id = testId;
            }
        }

        return id;
    }

    /**
     * <p>Manages a lookup of mojo objects.</p>
     *
     * @namespace mstrmojo.registry
     */
    mstrmojo.registry = mstrmojo.provide(
        "mstrmojo.registry",

        /**
         * @lends mstrmojo.registry
         */
        {
            /**
             * <p>Adds an object to the lookup.</p>
             *
             * <p>The object must have a non-null "id" property, and that id must not already be used in the lookup;
             * otherwise, throws an error.</p>
             *
             * @param {Object} obj The object to be added to the lookup.
             */
            add: function add(obj) {
                if (!obj) {
                    return;
                }

                // If we don't have an id (null|undefined), get an auto-generated one, so we can be looked up by id later.
                var id = obj.id;
                if (!id) {   // if id is null OR undefined
                    obj.id = id = getFreeID();
                } else if ($REGISTRY[id]) {
                    throw new Error("Tried to register 2 objects with same id: " + id);
                }

                $REGISTRY[id] = obj;
            },

            /**
             * <p>Removes a given object from the lookup.</p>
             *
             * @param {Object} obj The object to be removed from the lookup.
             */
            remove: function rmv(obj) {
                if (obj && obj.id) {    // if id is not null and not undefined
                    delete $REGISTRY[obj.id];
                }
            },

            /**
             * Dumps the ID and, if possible, scriptClass properties of all objects in mstrmojo.all to console.
             */
            dumpAll: function () {
                var o;
                for (o in $REGISTRY) {
                    var id = $REGISTRY[o].id;
                    if (id) {
                        mstrmojo.dbg(id + "(" + ($REGISTRY[o].scriptClass || "[unknown class]") + ")");
                    }
                }
            },

            /**
             * <p>Attempts to convert a given object reference into an instance of a javascript class.</p>
             *
             * <p>The object reference may be either of the following:</p>
             * <ol>
             *     <li>a fully qualified class name (String); or</li>
             *     <li>a hash table of properties, which includes a "scriptClass" property; or</li>
             *     <li>an instance of a javascript class.</li>
             * </ol>
             *
             * <p>In case #1, the FQCN is loaded (if needed) and evaluated. If the evaluated result
             * is a Function, it is assumed to be a constructor and then used to instantiate a
             * return value. Otherwise if the evaluated result is an object, then the object is
             * used for either cases #2 (for a native object) or #3 (for an instance of a javascript class).</p>
             *
             * <p>In case (2), the hash table's scriptClass property determines what constructor
             * is called to instantiate a javascript class.  The hash table is passed into the
             * constructor call. If no scriptClass property is defined, the hash table is returned.</p>
             *
             * <p>In case (3), the given instance is returned.</p>
             *
             * @param {String|Object} config The object reference to be evaluated.
             * @param {{skipLoadChecks: boolean, dontInst: boolean, clone: boolean}=} flags Hash table of flags to customize this function call's behavior:
             * <ul>
             *     <li>skipLoadChecks: If true, this method will skip calling mstrmojo.requiresCls before evaluating an FQCN string.</li>
             *     <li>dontInst: If true, when this method evaluates a reference as a Function, it will return that Function; otherwise, this method assumes the Function is a constructor and calls the Function to create a new object instance.</li>
             *     <li>clone: If true, when this method evaluates a reference as a hash table of properties, it will pass in a clone of the hash table, rather than the hash table itself, to a class constructor.</li>
             * </ul>
             *
             * @returns {Object}
             */
            ref: function ref(config, flags) {
                flags = flags || {};

                if (config) {
                    var C = config;
                    while (C) {
                        switch (typeof C) {
                        // FQCN.
                        case "string":
                            // Should we verify the script class is loaded?
                            if (flags.skipLoadChecks !== true) {
                                // Require the class.
                                mstrmojo.requiresCls(C);
                            }

                            // Reset C to the constructor.
                            C = $HASH.walk(C, window);
                            break;

                        // Constructor.
                        case "function":
                            // A constructor. Call it, unless explicitly asked not to.
                            return (flags.dontInst !== true) ? new C() : C;

                        // Instantiated class.
                        case "object":
                            if (C.constructor === Object) {
                                // A hash table of properties; try to convert to script class instance.
                                var sc = C.scriptClass;
                                if (sc) {
                                    // Script class FQCN is specified; load and evaluate it.
                                    if (flags.skipLoadChecks !== true) {
                                        mstrmojo.requiresCls(sc);
                                    }

                                    var Cls = $HASH.walk(sc, window);
                                    if (Cls) {
                                        // Got the constructor; call it.
                                        return new Cls((flags.clone === true) ? $HASH.clone(C) : C);
                                    }

                                    // Couldn't load the constructor; failed.
                                    return null;
                                }

                                // Script class FQCN not specified; return the hash table.
                                return C;
                            }

                            // A javascript custom class instance.
                            return C;

                        default:
                            return null;
                        }
                    }
                }

                return null;
            }
        }
    );

    /**
     * <p>Shortcut to mstrmojo.registry.ref method, for convenience.</p>
     *
     * @type {Function}
     * @return {Object}
     */
    mstrmojo.insert = mstrmojo.registry.ref;
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.hash");

    /**
     * The mstr event object.
     *
     * @class
     */
    mstrmojo.Event = mstrmojo.declare(
        null,

        null,

        /**
         * @lends mstrmojo.Event.prototype
         */
        {
            scriptClass: "mstrmojo.Event",

            init: function init(props) {
                // Is the event missing a name? If so, try using the event "type" (if any).
                if (props && !props.name) {
                    props.name = props.type;
                }

                // Copy all the properties to this new instance.  For performance optimization,
                // use copy rather than mixin.  Later when we have more instance methods for
                // this class, we might need to change to mixin instead of copy.
                mstrmojo.hash.copy(props, this);
            },

            /**
             * The name of the event.
             *
             * @type {string}
             * @default ''
             */
            name: '',

            /**
             * The source of the event.
             *
             * @type {mstrmojo.Obj}
             * @default null
             */
            src: null
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.hash",
                         "mstrmojo.array");

    /**
     * <p>Hashtable of subscriptions with callbacks to method names, keyed by publisher ID.</p>
     *
     * <p>The "subs" hashtable maps a publisher ID to the event names for which that publisher has subscriptions.
     * The event names are stored in a hashtable, which is keyed by event name.  That event hashtable, in turn,
     * maps an event name to the listener IDs for that event.  Each listener ID represents an object which wishes to
     * be notified when that given event name is published by the given publisher ID.  The list of listener IDs is
     * a hashtable as well, keyed by listener ID, where key value is a list of callbacks to that listener.  Generally,
     * a listener maybe ask for multiple callbacks, each of which may be either a method name or a Function object.
     * This hashtable stores these callbacks in an object with properties "methods" and "functions".
     * Note that an empty listener ID ("") is used to store callbacks to global methods.</p>
     *
     * <p>In summary, the hashtable's internal structures look like this:</p>
     * <pre>
     * subs[publisherId][evtName][listenerId] = {
     *  methods: {
     *    "methodName1": true,
     *    "methodName2": true,
     *    ..
     *  },
     *  functions: [
     *    Function1,
     *    Function2,
     *    ..
     *  ]
     * }
     * </pre>
     *
     * @type Object
     * @private
     * @static
     */
    var _subs = {};

    /**
     * A map of listeners so that we can release subscriptions when a listening instance is destroyed.
     *
     * @type Object
     * @private
     * @static
     */
    var _listenerMap = {};

    /**
     * <p>A publish-and-subscribe system for broadcasting events to observable objects in a mojo application.</p>
     *
     * @namespace mstrmojo.publisher
     */
    mstrmojo.publisher = mstrmojo.provide(
        "mstrmojo.publisher",

        /**
         * @lends mstrmojo.publisher
         */
        {
            /**
             * <p>Notifies subscribers of an event occurrence.</p>
             *
             * <p>All subscribers to that object's event will receive the data via whatever callback they used to subscribe.</p>
             *
             * @param {String} id The ID of the object that is publishing this event.
             * @param {String} type The name of the event to publish.
             * @param {Object} data The event occurrence information.
             */
            publish: function pub(id, type, data) {
                // Retrieve the hash of listener ids for this publisher + event combo.
                var ls = _subs[id] && _subs[id][type],
                    lid;
                if (!ls) {
                    return;
                }

                // Notify the listeners.
                for (lid in ls) {
                    // Get a handle to the listener, if any.
                    var l = null;
                    if (lid) {
                        l = mstrmojo.all[lid];
                        //A safty check for the case when the same listener was added several times.
                        //The optimization in the clearSubscriptions - using the listener to source map
                        //doesn't remove a listener if it was added more then once. This code will clean
                        //such orphan subscriptions.
                        if (!l) {
                            delete ls[lid];
                            continue;
                        }
                    }
                    // Call the methods subscribed on that listener.
                    var ns = ls[lid].methods;
                    if (ns) {
                        // If we have a listener object, call its method.
                        // Without a listener, use the global context.
                        var ctxt = l || mstrmojo.global,
                            n;
                        for (n in ns) {
                            if (ctxt[n]) {
                                ctxt[n](data);
                            }
                        }
                    }
                    // Call the Functions subscribed on that listener.
                    // Notify them in reverse order in case some callback deletes a callback.
                    // Also do a null check on ls[lid] because method callbacks above may have
                    // removed it from the listener hash.
                    var fs = ls[lid] && ls[lid].functions,
                        flen = (fs && fs.length) || 0;
                    if (flen) {
                        var i;
                        if (l) {
                            // If we have a listener object, apply the Function to it.
                            for (i = flen - 1; i > -1; i--) {
                                if (fs[i]) {
                                    fs[i].apply(l, [data]);
                                }
                            }
                        } else {
                            // Without a listener object, just call the Function directly.
                            // We avoid using apply() here for performance.
                            for (i = flen - 1; i > -1; i--) {
                                if (fs[i]) {
                                    fs[i](data);
                                }
                            }
                        }
                    }

                }
            },

            /**
             * <p>Requests that an object be notified of a future event in another object.</p>
             *
             * @param {String} id The ID of the object that will do the publishing.
             * @param {String} type The type of the event that will be listened for.
             * @param {Function|String} callback Either a Function, or the name of a listener method, to call when the event is published.
             * @param {String} [listener] ID of the listener to be notified when the given event is published. If missing, the global context is assumed to be the listener.
             *
             * @returns {Object} A newly generated identifier (Object) for this subscription, which can then be used to call unsubscribe() later.
             */
            subscribe: function sub(id, type, callback, listener) {

                // Validate publisher's hash.
                var s = _subs[id];
                if (!s) {
                    s = {};
                    _subs[id] = s;
                }

                // Validate publisher's event's hash.
                var e = s[type];
                if (!e) {
                    e = {};
                    s[type] = e;
                }

                // Validate publisher's event's listener's hash.
                var l = e[listener || ""];
                if (!l) {
                    l = {};
                    e[listener || ""] = l;
                }

                // Record the callback under either "methods" or "functions", depending on type.
                if (typeof callback  === "function") {
                    var fs = l.functions;
                    if (!fs) {
                        fs = [];
                        l.functions = fs;
                    }
                    fs.push(callback);
                } else {
                    // Assume callback is a String; a method name.
                    var ms = l.methods;
                    if (!ms) {
                        ms = {};
                        l.methods = ms;
                    }
                    ms[callback] = true;
                }

                // Performance optimization: To enable a reverse lookup, record a map from listener to publisher.
                var lmap = _listenerMap,
                    pmap = lmap[listener || ""];
                if (!pmap) {
                    pmap = {};
                    lmap[listener || ""] = pmap;
                }
                var emap = pmap[id];
                if (!emap) {
                    emap = {};
                    pmap[id] = emap;
                }
                emap[type] = true;


                // Return a handle to this subscription to use for unsubscribing later.
                return {
                    id: id,
                    type: type,
                    callback: callback,
                    listener: listener,
                    clear: function () {
                        mstrmojo.publisher.unsubscribe(this);
                    }
                };
            },

            /**
             * <p>Cancels a subscription created by calling the subscribe() method.</p>
             *
             * @param {Object} sub The subscription object provided by the subscribe() call.
             */
            unsubscribe: function unsub(sub) {
                var s = _subs[sub.id],
                    e = s && s[sub.type],
                    l = e && e[sub.listener || ""];
                if (!l) {
                    return;
                }

                var A = mstrmojo.array,
                    H = mstrmojo.hash,
                    tp = typeof sub.callback,
                    cleanupListener = false;
                if (tp === "function") {
                    // Remove the callback from the functions array.
                    var fs = l.functions;
                    if (fs) {
                        A.removeItem(fs, sub.callback);
                        if (!fs.length) {
                            // If array now empty, remove it.
                            delete l.functions;
                            // If no callbacks remain, remove listener id.
                            if (H.isEmpty(l.methods)) {
                                cleanupListener = true;
                            }
                        }
                    }
                } else {
                    // Remove the callback from the methods hash.
                    var ms = l.methods;
                    if (ms) {
                        delete ms[sub.callback];
                        if (H.isEmpty(ms)) {
                            // If the hash is now empty, remove it.
                            delete l.methods;
                            // If no callbacks remain, remove listener id.
                            if (!l.functions || !l.functions.length) {
                                cleanupListener = true;
                            }
                        }
                    }
                }
                // Did we remove the final callback from the listener?
                if (cleanupListener) {
                    // Yes, now remove the listener id from the listeners hash.
                    delete e[sub.listener || ""];
                    // And if there are no more listeners for this event...
                    if (H.isEmpty(e)) {
                        // Remove the listeners hash entirely for this event.
                        delete s[sub.type];
                    }
                }
            },

            /**
             * <p>Determines if a specified object hasany listeners subscribed for a given event.</p>
             *
             * @param {String} id The ID of the publishing object.
             * @param {String} type The name of the event.
             *
             * @returns {Boolean} true if the object has at least one listener; false otherwise.
             */
            hasSubs: function hasSubs(id, type) {
                var s = _subs[id],
                    evt = s && s[type];

                return !!evt;
            },

            /**
             * Clear all subscriptions for listeners of the component as well as any subscriptions the component has for other objects.
             *
             * @param {String} listener The id of the component whose subscriptions should be cleared.
             */
            clearSubscriptions: function clr(listener) {
                if (!listener) {
                    listener = "";
                }
                var sbs = _subs,
                    _H = mstrmojo.hash,
                    id;

                // Do we have anybody listening to this object?
                if (sbs[listener]) {
                    // Delete the subscriptions to this object.
                    delete sbs[listener];
                }

                // Is this object listening to anybody else?
                var pmap = _listenerMap[listener];
                if (pmap) {
                    // Walk the event providers...
                    for (id in pmap) {
                        var es = sbs[id],
                            emap = pmap[id],
                            e;
                        if (!es) {
                            continue;
                        }
                        // Walk the event names...
                        for (e in emap) {
                            // Remove this listener from that event.
                            var ls = es[e];
                            if (!ls) {
                                continue;
                            }
                            delete ls[listener];
                            // If there are no remaining listeners for that event...
                            if (_H.isEmpty(ls)) {
                                // ...remove the listeners hash for that event entirely.
                                delete es[e];
                            }
                        }
                    }
                }
                delete _listenerMap[listener];
            }
        }
    );

    mstrmojo.publisher.NO_SRC = "NO_SRC";
    mstrmojo.publisher.CONNECTIVITY_CHANGED_EVENT = "CONNECTIVITY_CHANGED";
    mstrmojo.publisher.RECONCILE_END_EVENT = "RECONCILE_END";

}());
(function () {
    mstrmojo.requiresCls("mstrmojo.hash");

    var reCHAIN_THIS = /this\.([\w\.\[\]\'\"\-]+)/m,
        reCHAIN_THIS_TEST = /this\./m,
        reCHAIN_ALL_BRACKET = /mstrmojo\.all\[[\'\"]([\w]+)[\'\"]\]\.([\w\.\[\]\'\"\-]+)/m,
        reCHAIN_ALL_BRACKET_TEST = /mstrmojo\.all\[/m,
        reCHAIN_ALL_DOT = /mstrmojo\.all\.([\w]+)\.([\w\.\[\]\'\"\-]+)/m,
        reCHAIN_ALL_DOT_TEST = /mstrmojo\.all\./m,
        reCvtIdxs = /\[(\d+)\]/g,
        reCvtSingleQts = /\[\'([\w\-]+)\'\]/g,
        reCvtDblQts = /\[\"([\w\-]+)\"\]/g,
        reTruncBrkts = /([\[\]].*)/;

    /**
     * @class
     */
    mstrmojo.Binding = mstrmojo.declare(
        null,

        null,

        /**
         * @lends mstrmojo.Binding.prototype
         */
        {
            scriptClass: "mstrmojo.Binding",

            /**
             * Reference to the context object whose property is the destination of this Binding.
             */
            parent: null,

            /**
             * String|Function. Javascript to be evaluated to determine a value for this Binding's destination.
             * The script will be evaluated in the context of the Binding's parent.
             */
            source: null,

            /**
             * String. Name of the property whose value will be determined by this Binding.
             */
            destination: null,

            /**
             * Records whether or not the binding is attached.
             */
            enabled: false,

            /**
             * Optional config for a setter function to set the destination's value. If null, no setter is used; the
             * destination is set directly (e.g., parent[destination] = value). If String, specifies the name of a method
             * of the parent object, which will serve as the setter. If Function, specifies a setter function which will be
             * applied in the parent's context to set the destination.
             */
            setter: "set",

            /**
             * <p>Indicates whether or not this binding is currently updating the bound destination.</p>
             *
             * <p>This flag is set to a positive integer while this binding is executing; otherwise it is zero.
             * The specific number is the total count
             * of calls to this.exec() which are currently executing; this count can be > 1 if the binding is designed to
             * cause its own trigger, either directly or indirectly, in a cyclical manner.</p>
             * @type Integer
             */
            executing: 0,

            init: function init(/*Object?*/ props) {
                // Apply the given properties to this instance.
                mstrmojo.hash.copy(props, this);

                // Then add ourselves to the registry, so we can be called back by events later.
                mstrmojo.registry.add(this);
            },

            destroy: function dest() {
                // Remove any event communication involving this object (faster than calling disable).
                mstrmojo.publisher.clearSubscriptions(this.id);
                // Remove ourselves from registry.
                mstrmojo.registry.remove(this);
            },

            /**
             * Executes the source script and stores the resulting value in the destination.
             */
            exec: function exec() {
                this.executing++;
                // Retrieve the source script as a Function object (cache it for later re-use).
                var fn = this._sourceFn;
                if (!fn) {
                    var s = this.source;
                    if (s != null) {
                        if (typeof(s) == "string") {
                            // TO DO: add a "return " at the beginning of the string if all conditions are met:
                            // [1] it has no "return ", and
                            // [2] if there is a semicolon, it is not followed by any chars except possibly blankspace chars.
                            if (!(s.match("return ")) && !(s.match(/\;\s*\S/))) {
                                s = "return " + s;
                            }
                            fn = new Function(s);
                        } else if (typeof(s) == "function") {
                            fn = s;
                        }
                        this._sourceFn = fn;
                    }
                }

                // If we have a source script Function, call it to calculate a value.
                var v, p = this.parent;
                if (fn) {
                    try {
                        v = fn.apply(p, []);
                    } catch (ex) {
                        // Bad binding script. Result value will be undefined.
                    }
                }

                // Update the destination with the new value.
                var st = this.setter,
                    d = this.destination;
                if (st == null) {
                    p[d] = v;
                } else if (typeof(st) == "string") {
                    p[st](d, v);
                } else if (typeof(st) == "function") {
                    st.apply(p, [d, v]);
                }
                this.executing--;
            },

            /**
             * Starts up the binding by executing the source script, updating the destination's value,
             * and attach event listeners for changes in the source's result value.
             */
            enable: function en() {
                if (!this.enabled) {
                    // Update the destination's value.
                    this.exec();
                    // Parse the source script, if we haven't already.
                    var chs = this._chains;
                    if (!chs) {
                        this._parseChains();
                        chs = this._chains;
                    }
                    // Attach event listeners to expressions within the source script.
                    for (var k in chs) {
                        this._attachChain(chs[k]);
                    }
                    this.enabled = true;
                }
            },

            /**
             * Stops the binding by detaching event listeners for changes in the source's result value.
             */
            disable: function dis() {
                if (this.enabled) {
                    // Detach event listeners, if any.
                    var chs = this._chains;
                    if (chs) {
                        for (var k in chs) {
                            this._detachChain(chs[k]);
                        }
                    }
                    this.enabled = false;
                }
            },

            /**
             * Internal cache of results from parsing the source script.
             */
            _chains: null,

            /**
             * Parses the source script, searching for "chains" of objects that we should attach event listeners to.
             * Examples of a chain:  "this.foo.bar", "mstrmojo.all['foo'].bar.get(..)".
             */
            _parseChains: function () {
                // Init cache.
                this._chains = {};
                var chains = this._chains;

                // Fetch source script as a string.
                var s = this.source;
                if (s && (typeof(s) == "function")) {
                    s = s.toString && s.toString();
                }
                if (!s) {
                    return;
                }

                // Helper method for using regular expression to find matches and storing results in cache.
                function _findMatches(/*String*/ str, /*RegExp*/ re, /*Integer*/ hostIdx, /*Integer*/ partsIdx) {
                    var sTemp = str,
                        match;

                    while (match = sTemp.match(re)) {    // Note: this is an assignment ("=") and null-check, NOT an equals test ("==")
                        // Found a match.
                        var key = match[0],
                            len = key.length,
                            add = true;

                        // Replace "[##]" with ".#", ['XX'] with .XX, ["XX"] with .XX
                        // Then truncate any remaining bracketed substring.
                        key = key.replace(reCvtIdxs, ".$1"
                            ).replace(reCvtSingleQts, ".$1"
                            ).replace(reCvtDblQts, ".$1"
                            ).replace(reTruncBrkts, '');

                        // Is this match redundant?
                        for (var k in chains) {
                            if (k.substr(0, len) === key) {
                                // The match is a subset of a previous match; skip it.
                                add = false;
                                break;
                            } else if (key.indexOf(k) === 0) {
                                // The match is a superset of a previous match; drop the previous match.
                                delete chains[k];
                            }
                        }
                        if (add) {
                            chains[key] = {
                                host: (hostIdx == null) ? null : match[hostIdx],
                                parts: match[partsIdx].replace(reCvtIdxs, ".$1"
                                    ).replace(reCvtSingleQts, ".$1"
                                    ).replace(reCvtDblQts, ".$1"
                                    ).replace(reTruncBrkts, '').split('.')
                            };
                        }
                        sTemp = sTemp.substr(match.index + len);
                    }
                }

                /*
                 We only recognize chains with specific syntax:
                 a) "this.<parts>"
                 where <parts> has only periods and word chars (alphanumerics+underscore). So, not allowed: "(" ,")",":", commas, blanks, etc.
                 Note: We don't check for double-periods ("this.foo..bar"), but of course that will result in a run-time err when exec() is called anyway.
                 Note: We DO allow <parts> to have square brackets ONLY like this "[##]", to support arrays, or like this ['..'] and [".."] to support hyphenated property names.
                 */
                if (reCHAIN_THIS_TEST.test(s)) {
                    _findMatches(s, reCHAIN_THIS, null, 1);
                }

                /*
                 Or in the following syntax:
                 b) "mstrmojo.all['<host>'].<parts>", or
                 c) "mstrmojo.all["<host>"].<parts>"
                 where <host> has only word chars (alphanumerics+underscore).
                 */
                if (reCHAIN_ALL_BRACKET_TEST.test(s)) {
                    _findMatches(s, reCHAIN_ALL_BRACKET, 1, 2);
                }
                /* Or in the following syntax:
                 d) "mstrmojo.all.<host>.<parts>"
                 where <host> has only word chars.
                 */
                if (reCHAIN_ALL_DOT_TEST.test(s)) {
                    _findMatches(s, reCHAIN_ALL_DOT, 1, 2);
                }
            },

            /**
             * Attaches event listeners to the objects along a given "chain".  The "chain" is an object in this._chains
             * hashtable, which was generated by _parseChains. Optional start index can be given; if missing, 0 is assumed.
             */
            _attachChain: function attCh(/*Object*/ ch, /*Integer?*/ start) {

                // Init lookups, if needed.
                if (!ch.evt2idx) {
                    ch.evt2idx = {};
                }
                if (!ch.idx2evt) {
                    ch.idx2evt = [];
                }
                var evt2idx = ch.evt2idx,
                    idx2evt = ch.idx2evt,
                    parts = ch.parts;

                // Init starting index, context and property.
                var idx = (start >= 0) ? start : 0,
                    bId = this.id,
                    reg = mstrmojo.all,
                    ctxt = (start > 0) ?
                        reg[idx2evt[idx - 1].context][parts[idx - 1]] :
                        (ch.host ? reg[ch.host] : this.parent),
                    prop = parts[idx];

                // Walk the chain...
                var A = mstrmojo.array;
                while (ctxt && prop) {
                    if (ctxt.attachEventListener) {
                        // What events should we listen for?
                        var evts = ctxt[prop + "_bindEvents"] || (prop + "Change");
                        if (typeof(evts) == "string") {
                            evts = [evts];
                        }
                        var subs = [];
                        for (var i = 0, iLen = evts.length; i < iLen; i++) {
                            subs[i] = ctxt.attachEventListener(evts[i], bId, "_callback");
                        }

                        // Update the map from event to index.
                        for (var i = 0; i < evts.length; i++) {
                            evt2idx[ ctxt.id + "_" + evts[i] ] = idx;
                        }

                        // Update the map from index to event.
                        idx2evt[idx] = {context: ctxt.id, evts: evts, subs: subs};
                    }
                    // Continue to the next item on the chain...
                    ctxt = ctxt[prop];
                    prop = ch.parts[++idx];
                }
            },

            /**
             * Detaches event listeners from the objects along a given "chain".  The "chain" is an object in this._chains
             * hashtable, which was generated by _parseChains. Optional start index can be given; if missing, 0 is assumed.
             */
            _detachChain: function detCh(/*Object*/ ch, /*Integer?*/ start) {

                var reg = mstrmojo.all,
                    idx2evt = ch.idx2evt,
                    evt2idx = ch.evt2idx,
                    bId = this.id;

                var i = (start > -1) ? start : 0,
                    len = idx2evt.length;
                if (i < len) {
                    for (; i < len; i++) {

                        var atts = idx2evt[i];
                        if (!atts) {
                            break;
                        }
                        var ctxtid = atts.context,
                            ctxt = reg[ctxtid],
                            evts = atts.evts;

                        // Stop listening for events in this outdated context.
                        if (ctxt && ctxt.detachEventListener) {
                            var s = atts.subs;
                            for (var t = 0, tLen = s.length; t < tLen; t++) {
                                ctxt.detachEventListener(s[t]);
                            }
                        }
                        // Update the map from index to event.
                        idx2evt[i] = null;
                        // Update the map from event to index.
                        for (var j = 0, jLen = evts.length; j < jLen; j++) {
                            delete evt2idx[ctxtid + "_" + evts[j]];
                        }
                    }
                }
            },

            /**
             * Notifies the Binding that the destination's value needs to be refreshed.  Also responsible for determining
             * whether or not event listeners need to be detached and re-attached.
             */
            _callback: function clbk(/*Event*/ evt) {

                // Update the destination's value.
                this.exec();

                /*
                 // For debugging only:
                 var n = evt && evt.name,
                 cbs = window.cbs;
                 if (!cbs) cbs = window.cbs = {};

                 if (cbs[n]) {
                 cbs[n]++;
                 } else {
                 cbs[n] = 1;
                 }
                 */

                if (!evt || !evt.name || !evt.src) {
                    return;
                }

                // Do we have any chains that require updating when this event is heard?
                var k = evt.src.id + "_" + evt.name,
                    chains = this._chains;
                // For each chain...
                for (var c in chains) {
                    // Does this event.src+evt.name combination map to an index in this chain?
                    var ch = chains[c],
                        idx = ch.evt2idx[k];
                    if (idx != null) {
                        // Yes, this chain needs to be detached & re-attached.
                        this._detachChain(ch, idx + 1);
                        this._attachChain(ch, idx + 1);
                    }
                }

            }

        }
    );

})();
(function () {
    mstrmojo.requiresCls("mstrmojo.array");

    var ESC = '*',
        D = '.',
        B = '-',
        K = '_',
        L = '<';

    var regEx = new RegExp('[' + '\\' + ESC + '\\' + D + '\\' + B + '\\' + K + '\\' + L + ']', 'g'),
        repText = ESC + '$&';

    /**
     * Static class for serializing data.
     *
     * @class
     * @static
     */
    mstrmojo.Serializer = {
        scriptClass: 'mstrmojo.Serializer',

        /**
         * <p>Returns a String of serialized group values.</p>
         *
         * @param {Array.<Array.<string>>} av A multi-dimensional array of strings to be serialized.
         *
         * @returns {string}
         */
        serializeValueGroup: function serializeValueGroup(av) {
            mstrmojo.array.forEach(av, function (v, i) {
                av[i] = mstrmojo.Serializer.serializeValues(v);
            });
            return B + this.serializeValues(av) + K;
        },

        /**
         * Returns a String of serialized values.
         *
         * @param {Array.<string>} av A single-dimensional array of strings to be serialized.
         *
         * @returns {string}
         */
        serializeValues: function serializeValues(av) {
            var t = [];
            mstrmojo.array.forEach(av, function (v) {
                if (typeof v === 'Boolean') {
                    v = v ? '1' : '0';
                }

                t.push(String(v).replace(regEx, repText));
            });

            return t.join(D);
        }
    };
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.array");

    var DEFAULT_COLOR = "#000000",
        $ROUND = Math.round;


    /**
     * Converts a decimal value to a hexadecimal value (padded to a length of two).
     *
     * @param {number} n The decimal value.
     *
     * @return {String} The hexadecimal value.
     */
    function num2Hex(n) {
        return ("0" + parseInt(n ,10).toString(16)).slice(-2);
    }

    /**
     * A utility class for color conversion.
     *
     * @namespace mstrmojo.color
     */
    mstrmojo.color = mstrmojo.provide(
        "mstrmojo.color",

        /**
         * @lends mstrmojo.color
         */
        {
            /**
             * Converts rgb color string 'rgb(0, 120, 255)' to an int array of red, green and blue.
             *
             * @param {String} color The rgb color string to convert.
             *
             * @return {Array.<int>} An int array of red, green and blue values.
             */
            rgbStr2rgb: function rgbStr2rgb(color) {
                // DE61725: for IE, we may get color as 'transparent' instead of rgba(0,0,0,0)
            	if (color === 'transparent') {
            		return ["0", "0", "0"];
            	} else {
                    return color.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i).slice(1);
            	}
            },

            /**
             * Converts an RGB color string value like 'rgb(0, 120, 255)' to a hexadecimal color string value.
             *
             * @param {String} color The RBG color value.
             *
             * @return {String} The hexadecimal color value.
             */
            rgbStr2hex: function rgbStr2hex(color) {
                //only when color is in rgb(r,g,b) format
                if (color.indexOf('rgb') >= 0) {
                    var rgb = this.rgbStr2rgb(color);
                    return "#" + this.rgb2hex(rgb[0], rgb[1], rgb[2]);
                }
                return color;
            },

            /**
             * Converts the RGB component values to a hexadecimal string.
             *
             * @param {int} r The red value.
             * @param {int} g The blue value.
             * @param {int} b The green value.
             *
             * @returns {String} The hexadecimal string value (without the "#" character).
             */
            rgb2hex: function rgb2hex(r, g, b) {
                return num2Hex(r) + num2Hex(g) + num2Hex(b);
            },

            /**
             * Converts the RGB component values to an array of hue, saturation and brightness.
             *
             * @param {int} r The red value.
             * @param {int} g The blue value.
             * @param {int} b The green value.
             *
             * @returns {Array.<int>}
             */
            rgb2hsv: function rgb2hsv(r, g, b) {
                var min = Math.min(r, g, b),
                    max = Math.max(r, g, b),
                    h = 0,
                    s,
                    v;

                v = max / 255.0;
                s = (max !== 0) ? (parseFloat(max) - parseFloat(min)) / parseFloat(max)
                    : 0;

                if (s === 0) {
                    h = 0;
                } else {
                    var d = max - min,
                        red = (max - r) / d,
                        green = (max - g) / d,
                        blue = (max - b) / d;

                    if (r === max) {
                        h = blue - green;
                    } else if (g === max) {
                        h = 2.0 + red - blue;
                    } else {
                        h = 4.0 + green - red;
                    }

                    h = h / 6.0;
                    if (h < 0) {
                        h = h + 1.0;
                    }
                }

                return [ $ROUND(h * 360), $ROUND(s * 100), $ROUND(v * 100) ];
            },

            /**
             * Converts the RGB component values to an array of hue, saturation and lightness.
             *
             * @param {int} r The red value.
             * @param {int} g The blue value.
             * @param {int} b The green value.
             *
             * @returns {Array.<int>}
             */
            rgb2hsl: function rgb2hsl(r, g, b) {
                // Convert to percentage values.
                r /= 255;
                g /= 255;
                b /= 255;

                // Get minimum and maximum and lightness.
                var max = Math.max(r, g, b),
                    min = Math.min(r, g, b),
                    l = (max + min) / 2,
                    h,
                    s;

                // Are all values the same?
                if (max === min) {
                    // HSL will be achromatic.
                    h = s = 0;

                } else {
                    // Get difference between max and min.
                    var delta = max - min;

                    // Calculate saturation.
                    s = l > 0.5 ? delta / (2 - max - min) : delta / (max + min);

                    switch (max) {
                    case r:
                        h = (g - b) / delta + (g < b ? 6 : 0);
                        break;

                    case g:
                        h = (b - r) / delta + 2;
                        break;

                    case b:
                        h = (r - g) / delta + 4;
                        break;
                    }

                    h /= 6;
                }

                return [ h, s, l ];
            },

            /**
             * Converts the HSL component values to an array of red, blue and green.
             *
             * @param {number} h The hue value.
             * @param {number} s The saturation value.
             * @param {number} l The lightness value.
             *
             * @returns {Array.<int>}
             */
            hsl2rgb: function hsl2rgb(h, s, l) {
                var fnHue2Rgb = function fnHue2Rgb(p, q, t) {
                        if (t < 0) {
                            t += 1;
                        }

                        if (t > 1) {
                            t -= 1;
                        }

                        if (t < 1 / 6) {
                            return p + (q - p) * 6 * t;
                        }

                        if (t < 1 / 2) {
                            return q;
                        }

                        if (t < 2 / 3) {
                            return p + (q - p) * (2 / 3 - t) * 6;
                        }

                        return p;
                    },
                    r,
                    g,
                    b;

                // Is saturation zero?
                if (s === 0) {
                    // Achromatic.
                    r = g = b = l;

                } else {
                    var q = l < 0.5 ? l * (1 + s) : l + s - l * s,
                        p = 2 * l - q;

                    r = fnHue2Rgb(p, q, h + 1 / 3);
                    g = fnHue2Rgb(p, q, h);
                    b = fnHue2Rgb(p, q, h - 1 / 3);
                }

                return [ $ROUND(r * 255), $ROUND(g * 255), $ROUND(b * 255) ];
            },

            /**
             * Converts the HSL component values to a HEX color string value.
             *
             * @param {number} h The hue value.
             * @param {number} s The saturation value.
             * @param {number} l The lightness value.
             *
             * @returns {String}
             */
            hsl2hex: function hsl2hex(h, s, l) {
                return '#' + mstrmojo.array.map(this.hsl2rgb(h, s, l), function (n) {
                    return num2Hex(n);
                }).join('');
            },

            /**
             * Converts a hexadecimal string color value to an array of RGB values.
             *
             * @param {String} s The hexadecimal color value.
             *
             * @returns {Array.<int>}
             */
            hex2rgb: function hex2rgb(s) {
                // Make sure the color is the full 7 string
                var color = this.fixFullHexValue('#' + s.replace('#', '')),
                    rgb = [],
                    i;

                // Remove hash.
                color = color.replace('#', '');

                // Pull out components.
                for (i = 0; i < 3; i++) {
                    rgb.push(parseInt(color.substr(i * 2, 2), 16));
                }

                return rgb;
            },

            /**
             * Converts a hexadecimal string color value to an array of BGR values.
             *
             * @param {String} s The hexadecimal color value.
             *
             * @returns {Array.<int>}
             */
            hex2bgr: function hex2bgr(s) {
                return this.hex2rgb(s).reverse();
            },

            /**
             * Converts a hexadecimal string color value to an array of HSV values.
             *
             * @param {String} s The hexadecimal color value.
             *
             * @returns {Array.<int>}
             */
            hex2hsv: function hex2hsv(s) {
                var rgb = this.hex2rgb(s);
                return this.rgb2hsv(rgb[0], rgb[1], rgb[2]);
            },

            /**
             * Converts a hexadecimal string color value to an array of HSL values.
             *
             * @param {String} color The hexadecimal color value.
             *
             * @returns {Array.<int>}
             */
            hex2hsl: function hex2hsl(color) {
                return this.rgb2hsl.apply(this, this.hex2rgb(color));
            },

            /**
             * Converts hue, saturation and lightness color values to an array of RGB values.
             *
             * @param {int} h The hue value.
             * @param {int} s The saturation value.
             * @param {int} v The lightness value.
             *
             * @returns {Array.<int>} The RBG values.
             */
            hsv2rgb: function hsv2rgb(h, s, v) {
                h = h / 360;
                s = s / 100;
                v = v / 100;

                var r, g, b;
                if (s === 0) {
                    r = v * 255;
                    g = v * 255;
                    b = v * 255;
                } else {
                    var th = h * 6;
                    if (th === 6) {
                        th = 0;
                    }

                    var i = Math.floor(th);
                    var p = v * (1 - s);
                    var q = v * (1 - s * (th - i));
                    var t = v * (1 - s * (1 - (th - i)));

                    var tr, tg, tb;

                    switch (i) {
                    case 0:
                        tr = v;
                        tg = t;
                        tb = p;
                        break;

                    case 1:
                        tr = q;
                        tg = v;
                        tb = p;
                        break;

                    case 2:
                        tr = p;
                        tg = v;
                        tb = t;
                        break;

                    case 3:
                        tr = p;
                        tg = q;
                        tb = v;
                        break;

                    case 4:
                        tr = t;
                        tg = p;
                        tb = v;
                        break;

                    default:
                        tr = v;
                        tg = p;
                        tb = q;
                        break;
                    }

                    r = tr * 255;
                    g = tg * 255;
                    b = tb * 255;
                }
                return [ $ROUND(r), $ROUND(g), $ROUND(b) ];

            },

            /**
             * Converts hue, saturation and lightness color values to an array of RGB values.
             *
             * @param {int} h The hue value.
             * @param {int} s The saturation value.
             * @param {int} v The lightness value.
             *
             * @returns {String} The hexadecimal string value (without the "#" character).
             */
            hsv2hex: function hsv2hex(h, s, v) {
                var rgb = this.hsv2rgb(h, s, v);
                return this.rgb2hex(rgb[0], rgb[1], rgb[2]);
            },

            /**
             * Chooses the most appropriate contrasting color from the supplied colors array.
             *
             * @param {String} hex The hexadecimal color value to contrast with.
             * @param {String} lightColor The value used to contrast with a dark color.
             * @param {String} darkColor The value used to contrast with a light color.
             *
             * @returns {String} The contrasting color.
             */
            getContrastingColor: function getContrastingColor(hex, lightColor, darkColor) {
                var rgb = this.hex2rgb(hex);
                return (((rgb[0] * 299) + (rgb[1] * 587) + (rgb[2] * 114)) / 1000 < 125) ? lightColor : darkColor;
            },

            /**
             * Get the luminance(brightness) value (0-255)from a given hex color
             * The formula to calculate the luminance, please refer to
             * https://en.wikipedia.org/wiki/Relative_luminance
             *
             * @param {String} hex The hexadecimal color value.
             *
             * @returns {Number} The luminance value.
             */
            getLuminance: function getLuminance(hex) {
                var rgb = this.hex2rgb(hex);
                return 0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2];
            },

            /**
             *
             * @param {Array.<int>} rgb An array of RGB color values.
             * @param {boolean} moreDim
             *
             * @returns {String} The hexadecimal value (including the "#" character).
             */
            getHighlightColor: function getHighlightColor(rgb, moreDim) {
                var r, g, b, luminosity,
                    refRGB = this.hex2rgb(!moreDim ? '#FFCE7F' : '#EFE6D8'),
                    R1 = parseInt(rgb[0], 10),
                    G1 = parseInt(rgb[1], 10),
                    B1 = parseInt(rgb[2], 10),
                    R2 = parseInt(refRGB[0], 10),
                    G2 = parseInt(refRGB[1], 10),
                    B2 = parseInt(refRGB[2], 10);

                r = (R1 * R2) / 255;
                g = (G1 * G2) / 255;
                b = (B1 * B2) / 255;

                luminosity = R1 * 0.3 + G1 * 0.59 + B1 * 0.11;
                if (luminosity < 85) {
                    r = r + (63 * (85 - luminosity) / 85);
                    r = r > 255 ? 255 : r;
                    g = g + (63 * (85 - luminosity) / 85);
                    g = g > 255 ? 255 : g;
                    b = b + (63 * (85 - luminosity) / 85);
                    b = b > 255 ? 255 : b;
                }

                return "#" + this.rgb2hex($ROUND(r), $ROUND(g), $ROUND(b));
            },

            /**
             * Calculates the light color component for 3d borders.
             *
             * @param {Array.<int>} bgRGB An array of rgb component colors.
             * @param {String} stroke Either 'light' or 'dark'.
             *
             * @return {String} The hexadecimal value for the light color component.
             */
            get3DBorderColor: function get3DBorderColor(bgRGB, stroke) {
                var lum = parseInt(bgRGB[0], 10) * 0.3 + parseInt(bgRGB[1], 10) * 0.59 + parseInt(bgRGB[2], 10) * 0.11;

                var r = parseInt(bgRGB[0], 10);
                var g = parseInt(bgRGB[1], 10);
                var b = parseInt(bgRGB[2], 10);

                switch (stroke) {
                case 'light': //light border color
                    if (lum > 150) {
                        r = r * 0.9;
                        g = g * 0.9;
                        b = b * 0.9;
                    } else {
                        r = r * 0.6 + 102;
                        g = g * 0.6 + 102;
                        b = b * 0.6 + 102;
                    }
                    break;
                case 'dark': //dark border color
                    if (lum > 10) {
                        r = r * 0.4;
                        g = g * 0.4;
                        b = b * 0.4;
                    } else {
                        r = r * 0.8 + 30;
                        g = g * 0.8 + 30;
                        b = b * 0.8 + 30;
                    }
                    break;
                }

                return "#" + this.rgb2hex($ROUND(r), $ROUND(g), $ROUND(b));
            },

            /**
             * <p>Convert Hex color into Decimal.</p>
             *
             * @param {String} v The Hex color
             * @param {String=} d
             */
            encodeColor: function encodeColor(v, d) {
                if (d !== undefined && (v === null || v.length === 0 || v === 'undefined')) {
                    v = d;
                }

                if (v === 'transparent') {
                    return -1;
                }

                if (parseInt(v, 10) === -2) {
                    return -2;
                }

                //remove prefix
                if (v.substring(0, 1) === '#') {
                    v = v.substring(1);
                }

                //switch RR with BB and get the decimal value
                return parseInt(v.substring(4) + v.substring(2, 4) + v.substring(0, 2), 16);
            },

            /**
             * <p>Convert decimal color into hexadecimal.</p>
             *
             * <pre>
             *   Here is the spec for color in CSS2
             *      EM { color: #f00 }              // #rgb
             *      EM { color: #ff0000 }           // #rrggbb
             *      EM { color: rgb(255,0,0) }      // integer range 0 - 255
             *      EM { color: rgb(100%, 0%, 0%) } // float range 0.0% - 100.0%
             *
             *   So we have this function to transform the color to #rrggbb style.
             *   current assumption is backend will give me a hexadecimal representation of the color
             *   in VB color in BBGGRR format in hexadecimal, and the value we get from backend is in decimal,
             *   so this function will convert decimal VB color to CSS2 color.
             *   anything wrong in converting, return black color "000000".
             * </pre>
             *
             * @param {int} color VB style color value in decimal.
             * @return {String} RGB color
             */
            decodeColor: function decodeColor(color) {
                color = parseInt(color, 10);

                if (color === 0) {
                    return DEFAULT_COLOR;
                }

                //get rgb color in decimal
                var rgb = 0x1000000 + (color & 0xff) * 0x10000 + (color & 0xff00) + (color & 0xff0000) / 0x10000;

                //convert to Hex string
                return '#' + rgb.toString(16).substring(1).toUpperCase();
            },

            /**
             * Converts shorthand color values to the full 7 digits.
             *
             * @param {String} color The hex color value.
             *
             * @returns {String}
             */
            fixFullHexValue: function fixFullHexValue(color) {
                // Is this a shorthand color?
                if (color && color.length === 4) {
                    // Return inflated value.
                    return color.replace(/([0-9a-f])/ig, '$1$1');
                }

                // Return original value.
                return color;
            },

            /**
             * Returns the mid color between two given hex colors.
             *
             * @param {String} hexColorStart The starting color in hex
             * @param {String} hexColorEnd The ending color in hex
             *
             * @return {String} The mid hex color between the two given colors with the "#" sign.
             */
            findMidColorHex: function findMidColorHex(hexColorStart, hexColorEnd) {
                var start = this.hex2rgb(hexColorStart),
                    end = this.hex2rgb(hexColorEnd),
                    mid = [];

                // Loop through all the RGB values and find the mid point.
                start.forEach(function (startValue, i) {
                    mid.push(parseInt((startValue + end[i]) / 2, 10));
                });

                // Return the final hex color with the "#" sign.
                return ("#" + this.rgb2hex(mid[0], mid[1], mid[2]));
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.dom");

	mstrmojo.fx = {enabled: true};
	
	var $DOM = mstrmojo.dom;	

	/**
	 * _Effect is an abstract base class for all visual effects.  It implements the machinery for a generic effect,
	 * but omits the "exec()" method which actually applies a change to the GUI.  That method is expected to be implemented
	 * by subclasses of _Effect.
     *
     * @class
	 */
	mstrmojo.fx._Effect = mstrmojo.declare(
        null,

        null,

        /**
         * @lends mstrmojo.fx._Effect.prototype
         */
		{
			scriptClass: "mstrmojo.fx._Effect",
			
			/**
             * Length (in milliseconds) of the entire effect.
			 */
			duration: 500,
			
			/**
             * Length (in milliseconds) of pause in between steps of this effect's animation.
			 */
			interval: 50,
			
			/**
             * Optional delay (in milliseconds) before effect is started once play() is called.
			 */
			delay: null,
			
			/**
			 * The object to which this effect is applied.
			 */
			target: null,
			
			/**
			 * Optional getter function for "target" property.  If specified, called at start-time (before "preStart").
			 */
			getTarget: null,
			
			/**
			 * Optional handle to the widget whose DOM will be targeted. An alternative to using "target" or "getTarget".
			 * If those 2 properties are omitted and "widget" is provided, the target will be set to a slot in the widget.
			 */
			widget: null,
			
			/**
			 * If "widget" is provided, the name of the widget's slot which will be targeted ("domNode" by default).
			 */
			slot: null,
			
			/**
			 * Optional handler, called before effect is started. For customization.
			 */
			preStart: null,

			/**
			 * Optional handler, called before effect is started. For customization.
			 */
			postStart: null,

			/**
			 * Optional handler, called before effect is started. For customization.
			 */
			onCancel: null,

			/**
			 * Optional handler, called after effect is successfully completed. For customization.
			 */
			onEnd: null,

			/**
			 * If true and the effect is cancelled while playing, the start value of the effect
			 * will be reapplied to the target.
			 */
			revertOnCancel: true,
			
			/**
			 * This boolean gets set to true when play() is called, and to false when
			 * either pause() or cancel() are called, or when the animation's steps are completed.
			 */
			isPlaying: false,
			
			/**
			 * This boolean gets set to true after both (1) play() is called and (2) the start delay
			 * (if any) is over. Gets reset to false after effect ends or is cancelled.
			 */
			started: false,
			
			/**
             * @inheritDoc
			 */
            init: function init(props) {
				mstrmojo.hash.copy(props, this);
			},
									
			/**
			 * Plays this effect, beginning with the effect's delay (if any).
			 */
			play: function ply() {
				this.isPlaying = true;
				this.started = false;
				if (this.delay) {
					var me = this;
					this.delayTimer = window.setTimeout(
                        function () {
							me._start();
							me = null;
						},  
						this.delay
					);
				} else {
					this._start();
				}
			},
			/**
			 * Prevents the effect from continuing to play any further.
			 */
			pause: function pause() {
				if (this.delayTimer) {
					window.clearTimeout(this.delayTimer);
					delete this.delayTimer;
				}
				if (this.timer) {
					window.clearInterval(this.timer);
					delete this.timer;
				}
				this.isPlaying = false;
			},

			/**
			 * Prevents the effect from continuing to play, optionally re-applies the start value, and
			 * fires the onCancel callback, if any.
			 */
			cancel: function cnl() {
				this.pause();
				if (this.started) {
					if (this.revertOnCancel) {
						this.counter = 0;
						this.exec();
					}
					if (this.onCancel) {
						this.onCancel();
					}
					this.started = false;
				}
			},
						
			/**
			 * Kicks off the application of this effect, possibly after a delay.
			 */
			_start: function start() {
				this.started = true;

				// Call the target getter method, if given.
				this._doTarget();

				// Calculate the # of animation steps required.
				// If duration = 0, do animation in 1 step.
                this.steps = Math.max(Math.ceil(this.duration / this.interval), 1);
				
				// Validate the ease property; could be a Function or String.
				var ea = this.ease;
                if (typeof ea  === "string") {
					this.ease = mstrmojo.registry.ref(ea);
				}
				
				// Call any pre-start method from the animation's config.
                if (this._doPreStart() === false) {
				    this.started = false;
				    this.isPlaying = false;
				    return;
				}

				// Start the animation immediately.
				this.counter = 0;
				this.exec();
				this.counter++;

				// Call postStart, if any.
				this._doPostStart();
				
				// Do any steps remain?
				if (this.counter >= this.steps) {
					// No, cleanup.
					this._end();
				} else {
					// Yes, continue animation in a repeating interval.
					var me = this;
					if (this.timer) {
						window.clearInterval(this.timer);
					}
                    this.timer = window.setInterval(function fxIntvl() {
							    if (me) {
							        me.exec();
							        me.counter++;
							        if (me.counter >= me.steps) {
							            me._end();
							            me = null;
							        }
							    }
                    }, this.interval);
				}
			},

			/**
			 * The method which applies a single step of a given effect.  Intentionally omitted for this
			 * abstract base class; expected to be implemented by subclasses.
			 */			
			exec: null,
			
			/**
			 * Called internally for cleanup after an animation executes all of its steps.
			 */
            _end: function end() {
				// Clear the interval.
				this.pause();
				this.started = false;
				if (this.onEnd) {
					this.onEnd();
				}
			},

            _doTarget: function tgt() {
                // Do we have a target getter?
                if (this.getTarget) {
                    // Assume the getter will return a DOM node.
                    this.target = this.getTarget();
                } else if (this.widget) {
                    // If we have a widget, target the widget's given slot ("domNode", by default).
                    // Refresh this every time we start, because the slot pointer may have changed (e.g., after a re-render).
                    this.target = this.widget[this.slot || "domNode"];
                } else if (this.target) {
                    // If we do have a target, check if its a widget or DOM node.
                    var t = this.target;
                    if (t && this.slot && t.scriptClass) {
                        var node = t[this.slot];
                        if (node) {
                            this.widget = t;
                            this.target = node;
                        }
                    }
                }
				// Finally, if we don't have a target, just assume it is the domNode of our widget ancestor.
				// Typically, that would be our parent. However, if this effect is used as a child of a Parallel effect,
				// then our parent would be the Parallel effect.  So we want to walk our ancestors until we reach an
				// ancestor with a domNode.
				if (!this.target) {
					var w = this;
					while (w = w.parent) {	// Note: this is an assignment ("="), not a comparison ("==")!
                        if (!w || w.domNode) {
						  break;
                        }
					}
					if (w) {
						this.widget = w;
						this.target = w[this.slot || "domNode"];
					}
				}
			},

            _doPreStart: function pre() {
				if (this.preStart) {
					 return this.preStart();
				}
			},
            _doPostStart: function post() {
				if (this.postStart) {
					this.postStart();
				}
			}			
		}
	);		

	/**
	 * Utility function used by mstrmojo.fx.Parallel to call methods in all of its children.
	 */
	function _callChildren(me, fName) {
        var arr = me.children,
            len = (arr && arr.length) || 0,
            i;

        for (i = 0; i < len; i++) {
			arr[i][fName]();
		}
	}
	
	/**
	 * Parallel is essentially a list ("children") of effects which are all played simultaneously when Parallel is played.
	 * Each "child" effect supports its own individual properties, such as "duration", "delay", "preStart", "onEnd", etc.  
	 * Note that "duration" of the Parallel itself is ignored.
	 * Additionally, the Parallel itself supports a "delay" which is applied before any of the children are played.
     *
     * @class
     * @extends mstrmojo.fn._Effect
	 */
	mstrmojo.fx.Parallel = mstrmojo.declare(
        mstrmojo.fx._Effect,

        null,

        /**
         * @lends mstrmojo.fx.Parallel.prototype
         */
		{
			scriptClass: "mstrmojo.fx.Parallel",
			
            init: function init(props) {
				this._super(props);
				// Inspect our children.  If they are native javascript Objects, try replacing them
				// with newly instantiated javascript classes.
				var ch = this.children;
				mstrmojo.registry.refArray(ch);
				// Set the children's parent pointer.
                var len = (ch && ch.length) || 0,
                    i;

                for (i = 0; i < len; i++) {
					ch[i].parent = this;
				}
			},
			
			/**
			 * Fires the preStart callback if any, triggers the playing of all the effects in its "children" 
			 * array, and then fires the postStart callback if any.  
			 */
			_start: function start() {
				this.started = true;

				if (this.preStart) {
					this.preStart();
				}

				_callChildren(this, "play");
				
				if (this.postStart) {
					this.postStart();
				}
			},

			/**
			 * Triggers the pause of all the effects in its "children" array.
			 */
			pause: function pause() {
				_callChildren(this, "pause");
			},

			/**
			 * Triggers the cancel of all the effects in its "children" array.
			 */
			cancel: function cnl() {
				_callChildren(this, "cancel");
			}
		}
	);
	
    /**
     * Animates a given property of a given target DOM Node.
     *
     * @class
     * @extends mstrmojo.fx._Effect
     */
    mstrmojo.fx.AnimateProp = mstrmojo.declare(
        mstrmojo.fx._Effect,

        null,

        /**
         * @lends mstrmojo.fs.AnimateProp.prototype
         */
		{
			scriptClass: "mstrmojo.fx.AnimateProp",
			
			/**
			 * Hashtable of style properties animated by this effect.
			 * Keyed by name of the property; value is an object with the following
			 * properties: {start: .., stop: .., suffix: .., ease: ..}.
			 */
			props: null,

			/**
			 * Extends the inherited method in order to validate "ease" property of each
			 * individual property to be animated.
			 */
			_start: function st() {
				// Validate the ease function for each given property. Could be a String that
				// needs to be eval'd into a function.  Do this before calling the inherited method,
				// because that method will perform the first animation step, which will need the ease function.
                var ps = this.props,
                    n;

                for (n in ps) {
					var p = ps[n],
						ea = p.ease;
                    if (typeof ea  === "string") {
					    p.ease = mstrmojo.registry.ref(ea, {dontInst: true});
					}
				}
				// Call the inherited method to truly start the animation.
				this._super();

			},
									
			exec: function exec() {
                var ps = this.props,
                    n;

                for (n in ps) {
                    var p = ps[n],
                        v = (p.ease || mstrmojo.ease.sin)(this.counter, p.start, p.stop - p.start, this.steps - 1);
                    if (p.fn) {
					    v = p.fn(v);
					}
                    if (p.suffix) {
					   v += p.suffix;
                    }
                    var o = p.isStyle === false ? this.target : this.target.style;
                    o[n] = v;
				}
			}
		}
	);
	
    /**
     * @class
     * @extends mstrmojo.fx._Effect
     */
	mstrmojo.fx.Typewriter = mstrmojo.declare(
        mstrmojo.fx._Effect,

        null,

        /**
         * @lends mstrmojo.fn.Typewriter.prototype
         */
		{
			scriptClass: "mstrmojo.fx.Typewriter",
			
			charGroupSize: 1,
			
			/**
			 * This property is used to set the effect's "stop" value if none is provided.
			 * The srcProp is the name of the targeted widget's property from which to read the typewriter text.
			 */
			srcProp: "text",
			
			/**
			 * Extends the inherited method in order to do some additional initialization, and to
			 * support the targetField property.
			 */
			_doPreStart: function () {
				// First call the inherited method to do standard setup.
				this._super();
				
				// Now validate the "stop" property. 
				this._dynStop = false;
				// If it's null, try setting it with the help of the srcProp.
				if (this.stop == null) {    // if null or undefined
					var sp = this.srcProp,
                        st;
					if (sp) {
						var w = this.widget || this.parent;
						st = w && w[sp];
						if ((st != null) && (typeof(st) !== 'string')) {  // if not null and not undefined
							st = String(st);
						}
					}
					this.stop = st;
					this._dynStop = true;
				}
				// If it's still null, use empty string.
				if (this.stop == null) {
					this.stop = "";
				}

				// Prepare the target's innerHTML.				
				var t = this.target,
					ttn = null,
					cgs = 1;

				if (t) {
					t.innerHTML = '';
					ttn = document.createTextNode('');
					t.appendChild(ttn);
                    cgs = Math.max(Math.floor(this.stop.length / this.steps), 1);
				}
				this.targetTextNode = ttn;
				this.charGroupSize = cgs;
			},
			
            exec: function () {
				var ttn = this.targetTextNode;
				if (!ttn) {
				    return;
			    }
				
				var v;
                if (this.counter >= this.steps - 1) {
					v = this.stop;
				} else if (this.counter === 0) {
					v = '';
				} else {
					v = this.stop.substring(0, this.charGroupSize * this.counter) + '_';
				}
				ttn.nodeValue = v;
			},
			
			_end: function end() {
				this._super();
				if (this._dynStop) {
					this.stop = null;
					delete this._dynStop;
				}
			},
			
			cancel: function cnl() {
				if (this._dynStop) {
					this.stop = null;
					delete this._dynStop;
				}
			}
		}
	);
	
	mstrmojo.requiresCls("mstrmojo.dom");
		
	/**
	 * Animates the opacity of a DOM node.  The target may be specified as either a sDOM node
     *
     * @class
     * @extends mstrmojo.fx._Effect
	 */
	mstrmojo.fx.Fade = mstrmojo.declare(
        mstrmojo.fx._Effect,

        null,

        /**
         * @lends mstrmojo.fx.Fade.prototype
         */
		{
			scriptClass: "mstrmojo.fx.Fade",
			
			/**
			 * "start" and "stop" define a range of values over which this effect will be applied.
			 */
			start: null,
			stop: null,
			
			/**
			 * Optional easing function used to compute in-between values for animation.
			 */
			ease: null,

			/**
			 * Optional suffix to be appended to property values applied by this effect.
			 */
			suffix: null,

			exec: function exec(v) {
				if (v == null) {    // if null or undefined
                    v = (this.ease || mstrmojo.ease.sin)(this.counter, this.start, this.stop - this.start, this.steps - 1);
				}
				if ($DOM.isIE && !$DOM.isWinPhone) {
					// TO DO: implement opacity via filter
                    this.target.style.filter = 'alpha(opacity=' + parseInt(v * 100, 10) + ')';
					
				} else {
					this.target.style.opacity = v;
				}
			}
		}
	);
	
	/**
	 * A subclass of Fade which fades opacity from 1 to 0, and (optionally) then sets the style.display of target.
     *
     * @class
     * @extends mstrmojo.fx.Fade
	 */
	mstrmojo.fx.FadeOut = mstrmojo.declare(
        mstrmojo.fx.Fade,

        null,

        /**
         * @lends mstrmojo.fx.FadeOut.prototype
         */
		{
			scriptClass: "mstrmojo.fx.FadeOut",
			
			start: 1,
			stop: 0,
			revertOnCancel: true,
			
			/**
			 * If not null, when the animation is completed the target's style.display will be set to "hidden";
			 * when it is cancelled, if revertOnCancel is true the target's style.display will be set to the cssDisplay value.
			 */
			cssDisplay: 'block',
			
			/**
			 * Extends the inherited method in order to implement the "cssDisplay" feature.
			 */
            _end: function end() {
				if (this.cssDisplay) {
					this.target.style.display = 'none';
					this.exec(this.start);
				}
				this._super();
			},
			
			/**
			 * Extends the inherited method in order to implement the "cssDisplay" feature.
			 */
			cancel: function cnl() {
				if (this.started && this.cssDisplay) {
					this.target.style.display = this.cssDisplay;
				}
				this._super();
			}
		}
	);

	/**
	 * A subclass of Fade which fades opacity from 1 to 0, and (optionally) then sets the style.display of target.
     *
     * @class
     * @extends mstrmojo.fx.Fade
	 */
	mstrmojo.fx.FadeIn = mstrmojo.declare(
        mstrmojo.fx.Fade,

        null,

        /**
         * @lends mstrmojo.fx.FadeIn.prototype
         */
		{
			scriptClass: "mstrmojo.fx.FadeIn",
			
			start: 0,
			stop: 1,
			revertOnCancel: true,
			
			/**
			 * If not null, when the animation is completed the target's style.display will be set to "hidden";
			 * when it is cancelled, if revertOnCancel is true the target's style.display will be set to the cssDisplay value.
			 */
			cssDisplay: 'block',
			
			/**
			 * Extends the inherited method in order to implement the "cssDisplay" feature.
			 */
            _doPostStart: function postS() {
				if (this.cssDisplay) {
					this.target.style.display = this.cssDisplay;
				}
				this._super();
			},
			
			/**
			 * Extends the inherited method in order to implement the "cssDisplay" feature.
			 */
            cancel: function () {
				if (this.started && this.revertOnCancel && this.cssDisplay) {
					this.target.style.display = 'none';
				}
				this._super();
			}
		}
	);

	function fraction(num, dem, digits) {
		var x = Math.pow(10, digits || 2);
		if (dem) {
			return parseInt(x * num / dem, 10) / x;
        }

        return parseInt(x * num, 10) / x;
	}
	
	/**
	 * Collection of easing functions, ready to be used with mstrmojo.fx effects.
     *
     * @namespace mstrmojo.ease
	 */
	mstrmojo.ease = {
		linear: function ln(t, b, c, d) {
            if (t === d) {
                return b + c;
            }

            if (t === 0) {
				return b;
            }
				return b + c * fraction(t, d);
		},
		
		sin: function sin(t, b, c, d) {
			return b + c * Math.sin((Math.PI / 2) * t / d);
		},
		
		cos: function cos(t, b, c, d) {
			return b + c * Math.cos((Math.PI / 2) * (1 - t / d));
		},
		
		sincos: function sincos(t, b, c, d) {
			if (t > d / 2) {
				return b + c * Math.cos((Math.PI / 2) * (1 - t / d));
            }

            return b + c * Math.sin((Math.PI / 2) * t / d);
		},
		
		cossin: function cossin(t, b, c, d) {
			if (t > d / 2) {
				return b + c * Math.sin((Math.PI / 2) * t / d);
            }

            return b + c * Math.cos((Math.PI / 2) * (1 - t / d));
		},
		
		bounce: function bounce(t, b, c, d) {
			if ((t /= d) < (1 / 2.75)) {
			      return c * (7.5625 * t * t) + b;
			}

            if (t < (2 / 2.75)) {
                return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;
            }

            if (t < (2.5 / 2.75)) {
                return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;
            }

            return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;
		},
		
		shake: function shake(t, b, c, d) {
            if (t < d / 2) {
                return b + c * fraction(Math.sin(2 * Math.PI * t / 8), null, 2) * 2 * t / d;
            }
            return b + c * fraction(Math.sin(2 * Math.PI * t / 8), null, 2) * 2 * (1 - t / d);
//				return b + c * fraction(Math.sin(6 * Math.PI * t/d), null, 2) * 2 *(1-t/d);
			}
	};
}());

(function () {
    mstrmojo.requiresCls("mstrmojo.registry",
                         "mstrmojo.array",
                         "mstrmojo.publisher");

    var $REG = mstrmojo.registry,
        $ARR = mstrmojo.array,
        $PUB = mstrmojo.publisher;

    /**
     * <p>Pre-processing for a new child. Converts a given JSON object into a script class instance,
     * and sets its parent.</p>
     *
     * @param {mstrmojo.Container} p The parent to which a child is about to be added.
     * @param {mstrmojo.Widget|{}} c The child which is about to be added.
     *
     * @private
     */
    function preAddChild(p, c) {
        if (c) {
            c.parent = p;
            var inst = $REG.ref(c);
            if ( c !== inst ) {
                delete c.parent;
            }
            return inst;
        }
        return null;
    }

    /**
     * <p>Post processing for a new child. Sets an alias reference on the parent to the child.</p>
     *
     * @param {mstrmojo.Container} p The parent to which a child has been added.
     * @param {mstrmojo.Widget|{}} c The child which has been added.
     *
     * @private
     */
    function postAddChild(p, c) {
        var alias = c.alias;
        if (alias !== null && alias !== '') {
            p[alias] = c;
        }
    }

    /**
     * <p>Post processing for a newly removed child. Clears the alias reference on the parent and
     * the parent reference on the child.</p>
     *
     * @param {mstrmojo.Container} p The parent to which a child has been added.
     * @param {mstrmojo.Widget|{}} c The child which has been added.
     *
     * @private
     */
    function postRemoveChild(p, c) {
        var alias = c.alias;
        if (c.parent === p) {
            delete c.parent;
        }
        if ((alias !== null && alias !== '') && (p[alias] === c)) {
            delete p[alias];
        }
    }

    /**
     * <p>Converts an array of child references to a new array of child objects.</p>
     *
     * <p>Each array member that is a child reference will be replaced by the evaluation of that reference; the evaluation
     * is done via the mstrmojo.registry.ref method. If the evaluation results in null, the array member is removed.
     * Each array member that is already a child object will remain intact.</p>
     *
     * <p>Each array member will have its parent set, and the parent will have alias references set to the children
     * (for each child that specifies an alias).</p>
     *
     * @param {mstrmojo.Container} p The parent to which children will be added.
     * @param {Object[]} refs An array of either child references or child objects.
     *
     * @returns {Object[]} An array of child objects, if successful; otherwise, an empty array or null.
     *
     * @private
     */
    function makeCh(p, refs) {
        var len = refs && refs.length,
            ch,
            i;

        if (len) {
            ch = [];
            for (i = 0; i < len; i++) {
                var c = preAddChild(p, refs[i]);
                if (!c) {
                    continue;
                }
                ch.push(c);
                postAddChild(p, c);
            }
        }
        return ch;
    }

    /**
     * <p>A mixin that equips an observable object with methods for managing an array of children.</p>
     *
     * <p> The children list is maintained in a "children" property (type: Array of Objects). Additions and removals
     * of children in the list raise events that can be handled by this or other objects.</p>
     *
     * @mixin
     * @public
     */
    mstrmojo._HasChildren = mstrmojo.provide(

        "mstrmojo._HasChildren",

        /**
         * @lends mstrmojo._HasChildren#
         */
        {
            /**
             * @ignore
             */
            _meta_usesSuper: false,

            /**
             * Array of child objects contained by this object.
             *
             * @type {mstrmojo.Widget[]}
             */
            children: null,

            /**
             * <p>Optional handler called after initialization of children.</p>
             *
             * <p>This handler is supported as a customization hook during the initialization process.
             * If specified, the handler will be called after the instance's initial children have been created.
             * If the instance has no initial children, the handler is not called.</p>
             *
             * @type {Function}
             */
            postCreateChildren: mstrmojo.emptyFn,

            /**
             * <p>Optional handler called after children are added.</p>
             *
             * @type {Function}
             */
            onaddChild: null,

            /**
             * <p>Optional handler called after children are removed.</p>
             *
             * @type {Function}
             */
            onremoveChild: null,

            /**
             * <p>Constructs child objects from this object's "children" property value.</p>
             * <p>This method is intended to be used during initialization and therefore operates silently;
             * meaning it does not raise "addChild" events for the initial set of children.</p>
             */
            initChildren: function initChildren() {
                var propertyName = "children",
                    children = this[propertyName];

                // Are there no children?
                if (!children) {
                    // Nothing to do.
                    return;
                }

                // Clear children (MUST use null, since delete won't work when children is defined on prototype) and call custom property setter.
                this[propertyName] = null;
                this._set_children(propertyName, children, true);

                // Hook for customizations.
                this.postCreateChildren();
            },

            /**
             * <p>Custom setter for the "children" property value.</p>
             *
             * <p>This method will add a given array of children to this object's
             * "children" property. Any children previously in the "children" property
             * are removed first.</p>
             *
             * @param {string} [n=children] The property whose value is being set.
             * @param {Array.<Object>=} v An array of either child objects or references to child objects. If
             *                      references are specified, they are resolved to actual child objects using the {@link mstrmojo.registry.ref} method.
             * @param {boolean} [silent=false] If true, suppresses raising of event.
             *
             * @returns {boolean} false to avoid raising a "childrenChange" event when called from {@link mstrmojo.Obj.set}.
             *                          Instead, calling this method should raise "removeChild" and/or "addChild" events (unless suppressed
             *                          by the "silent" argument).
             */
            _set_children: function _set_children(n, v, silent) {
                var ch = this.children;
                if (v !== ch) {
                    if (ch) {
                        // Call removeChildren with null to clear all children; it doesn't accept arrays.
                        this.removeChildren(null, silent);
                    }
                    this.addChildren(v, 0, silent);
                }
                return false;
            },

            /**
             * <p>Destroys the children of this object, if any.</p>
             *
             * <p>This method calls the destroy method of any objects in the "this.children" array, and removes the objects as children of
             * this parent object.  This is done in reverse order, in case any destroy call causes a child to be removed from this.children.
             * It is also done silently, meaning that no "removeChild" events are raised.</p>
             *
             * <p>This method can be called either separately or from this object's own "destroy" method.  When called from this object's own
             * method, it should be called with a true argument.  This allows the method to pass a flag into the children's "destroy" calls,
             * letting them know whether or not the cleanup is being coordinated by a parent/ancestor object.  The flag is used
             * as a performance optimization for a cascading destruction.</p>
             *
             * @param {boolean} [meDestroying=false] This param should be set to true when this method is called from this object's
             *                                 own "destory" method.  If true, this method skips removing the children's "parent" handle
             *                                 from the children, removing the "alias" handle to child from this parent object, and skips
             *                                 clearing the children array.
             */
            destroyChildren: function destroyChildren(meDestroying) {
                var ch = this.children,
                    len = (ch && ch.length) || 0,
                    i;
                if (len) {
                    for (i = len - 1; i > -1; i--) {
                        var c = ch[i];
                        if (c && c.destroy) {
                            c.destroy(meDestroying);
                            if (!meDestroying) {
                                postRemoveChild(this, c);
                            }
                        }
                    }
                    if (!meDestroying) {
                        ch.length = 0;
                    }
                }
            },

            invalidateChildren: function invalidateChildren() {
                mstrmojo.array.forEach(this.children, function (child) {
                    child.invalidate();
                });
            },

            invalidate: function invalidate() {
                this.invalidateChildren();
            },

            /**
             * <p>Adds a given child or array of children to this object's "children" array. Notifies event
             * listeners by raising an "addChild" event.</p>
             *
             * <p>Each "child" will have a "parent" property whose value is a handle to this object.
             * Additionally, for each child with an "alias" property, a handle to that child will be
             * stored in a property of this object; the property's name will be the child's "alias" value.</p>
             *
             * @param {mstrmojo.Widget|Object|mstrmojo.Widget[]|Object[]} c A child or array of children to be added.
             * @param {int=} idx Index at which the given child(ren) should be inserted. If missing, they are appended.
             * @param {boolean} [silent=false] If true, suppresses raising of event.
             *
             * @returns {Object|Object[]|null} The child or array of children newly added (possibly empty or null).
             */
            addChildren: function addChildren(c, idx, silent) {
                if (!c) {
                    return c;
                }
                // Convert the given children references to an array of proper children.
                var isArr = c.constructor === Array,
                    arr = makeCh(this, isArr ? c : [c]);

                if (arr && arr.length) {
                    // Insert the new kids into our "children" property.
                    var ch = this.children || [];
                    if (idx === null || idx === undefined) {  // if idx is null OR undefined
                        idx = ch.length;
                    }
                    this.children = $ARR.insert(ch, idx, arr);

                    // Raise an event, only if someone is listening for it (including this object itself).
                    if (!silent && (this.onaddChild || $PUB.hasSubs(this.id, "addChild"))) {
                        this.raiseEvent({
                            name: "addChild",
                            value: arr,
                            index: idx
                        });
                    }
                }
                return isArr ? arr : (arr && arr[0]);
            },

            /**
             * <p>Removes a given child or all children from this object's "children" array. Notifies event
             * listeners by raising an "removeChild" event.</p>
             *
             * <p>Each removed child's parent property is cleared.  Additionally, if a child has an "alias" property,
             * this object's alias handle to that child will be cleared.</p>
             *
             * @param {mstrmojo.Widget=} c The child to be removed. If missing, all children are removed.
             * @param {boolean} [silent=false] If true, suppresses raising of event.
             *
             * @returns {int} The index at which the child was removed, if successful; -1 otherwise.
             */
            removeChildren: function removeChildren(c, silent) {
                var ch = this.children,
                    c2r = c ? [c] : (this.children || []).concat(),
                    len = c2r.length,
                    idx = -1,
                    i;

                if (len) {
                    for (i = len - 1; i > -1; i--) {
                        postRemoveChild(this, c2r[i]);
                    }

                    if (c) {
                        idx = $ARR.removeItem(ch, c);
                    } else if (ch) {
                        ch.length = 0;
                        idx = 0;
                    }

                    // Raise an event, only if someone is listening for it (including this object itself).
                    if (!silent && (this.onremoveChild || $PUB.hasSubs(this.id, "removeChild"))) {
                        this.raiseEvent({
                            name: "removeChild",
                            value: c2r,
                            index: idx
                        });
                    }
                }
                return idx;
            },

            /**
             * <p>Removes a given child from this object's "children" collection and raises an event, unless silent,
             * and destroys that child widget.</p>
             *
             * @param {mstrmojo.Obj} child The child object/widget to be removed from the children collection.
             * @param {boolean=} silent If true, suppresses raising of the event that a child was removed.
             * @param {boolean=} ignoreDOM Optional boolean flag, if true, won't remove the child's domNode from the document.
             */
            removeAndDestroyChild: function removeAndDestroyChild(child, silent, ignoreDOM) {
                // Do we have the child widget?
                if (child) {
                    // Does the child widget belong to us?
                    if (child.parent !== this) {
                        // No? Throw an error.
                        throw "Unable to remove an object that is not in the children collection.";
                    }

                    // Remove the child from the children collection.
                    this.removeChildren(child, silent);

                    // Destroy the child.
                    child.destroy(ignoreDOM);
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.publisher");

    var $P = mstrmojo.publisher;

    /**
     * <p>Enables an object to raise events that can be heard by listeners.</p>
     *
     * <p>This mixin provides a generic "set" method for updating an object's property value. The set method is capable of
     * raising an "event" when a property value changes by leveraging mstrmojo.publisher. This event can then be heard
     * by other objects who wish to be notified of the change.  Those objects can sign up as "listeners" by calling the
     * object's "attachEventListener" and "detachEventListener" methods.</p>
     *
     * @mixin
     * @public
     */
    mstrmojo._Provider = mstrmojo.provide(

        "mstrmojo._Provider",

        /**
         * @lends mstrmojo._Provider#
         */
        {
            /**
             * @ignore
             */
            _meta_usesSuper: false,

            /**
             * <p>Specifies which properties (if any) should raise an event when
             * their value is changed via a call to the "set()" method.<p>
             *
             * <p>For example, if changes to the property "foo" should raise an event that can be listened for by event
             * listeners, then we should set audibles to:</p>
             *
             *   <pre>audibles: {"foo": true}</pre>
             *
             * <p>Alternatively, if the changes to "foo" should NOT raise an event, we can declare:</p>
             *
             *   <pre>audibles: {"foo": false}</pre>
             *
             * <p>To specify default behavior for properties in general, we can use the "*" shortcut:</p>
             *
             *   <pre>audibles: {"*": true}</pre>
             *
             * <p>If no default is specified, we assume the default to be audible.
             * Note that changes to property values which are NOT audible will not generate an internal event
             * which this instance can respond to.</p>
             *
             * @type Object
             */
            audibles: {
                "*": true
            },

            /**
             * <p>Sets the value of a given property of this object.</p>
             *
             * <p>This method checks this instance for a custom setter; if not found, the property value is updated directly.
             * If the value of the property was indeed changed, an event named "{propertyname}Change" is raised, but only
             * if both the following conditions are met:</p>
             * <ol>
             * <li>the property is audible; and</li>
             * <li>either this object has a handler for the event, or the global publisher has subscriptions for this event.</li>.
             * </ol>
             *
             * <p>If the custom setter is used and returns truthy, the event is automatically published.</p>
             *
             * @param {String} n The name of the property to change.
             * @param {*} [v] The new value.
             *
             * @returns {Boolean} true if the property value was changed; false otherwise.
             */
            set: function set(n, v) {
                // Do we have a custom setter with the name "_set_XXX"?
                var bChanged = false,
                    f = this["_set_" + n],
                    vWas = this[n];    // Old value.

                if (f) {
                    // We have a custom setter, so call it with our arguments.
                    bChanged = f.apply(this, arguments);
                } else {
                    // We don't have a custom setter, just update our property directly.
                    this[n] = v;
                    bChanged = (vWas !== v);
                }

                // Did the property value actually change?
                if (bChanged) {
                    // Performance optimization: Raise event only if it's audible and someone is
                    // listening for it (including this observable itself).
                    var evtName = n + "Change",
                        aud = this.audibles || {},
                        isAudible =  (aud[n] === true) || ((aud[n] !== false) && (aud["*"] !== false));

                    if (isAudible && (this['pre' + evtName] || this['on' + evtName] || this['post' + evtName] || $P.hasSubs(this.id, evtName))) {
                        // Raise an event corresponding to this property value change,
                        // so listeners can be notified.
                        this.raiseEvent({
                            name: evtName,
                            prop: n,
                            value: v,
                            valueWas: vWas
                        });
                    }
                }
                return this;
            },

            /**
             * <p>Publishes an event that can be handled by this and other objects.</p>
             *
             * <p>Given an object which represents an event that originated within this object, this method will call
             * this object's handler for that event (if any) with the given event object. Additionally, this method will
             * ask the mstrmojo.publisher to publish the event so other objects can be notified of the event.</p>
             *
             * @param {Object} evt An object representing an event; must have a "name" property representing the event's name.
             *
             * @returns {Object} The augmented event object.
             */
            raiseEvent: function rse(evt) {
                var n = evt && evt.name;
                if (!n) {
                    return null;
                }
                // Set the event source.
                evt.src = this;

                // Hook for customization.
                this.preHandleEvent(evt);

                // First let this object respond to the event with its own custom handler, if any.
                var ns = ['pre', 'on', 'post'],
                    abort = false,
                    i,
                    len;

                for (i = 0, len = ns.length; i < len; i++) {
                    var fn = ns[i] + n;
                    if (this[fn]) {
                        if (this[fn](evt) === false) {
                            abort = true;
                            break;
                        }
                    }
                }

                // If no event handler has "aborted" this event...
                if (!abort) {
                    // Hook for customization.
                    this.postHandleEvent(evt);

                    // Then publish the event for other listeners to be notified.
                    $P.publish(this.id, n, evt);
                }

                return evt;
            },

            /**
             * <p>Optional handler called before event handling is executed.</p>
             *
             * <p>This handler is supported as a customization hook within the event handling process.
             * If specified, the handler will be called from raiseEvent before the object's handler for the event.
             * A single argument will be passed into the call: the event object.</p>
             *
             * @param {mstrmojo.Event}
             *
             * @abstract
             */
            preHandleEvent: mstrmojo.emptyFn,

            /**
             * <p>Optional handler called after event handling is executed.</p>
             *
             * <p>This handler is supported as a customization hook within the event handling process.
             * If specified, the handler will be called from raiseEvent after the object's handler for the event.
             * A single argument will be passed into the call: the event object.</p>
             *
             * @abstract
             */
            postHandleEvent: mstrmojo.emptyFn,

            /**
             * <p>A shortcut for subscribing to events from this observable object.</p>
             *
             * <p>Although mstrmojo.publisher can be called to attach an event listener to an observable object,
             * this method is provided as a convenience for attaching listeners for events that originate within this object.</p>
             *
             * @param {String} name The name of the event we wish to subcribe to.
             * @param {Function|String} callback A function, or name of a method, to be called in response to the event.
             * @param {String} [listener] ID of object which hosts the callback. If omitted, the global context is assumed.
             * @returns {Object} An object representing the attached subscription.  This object can be used subsequently as the argument to
             * detachEventListener to cancel the subscription.
             */
            attachEventListener: function att(name, listener, callback) {
                return $P.subscribe(this.id, name, callback, listener);
            },

            /**
             * <p>A shortcut for unsubscribing from events from this observable object.</p>
             *
             * <p>Although mstrmojo.publisher can be called to detach an event listener to an observable object,
             * this method is provided as a convenience for detaching listeners for events that originate within this object.
             * This method is a complement to the attachEventListener method, and can be used to cancel a subscription created by attachEventListener.</p>
             *
             * @param {Object} sub A single object identifier for the subscription, or an array of object identifiers.
             */
            detachEventListener: function det(sub) {
                $P.unsubscribe(sub);
            },

            /**
             * Clears any subscriptions associated with this component.
             *
             */
            destroy: function destroy() {
                // Clear all subscription to or from this object.
                $P.clearSubscriptions(this.id);

                if (this._super) {
                    this._super();
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.registry",
                         "mstrmojo.hash");

    var loadedCls = false,
        FQCN = "mstrmojo.Binding",
        $BINDINGS = "bindings",
        $REGISTRY = mstrmojo.registry;

    /**
     * Disables a given collection of binding objects.
     * @param {Object} bs Hash of binding objects.
     *
     * @private
     */
    function shutdown(bs) {
        var d;
        for (d in bs) {
            var b = bs[d];
            if (b && b.disable) {
                b.destroy();
            }
        }
    }

    /**
     * Enables a given collection of either binding objects or references to binding objects.
     *
     * @param {Object} bs Hash of binding objects or references.
     * @param {Object} p The parent object to which these bindings belong.
     * @private
     */
    function startup(bs, p) {
        // Load the Binding class (one-time only).
        if (!loadedCls) {
            mstrmojo.requiresCls(FQCN);
            loadedCls = true;
        }
        // For each binding config...
        var d;
        for (d in bs) {
            var b = bs[d];
            if (b === null || b === undefined) {    // if b is null or undefined
                continue;
            }
            var t = typeof b;
            // Strings values are shorthand for binding "source" properties;
            // otherwise assume we have an object value.
            if (t === "string" || t === "function") {
                b = {
                    destination: d,
                    source: b,
                    scriptClass: FQCN
                };
            }
            // Before creating the binding, set its parent handle (in case it uses it).
            b.parent = p;
            // Evaluate the binding reference into a binding object and start it up.
            // Optimization: skip class loaded check, because we assume we've already loaded the one binding class above.
            b = $REGISTRY.ref(b, {
                skipLoadChecks: true
            });
            bs[d] = b;
            b.enable();
        }
    }

    /**
     * <p>Enables the use of bindings to determine property values on a given object.</p>
     *
     * <p>The object is expected to have a "bindings" property whose value is a hashtable, which is keyed by destination name;
     * the hash values are configs for instances of Binding objects.</p>
     *
     * @mixin
     * @public
     */
    mstrmojo._HasBindings = mstrmojo.provide(
        "mstrmojo._HasBindings",

        /**
         * @lends mstrmojo._HasBindings#
         */
        {
            _meta_usesSuper: false,

            /**
             * <p>Hash of bindings defined for this object.</p>
             *
             * @type {Object}
             */
            //bindings: null,

            /**
             * <p>Optional handler called after initialization of bindings.</p>
             *
             * <p>This handler is supported as a customization hook at the end of the binding creation process.
             * If specified, the handler will be called after the instance's bindings have been initialized.
             * If the instance has no bindings, the handler will not be called.</p>
             *
             * @type Function
             */
            //postCreateBindings: null,

            /**
             * <p>Initializes the bindings for properties in this object and its children (if any).</p>
             *
             * <p>This method first inspects this object's "bindings" property. If given, this method creates
             * bindings from that property value. Then this method calls the "initBindings" method of this object's children
             * (if any) regardless of whether or not this object has any bindings.</p>
             */
            initBindings: function inB() {
                this.hasInitBindings = true;

                var bs = mstrmojo.hash.copy(this[$BINDINGS]);

                if (bs) {
                    delete this[$BINDINGS];
                    this._set_bindings($BINDINGS, bs);
                    // Hook for customizations after creating bindings.
                    if (this.postCreateBindings) {
                        this.postCreateBindings();
                    }
                }

                var ch = this.children,
                    len = (ch && ch.length) || 0;

                if (len) {
                    var i;
                    for (i = 0; i < len; i++) {
                        var c = ch[i];
                        if (c && c.initBindings) {
                            c.initBindings();
                        }
                    }
                }
            },

            destroyBindings: function destB() {
                var bs = this.bindings;
                if (bs) {
                    shutdown(bs);
                    delete this.bindings;
                }
            },

            /**
             * <p>Custom setter for the "bindings" property value.</p>
             *
             * <p>This method will apply a given hash of bindings to this object.
             * It initializes the values of the bound properties in this object.
             * Any bindings previously in the "bindings" property are removed first.</p>
             *
             * <p>This method inspects the given bindings hash. Each hash key is the
             * name of a bound property; each hash value is either an instance of a Binding object,
             * or a reference to a Binding. A "reference" is either a String (which serves as the
             * source script for a new Binding) or a hashtable of properties for a new Binding, which
             * is resolved via the mstrmojo.registry.ref method.</p>
             *
             * @param {String} [n="bindings"] The property whose value is being set.
             * @param {Object} [v] Hash of either binding objects or references to binding objects.
             * @returns {Boolean} true if the "bindings" hash object was reset; false otherwise.
             */
            _set_bindings: function setB(n, v) {
                var bs = this[$BINDINGS];
                if (v !== bs) {
                    if (bs) {
                        shutdown(bs);
                    }
                    this[$BINDINGS] = v;
                    if (v) {
                        startup(v, this);
                    }
                    return true;
                }
                return false;
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.dom",
        "mstrmojo.dnd");

    var $DOM = mstrmojo.dom;

    /**
     * Determines if the moving handle is being dragged.
     *
     * @param {Object} context The drag context.
     *
     * @returns {boolean}
     */
    function isHandleMoving(context) {
        return $DOM.contains(this.getMovingHandle(), context.src.node, true, document.body);
    }

    /**
     * @mixin
     * @public
     */
    mstrmojo._IsMovable = mstrmojo.provide(
        "mstrmojo._IsMovable",
        /**
         * @lends mstrmojo._IsMovable
         */
        {
            /**
             * Whether or not this widget is draggable/movable.
             *
             * @type {boolean}
             * @default true
             */
            draggable: true,

            /**
             * Whether or not this widget controls its own avatar when dragged. By default, for a movable object/widget, we do not show
             * any avatar, instead, we just change the mouse cursor to 'move' style.
             *
             *  @type {boolean}
             *  @default true
             */
            ownAvatar: true,

            /**
             * A method that returns the movable handle node.
             *
             * @returns {HTMLElement}
             */
            getMovingHandle: function getMovingHandle() {
                return this.domNode;
            },

            /**
             * A method that returns the target of the move.
             *
             * @returns {HTMLElement}
             */
            getMovingTarget: function getMovingTarget() {
                return this.domNode;
            },

            isDragValid: function isDragValid(context) {
                return isHandleMoving.call(this, context) || (this._super && this._super(context)) || false;
            },

            ondragstart: function ondragstart(context) {
                if (isHandleMoving.call(this, context)) {
                    var handle = this.getMovingHandle(),
                        targetStyle = this.getMovingTarget().style;

                    // Cache the left and top positions as well as the handle height and width.
                    this._leftPos = parseInt(targetStyle.left, 10);
                    this._topPos = parseInt(targetStyle.top, 10);
                    this._hWidth = handle.clientWidth;
                    this._hHeight = handle.clientHeight;
                }

                if (this._super) {
                    this._super();
                }
            },

            ondragmove: function ondragmove(context) {
                if (isHandleMoving.call(this, context)) {
                    var targetPosition = context.tgt.pos,
                        srcPosition = context.src.pos,
                        targetStyle = this.getMovingTarget().style,
                        dm = $DOM.windowDim();

                    // Position target at cached position plus delta.
                    // TQMS #536942: Don't allow the element to be dragged such that the handle is no longer on the screen.
                    // TQMS #963756: limit drag to right and bottom depend on the window's dimension
                    targetStyle.left = this.left = Math.min(Math.max(this._leftPos + targetPosition.x - srcPosition.x, -this._hWidth + 40), dm.w - 40) + 'px';
                    targetStyle.top = this.top = Math.min(Math.max(this._topPos + targetPosition.y - srcPosition.y, -this._hHeight + 20), dm.h - 20) + 'px';
                }

                if (this._super) {
                    this._super();
                }
            },

            ondragend: function ondragend(context) {
                if (isHandleMoving.call(this, context)) {
                    // Clear left and top position and handle height and width.
                    delete this._leftPos;
                    delete this._topPos;
                    delete this._hWidth;
                    delete this._hHeight;
                }


                if (this._super) {
                    this._super();
                }
            }
        }
    );
}());
/**
 * DOMLocalStorage.js 
 * Copyright 2011 MicroStrategy Incorporated. All rights reserved.
 *
 * @fileoverview wrapper classes around the DOM Local Storage API in HTML5.
 * @version 1.0
 */

(function(){

    mstrmojo.requiresCls( "mstrmojo.storage.DOMStorage" );

    var LOCAL_STORAGE_DATA_FORMAT_VERSION = 4;

    /**
     * <p>Class that manages DOM local storage.</p>
     * @class
     * @augments mstrmojo.storage.DOMStorage
     */
    mstrmojo.storage.DOMLocalStorage = mstrmojo.declare(mstrmojo.storage.DOMStorage, null, 
        /**
         * @lends mstrmojo.storage.DOMLocalStorage.prototype
         */     
        {
            scriptClass : "mstrmojo.storage.DOMLocalStorage",
        
                
            /**
             * Initializes the object with reference to localStorage object if available.\
             * @memberOf mstrmojo.storage.DOMLocalStorage
             * @param {Object} [props] Hash of property values to be applied to this instance.       
             */
             
            init : function(props) {
                this._super(props);
                
                // detect the feature watching out for exceptions that can be thrown if the user
                // has disabled storage, etc.
                try {
                    this.mIsSupported = ('localStorage' in window) && (window['localStorage'] !== null);        
                    this.mStorageObj = this.mIsSupported ? window.localStorage : null;

                    this.checkVersion(LOCAL_STORAGE_DATA_FORMAT_VERSION);                

                } catch (e) {
                    // eat any exceptions and just turn off the feature
                    this.mIsSupported = false;
                }
            }
        });

    /**
     * Alias to the singleton object that manages the DOM local storage. We increase the ttl for local storage items to 24 hours.
     * @static
     */
    $LS = mstrmojo.global.localStore = new mstrmojo.storage.DOMLocalStorage({ itemTimeToLive: (3600 * 24) });

})();
/**
 * DOMSessionStorage.js 
 * Copyright 2011 MicroStrategy Incorporated. All rights reserved.
 *
 * @fileoverview wrapper classes around the DOM Session Storage API in HTML5.
 * @version 1.0
 */

(function(){

    mstrmojo.requiresCls( "mstrmojo.storage.DOMStorage" );

    var     SESSION_STORAGE_DATA_FORMAT_VERSION = 4;

    /**
     * <p>Class that manages DOM session storage. Data stored using this class persists for the current session only.</p>
     *
     * @class
     * @augments mstrmojo.storage.DOMSessionStorage
     */
    
    mstrmojo.storage.DOMSessionStorage = mstrmojo.declare(mstrmojo.storage.DOMStorage, null, 
        /**
         * @lends mstrmojo.storage.DOMSessionStorage.prototype
         */             
        {
        scriptClass : "mstrmojo.storage.DOMSessionStorage",
        
        
        /**
         * Initializes the object with reference to localStorage object if available.\
         * @methodOf mstrmojo.storage.DOMSessionStorage
         * @param {Object} [props] Hash of property values to be applied to this instance.       
         */
        init : function(props) {
            this._super(props);

            // detect the feature watching out for exceptions that can be thrown if the user
            // has disabled storage, etc.
            try {
                this.mIsSupported = ('sessionStorage' in window) && (window['sessionStorage'] !== null);        
                this.mStorageObj = this.mIsSupported ? window.sessionStorage : null;

                this.checkVersion(SESSION_STORAGE_DATA_FORMAT_VERSION);
                
            } catch (e) {
                // eat any exceptions and just turn off the feature
                this.mIsSupported = false;
            }
        }
    });

    $SS = mstrmojo.global.sessionStore = new mstrmojo.storage.DOMSessionStorage();

})();
(function () {
    mstrmojo.requiresCls(
        "mstrmojo.base64",
        "mstrmojo.func",
        "mstrmojo.hash",
        "mstrmojo.string",
        "mstrmojo.dom"
    );

    /**
     * A standard XHR callback object.
     *
     * @typedef {{
     *      submission: Function=,
     *      progress: Function=,
     *      success: Function=,
     *      failure: Function=,
     *      complete: Function=,
     *      canceled: Function=
     *  }} mstrmojo.XhrCallbackType
     *
     * @property {Function=} submission Called when the XHR request is submitted.
     * @property {Function=} progress Called when the XHR has progress.
     * @property {Function=} success Called when the XHR request succeeds.
     * @property {Function=} failure Called when the XHR request fails.
     * @property {Function=} complete Called when the XHR request is complete, regardless of status.
     * @property {Function=} canceled Called when the XHR request is canceled.
     */
    mstrmojo.XhrCallbackType = null;

    /**
     * <p> Decode the Base64-encoded response header whose value are in the following format: "=?UTF-8?B?EncodedText?=" </p>
     *
     * @param {string} value The value of a response header.
     * @returns {string} The decoded response header.
     *
     * @private
     */
    function decodeHeader(value) {
        var rEncoded = /\=\?UTF-8\?B\?(.+?)\?\=/g;
        if (value && value.indexOf("=?UTF-8?B?") === 0) {
            var decMsg = "", result;
            while ((result = rEncoded.exec(value)) !== null) {
                decMsg += mstrmojo.base64.decode(result[1]);
            }
            return decMsg;
        }
        return value;
    }

    /**
     * <p>Encodes parameters for XHR transport.</p>
     *
     * @param {Object} params A hash containing parameter names and values.
     *
     * @returns {string} A URL of encoded parameters.
     */
    function encodeParams(params) {
        var x = -1,
            url = [],
            p;

        if (params) {
            for (p in params) {
                url[++x] = p + '=' + encodeURIComponent(params[p]);
            }
        }

        return url.join('&');
    }

    /**
     * <p>Builds up the url with parameters is method == 'GET'.</p>
     *
     * @param {string} method The method for the xhr ('GET' or 'POST').
     * @param {string} baseUrl The url used for both GET and POST (excludes parameters in GET case).
     * @param {Object} [params] The parameters for this request.
     *
     * @returns {string} The url built from the baseUrl and params.
     */
    function appendUrlParams(method, baseUrl, params) {
        if (method !== 'GET' || !params) {
            return baseUrl;
        }

        return baseUrl + '?' + encodeParams(params);
    }

    /**
     * <p>Opens and sends the xhr.</p>
     *
     * @param {{open: Function, send: Function, setRequestHeader: Function, onreadystatechange: Function}} xhr The xhr to use for this request.
     * @param {string} method The method for the xhr ('GET' or 'POST').
     * @param {string} baseUrl The url used for both GET and POST (excludes parameters in GET case).
     * @param {Object} params The parameters for this request.
     * @private
     */
    function sendXhr(xhr, method, baseUrl, params) {
        // Make sure it's uppercase for comparisons.
        method = method.toUpperCase();
        var app = mstrApp,
            m = window.microstrategy;

        // Set default values.
        if (this.isTask) {
            params = mstrmojo.addCSRFTokenToTaskParams(params);

            params.taskContentType = params.taskContentType || 'json';
            params.taskEnv = params.taskEnv || 'xhr';
            params.xts = new Date().getTime();
            params[mstrApp.name] = mstrApp.servletState || mstrConfig.servletState || '';
            baseUrl = baseUrl || mstrConfig.taskURL;
        }

        //persisted task params
        var ptp = app.persistTaskParams || (m && m.persistParams);
        if (ptp) {
            mstrmojo.requiresCls("mstrmojo.hash");
            mstrmojo.hash.copy(ptp, params);
        }

        xhr.open(method, appendUrlParams(method, baseUrl, params), this.async);

        // Add request headers if provided
        var headers = params.xhrHeaders;
        if (headers) {
            for (var hdr in headers) {
                xhr.setRequestHeader(hdr, headers[hdr])
            }

            delete params.xhrHeaders;
        }

        if (method !== 'POST') {
            xhr.send(null);
        } else {
            xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
            xhr.send(encodeParams(params));
        }


        if (this.async === false) {
            xhr.onreadystatechange();
        }
    }

    /**
     * <p>Creates an XHR object.</p>
     *
     * @type XMLHttpRequest
     * @returns An instance of the XMHttpRequest object.
     *
     * @private
     */
    function createXhr() {
        var methods = [
                function () {
                    var res = new XMLHttpRequest();
                    var foo = res.open;
                    res.open = function () {
                        foo.apply(res, arguments);
                    }
                    return res;
                },
                function () {
                    return new ActiveXObject('Msxml2.XMLHTTP');
                },
                function () {
                    return new ActiveXObject('Microsoft.XMLHTTP');
                }
            ],
            cnt = methods.length,
            i;

        for (i = 0; i < cnt; i++) {
            var xhr;
            try {
                xhr = methods[i]();
            } catch (e) {
                continue;
            }

            // Success, replace this method with appropriate method.
            createXhr = methods[i];
            return xhr;
        }

        // Failed, throw error.
        throw new Error('mstrmojo.SimpleXHR: Could not create an XHR object.');
    }

    /**
     * Evals the XHR response, swallowing any errors that occur.
     *
     * @param {string} rt The XHR.responseText.
     *
     * @private
     */
    function evalResponse(rt) {
        var rtn = null;

        try {
            try {
                rtn = JSON.parse(rt);
            } catch (ex) {
                rtn = eval('(' + rt + ')');
            }
        } catch (ex) {
            rtn = rt && mstrmojo.string.trim(rt);
        }

        return rtn;
    }

    /**
     * Error codes for disconnected session.
     *
     * @private
     * @ignore
     */
    var MSI_SERVER_NAME_NOT_INITIALIZED = 0x800438F3,  // Server Name Not initialized
        MSI_INVALID_SESSION_ID = 0x800438F4,           // Session ID invalid
        E_MSI_USERMGR_USER_NOTFOUND = 0x800430A5,      // UserLogin expired
        E_MSI_CONNECT_FAILED = 0x80043705;

    /**
     * Check response code to see whether the xhr error because of disconnected session.
     *
     * @private
     * @ignore
     */
    function isSessionExpiredError(res) {
    	if (res.status === 401) {
    		return true;
    	}
        var c = res && res.getResponseHeader('X-MSTR-TaskErrorCode');
        c = (c < 0) ? (0x100000000 + parseInt(c, 10)) : c;    // c from task is a negative number, we need to recover it into positive number
        switch (c) {
        case MSI_SERVER_NAME_NOT_INITIALIZED:
        case MSI_INVALID_SESSION_ID:
        case E_MSI_USERMGR_USER_NOTFOUND:
        case E_MSI_CONNECT_FAILED:
            return true;
        }
        return false;
    }

    function xhrSupportsProgress(xhr) {
    	// DE50288 Executing xhr.upload && xhr.upload.onprogress on safari will break the
    	// the IIS windows authentication request handshake, causing xhr post call hanging forever     	
        return !mstrmojo.dom.isSafari && !!(xhr && xhr.upload && xhr.upload.onprogress);
    }

    /**
     * A simple XHR.
     *
     * @class
     */
    mstrmojo.SimpleXHR = mstrmojo.declare(
        // superclass
        null,

        // mixins
        null,

        /**
         * @lends mstrmojo.SimpleXHR.prototype
         */
        {
            scriptClass: "mstrmojo.SimpleXHR",

            /**
             * If true, this object's requests are treated as requests to a MicroStrategy Web Task, and
             * therefore Task-specific default parameters are automatically included in each request.
             *
             * @type Boolean
             */
            isTask: true,

            /**
             * If true, the XHR will be sent asynchronously
             *
             * @type Boolean
             */
            async: true,

            init: function init(props) {
                // Apply the given properties to this instance.
                mstrmojo.hash.copy(props, this);
            },

            onreadystatechange: function onreadystatechange(xhr, callback, prevRequest) {
                // ignore all state changes until we see a 4
                if (xhr.readyState !== 4) {
                    return;
                }
                // we expect the callback parameter to be a hash of callback functions for success, failure, etc.
                if (typeof callback !== "object") {
                    return;
                }

                try {
                    // djh 2010/06/30 added check for 304 error code to handle cached files that have not changed.
                    if ((xhr.status === 200) || (xhr.status === 304)) {

                        // evaluate the response from the server in the hopes that it returned us JSON.  However, it may not.
                        // We can receive text, HTML, XML, or <empty string> here as well.
                        this.response = callback.textResponse ? xhr.responseText : evalResponse(xhr.responseText);

                        // if we got a response then pass it back to the success() callback.  It is this function's responsibility to
                        // determine if the repsonse data received is value for the request made of the server.
                        if (typeof callback.success === "function") {
                            // got data back from the server that evaluated w/o errors; call the success callback
                            callback.success(this.response, xhr);
                        }
                    } else {
                        // Xhr.status= 0, when timeout or canceled. If it is canceled, xhr.isAborted is true.
                        // For status =0, only pop up error when it is not canceled(isAborted) and request with displayNoResErr, like for docRefresh
                        if (xhr.status !== 0 || (!xhr.isAborted && prevRequest.params.displayNoResErr)) {
                            // need to check session expiration error
                            var app = mstrApp,
                                sessionExp = app && app.onSessionExpired;

                            if (sessionExp && isSessionExpiredError(xhr)) {
                                sessionExp.call(app, prevRequest);
                            } else {
                                var orig = xhr.getResponseHeader;
                                xhr.getResponseHeader = function (name) {
                                    return decodeHeader(orig.apply ? orig.apply(xhr, [name]) : orig(name));
                                };

                                // since we failed to get the data, call the failure callback
                                if (typeof callback.failure === "function") {
                                    callback.failure(xhr);
                                }
                            }
                        }
                    }
                } catch (ex) {
                    mstrmojo.err(ex);
                    throw ex;
                } finally {
                    // no matter what, call the complete callback
                    if (typeof callback.complete === "function") {
                        callback.complete();
                    }

                    // This xhr request should have extended the session to a new cycle of life,
                    // then we need restart session manager unless the request sets flag 'notRestartSessionManager.params' true.
                    // Specifically task 'isSessionAlive' should have set this flag true.
                    if (!isSessionExpiredError(xhr) && !prevRequest.params.notRestartSessionManager) {
                        var sm = mstrApp.sessionManager;
                        if (sm && sm.restart) {
                            sm.restart();
                        }
                    }
                }
            },

            /**
             * <p>Aborts an XHR request in progress.</p>
             *
             * @returns {boolean} TRUE if xhr request was canceled
             */
            cancel: function () {
                var didCancel = false;
                var xhr = this.xhr;
                if (xhr) {
                    delete xhr.onreadystatechange;
                    // assign it to null would cause type mismatch error in IE.
                    // xhr.onreadystatechange = null;
                    xhr.isAborted = true;//for some browsers, the onreadystatechange is still called, so we need to use this workaround.

                    if (xhr.readyState < 4) {
                        xhr.abort();
                        didCancel = true;
                    }
                    this.xhr = null;
                }
                return didCancel;
            },

            /**
             * <p>Initiates an XHR request.</p>
             *
             * @param {string} method The method to use, i.e. 'GET' or 'POST'.
             * @param {string} baseUrl The base URL of the web server page to hit with the XHR request.
             * @param {mstrmojo.XhrCallbackType} callback The callback interface
             * @param {Object} params A hash of parameter names/values.
             * @param {string=} webSvrUrl  Web server url if the call is targeted to another web server other than the one hosting the app.
             * @param {boolean=} useResFeed if use resourceFeed to access webSrvUrl
             * @param {Object=} webSrvParams Params for webSvrUrl
             */
            request: function request(method, baseUrl, callback, params, webSvrUrl, useResFeed, webSrvParams) {
                // If webSvrUrl is presented, it means this is a cross web server request.
                // Then it will be delegated to mstrmojo.jsonp.request.
                if (webSvrUrl) {
                    if (useResFeed === true) {
                        if (!params) {
                            params = {};
                        }
                        params.srcURL = appendUrlParams('POST', webSvrUrl, webSrvParams);
                        this.request(method, baseUrl, callback, params);
                    } else {
                        mstrmojo.jsonp.request(webSvrUrl, params, callback);
                    }
                } else {
                    var xhr = createXhr();
                    xhr.onreadystatechange = (function (me, x, c, pr) {
                        return function () {
                            me.onreadystatechange(x, c, pr);
                        };
                    }(this, xhr, callback, {
                        method: method,
                        baseUrl: baseUrl,
                        callback: callback,
                        params: params
                    }));

                    // if the xhr supports it, hook up the progress callback if we have one
                    if (xhrSupportsProgress(xhr) && callback.progress) {
                        xhr.onprogress = (function (me, x, c) {
                            return function (evt) {
                                c.progress.call(me, evt);
                            };
                        }(this, xhr, callback));
                    }
                    this.xhr = xhr;

                    sendXhr.call(this, xhr, method, baseUrl, params);
                }
            }
        }
    );

    /**
     * An XHR that queues requests.
     *
     * @class
     * @extends mstrmojo.SimpleXHR
     */
    mstrmojo.QueuedXHR = mstrmojo.declare(
        // superclass
        mstrmojo.SimpleXHR,

        // mixins,
        null,

        /**
         * @lends mstrmojo.QueuedXHR.prototype
         */
        {
            scriptClass: "mstrmojo.QueuedXHR",

            /**
             * The request queue.
             *
             * @type {Object[]}
             * @private
             */
            queue: null,

            /**
             * Number of requests in the queue, it indicates where there is any request in progress.
             *
             * @type {Integer}
             * @private
             */
            requestCount: 0,

            /**
             * The number of seconds to delay between requests.
             *
             * @type {int}
             * @private
             */
            retryDelay: 1,

            /**
             * The request cache, the task with same parameters can hit this cache
             *
             * @type {Object[]}
             * @private
             */
            lookup: null,

            /**
             * <p>Override of super that aborts an XHR request in progress and purges queue of any outstanding requests</p>
             */
            cancel: function cancel() {
                // cancel any request that's actually processing ASAP so it doesn't complete and fire off any queued requests
                var didCancel = this._super();

                // now empty the queue of any requests we haven't processed yet firing the complete() callback for each one
                while (this.queue.length) {
                    var x = this.queue.pop();
                    var cb = x.callback;
                    if (cb && cb.complete) {
                        cb.complete();
                    }
                }
                this.queue = [];

                // reset our busy flag
                this.requestCount--;

                return didCancel;
            },

            /**
             * Constructor. Initializes the queue to an empty array.
             */
            init: function init() {
                this.queue = [];
                this.lookup = [];
            },

            /**
             * <p>Initiates an XHR request.</p>
             *
             * @param {string} method The method to use, i.e. 'GET' or 'POST'.
             * @param {string} baseUrl The base URL of the web server page to hit with the XHR request.
             * @param {mstrmojo.XhrCallbackType} callback An optional callback interface
             * @param {Object} params A hash of parameter names/values.
             * @param {boolean=} override Indicates that any in progress requests should be cancelled.
             * @param {string=} webSvrUrl  Webserver url if the call is targeted to another web server other than the one hosting the app.
             * @param {boolean=} useResFeed if use resourceFeed to access webSrvUrl
             * @param {Object=} webSrvParams Params for webSvrUrl
             * @param {boolean=} useCache indicates whether to cache the response of the request into local memory
             */
            request: function request(method, baseUrl, callback, params, override, webSvrUrl, useResFeed, webSrvParams, useCache) {
                // If webSvrUrl is presented, it means this is a cross web server request.
                // Then it will be delegated to mstrmojo.jsonp.request.
                if (webSvrUrl) {
                    if (useResFeed === true) {
                        if (!params) {
                            params = {};
                        }
                        params.srcURL = appendUrlParams('POST', webSvrUrl, webSrvParams);
                        this.request(method, baseUrl, callback, params);
                    } else {
                        mstrmojo.jsonp.request(webSvrUrl, params, callback);
                    }
                } else {
                    // if there's already a request processing and we're not to preempt it then queue the new request
                    if (this.requestCount > 0 && !override) {
                        this.queue.push({
                            method: method,
                            baseUrl: baseUrl,
                            callback: callback,
                            params: params
                        });
                    } else {
                        // either nothing is going on or we want to preempt any running/queued requests

                        // if there is a request in progress then kill it any empty the queue
                        if (this.requestCount > 0) {
                            this.cancel();
                        }

                        this.requestCount++;

                        var lu = null,
                            oriParams = null;
                        if (useCache) {
                            lu = this._searchForCacheRequest(params);
                            oriParams = mstrmojo.hash.copy(params); // because it may add some more parameters in later sendXHR method
                        }

                        if (lu) {
                            // If find the cache, directly call the success callback with cached response data
                            try {
                                if (callback.success) {
                                    window.setTimeout(
                                        function () {
                                            callback.success(lu.res);
                                        },
                                        10
                                    );
                                    //callback.success(lu.res);
                                }
                            } catch (ex) {
                                mstrmojo.err(ex);
                                throw ex;
                            } finally {
                                if (callback.complete) {
                                    callback.complete();
                                }
                                this.advanceQueue();
                            }
                        } else {
                            var xhr = this.xhr = createXhr();

                            // wrap the complete callback with our own that will advance the queue
                            callback = /** @type {mstrmojo.XhrCallbackType} **/ mstrmojo.func.wrapMethods(callback, {
                                complete: (function (ths) {
                                    return function () {
                                        ths.advanceQueue();
                                    };
                                }(this)),

                                success: (function (ths) {
                                    return function () {
                                        // Cache the request with parameters and response into the lookup
                                        if (useCache) {
                                            ths.lookup.push({
                                                params: oriParams,
                                                res: ths.response
                                            });
                                        }
                                    };
                                }(this))
                            });

                            xhr.onreadystatechange = (function (me, x, c, pr) {
                                return function () {
                                    me.onreadystatechange(x, c, pr);
                                };
                            }(this, xhr, callback, {
                                method: method,
                                baseUrl: baseUrl,
                                callback: callback,
                                params: params
                            }));

                            // if the xhr supports it, hook up the progress callback if we have one
                            if (xhrSupportsProgress(xhr) && callback.progress) {
                                xhr.onprogress = (function (me, x, c) {
                                    return function (evt) {
                                        c.progress.call(me, evt);
                                    };
                                }(this, xhr, callback));
                            }

                            sendXhr.call(this, xhr, method, baseUrl, params);
                        }
                    }
                }
            },

            /**
             * Use Formdata to send data to the server via XHR request
             *
             * @param method The method to use, i.e. 'GET' or 'POST'
             * @param baseUrl The base URL of the web server page to hit with the XHR request
             * @param callback An optional callback interface
             * @param params A hash of parameter names/values.
             * @param data The data being sent. Data can be a Blob, File, or a string, if neither, the value is converted to a string.
             * @param config Configuration for the progress bar
             * @param override Indicates that any in progress requests should be cancelled.
             * @param webSrvParams Params for webSvrUrl
             * @param useCache indicate whether to cache the response of the request into local memory
             */
            upload: function upload(method, baseUrl, callback, params, data, config, override, webSrvParams, useCache) {

                if (this.isTask) {
                    params = mstrmojo.addCSRFTokenToTaskParams(params);
                }

                // if there's already a request processing and we're not to preempt it then queue the new request
                if (this.requestCount > 0 && !override) {
                    this.queue.push({
                        method: method,
                        baseUrl: baseUrl,
                        callback: callback,
                        params: params,
                        data: data,
                        config: config
                    });
                } else {
                    // either nothing is going on or we want to preempt any running/queued requests

                    // if there is a request in progress then kill it any empty the queue
                    if (this.requestCount > 0) {
                        this.cancel();
                    }

                    this.requestCount++;

                    var lu = null,
                        oriParams = null;
                    if (useCache) {
                        lu = this._searchForCacheRequest(params);
                        oriParams = mstrmojo.hash.copy(params); // because it may add some more parameters in later sendXHR method
                    }

                    if (lu) {
                        // If find the cache, directly call the success callback with cached response data
                        try {
                            if (callback.success) {
                                window.setTimeout(
                                    function () {
                                        callback.success(lu.res);
                                    },
                                    10
                                );
                                //callback.success(lu.res);
                            }
                        } catch (ex) {
                            mstrmojo.err(ex);
                            throw ex;
                        } finally {
                            if (callback.complete) {
                                callback.complete();
                            }
                            this.advanceQueue();
                        }
                    } else {
                        var xhr = this.xhr = createXhr();
                        var self = this;
                        // wrap the complete callback with our own that will advance the queue
                        callback = mstrmojo.func.wrapMethods(callback, {
                            complete: (function (ths) {
                                return function () {
                                    ths.advanceQueue.call(ths);
                                };
                            }(this)),
                            success: (function (ths) {
                                return function () {
                                    // Cache the request with parameters and response into the lookup
                                    if (useCache) {
                                        ths.lookup.push({
                                            params: oriParams,
                                            res: ths.response
                                        });
                                    }
                                };
                            }(this))
                        });

                        var handleProgress = function (event) {
                            callback.progress(event, config);
                        };

                        // TQMS 837861. by muli.
                        var url = baseUrl;
                        var async = !!(config && config.async);

                        xhr.open('POST', url, async);


                        if (config && config.authToken) {
                            xhr.setRequestHeader('X-MSTR-AuthToken', config.authToken);
                            if('projectId' in params){
                                xhr.setRequestHeader('X-MSTR-ProjectId', params.projectId);
                            }
                        }

                        var formData = new FormData();
                        var a;
                        for (a in params) {
                            formData.append(a, params[a]);
                        }
                        if (data) { //YGUO TQMS-958717
                            if (params.fileName) {
                                // fileFieldName: indicate custom file field name if defined by upper level.
                                formData.append(params.fileFieldName ? params.fileFieldName : 'myFile', data, params.fileName); //YGUO TQMS-942690 For QE's concern, change the blob object's default name into the file's name, even though this does not affect the functionality at all.
                            } else {
                                formData.append(params.fileFieldName ? params.fileFieldName : 'myFile', data);
                            }
                        }

                        // if the xhr supports it, hook up the progress callback if we have one
                        if (xhrSupportsProgress(xhr) && callback.progress) {
                            xhr.upload.onprogress = handleProgress;
                        }
                        xhr.onreadystatechange = (function (me, x, c, pr) {
                            return function () {
                                me.onreadystatechange(x, c, pr);
                            };
                        }(self, xhr, callback, {
                            method: method,
                            baseUrl: baseUrl,
                            callback: callback,
                            params: params
                        }));
                        xhr.send(formData);
                    }
                }
            },

            /**
             * Moves to the next request in the queue.
             *
             * @private
             */
            advanceQueue: function advanceQueue() {
                // nothing is processing right now
                this.requestCount--;
                if (this.queue.length === 0) {
                    this.requestCount = 0;
                    return;
                }
                var req = this.queue.shift();
                if (req.params.taskId === "importFile" || req.params.taskId === "arch.sparkFileUpload") {
                    this.upload(req.method, req.baseUrl, req.callback, req.params, req.data, req.config);
                } else {
                    this.request(req.method, req.baseUrl, req.callback, req.params, true);
                }
            },

            /**
             * Search from lookup table, see if there is a cahced request has the same parameters.
             * @param params
             * @private
             */
            _searchForCacheRequest: function _searchForCacheRequest(params) {
                var i;
                for (i in this.lookup) {
                    if (mstrmojo.hash.equals(params, this.lookup[i].params)) {
                        return this.lookup[i];
                    }
                }
                return null;
            },

            hasRequests: function hasRequests() {
                return this.requestCount > 0 || mstrmojo.jsonp.hasRequests();
            }
        }
    );

    mstrmojo.xhr = new mstrmojo.QueuedXHR();

    /**
     * A Singleton class which is able to send HTTP requests to web server on the different domain.
     * The basic idea is dynamic script insertion. The content of the script is a piece of code that invokes
     * mstrmojo.jsonp.onsuccess or mstrmojo.jsonp.onfailure on the JSON data.
     *
     * Usage: Previously, we used ResourceFeedController as the solution for cross web server request. And we
     * did this by calling mstrmojo.xhr.request with the parameter "webSvrUrl" that indicates the remote web server url.
     * Now, we are trying to introduce JSONP without changing this interface. So in the mstrmojo.xhr.request, we
     * check the existence of "webSvrUrl", if presented, it will delegate to mstrmojo.jsonp.request method.
     *
     * TODO: We are not queueing the JSONP request now. Please be careful when dealing with multiple JSONP requests as it may cause racing conditions.
     */
    mstrmojo.jsonp = {
        jsc: new Date().getTime(),

        /**
         * The number of milliseconds to wait after the request is sent out.
         *
         * @type {int}
         */
        timeToWait: 20000,

        requestCount: 0,

        /**
         * <p>Send out a jsonp request</p>
         *
         * @param {string} url The target web server address
         * @param {Object} params A hash of parameter names/values
         * @param {Object} callback Object that contains three callback methods: success, failure, timeout(optional)
         */
        request: function (url, params, callback) {
            var head = document.getElementsByTagName("head")[0] || document.documentElement,
                jsonp = 'jsonp' + (this.jsc++),
                script = document.createElement("script");

            params.jsonp = jsonp + "(@R@);"; //@R@ is the placeholder for the JSON object
            params.taskContentType = 'jsonp';
            params.taskEnv = 'jsonp';
            params.xts = new Date().getTime();

            //This function will be executed automatically when the script is loaded.
            window[jsonp] = function (response) {
                mstrmojo.jsonp.requestCount--;
                if (!response) { // request timeout
                    if (callback.timeout) {
                        callback.timeout();
                    }
                } else if (response.status === 200) { //request succeeded
                    callback.success(response.content);
                } else { //request failed
                    //As we reuse mstrmojo.xhr.request to send a JSONP request, we use getResponseHeader quite often
                    //in the xhr failure callback. It's better to have this method as well so that we don't need to
                    //change the existing app code.
                    var res = {
                        status: response.status,
                        getResponseHeader: function (name) {
                            switch (name) {
                            case 'X-MSTR-TaskFailureMsg':
                                return response.errorMsg;
                            case 'X-MSTR-TaskErrorCode':
                                return response.errorCode;
                            }
                        }
                    };
                    if (mstrApp.onSessionExpired && isSessionExpiredError(res)) {
                        if (callback.onSessionExpired) {
                            callback.onSessionExpired();
                        }else{
                        mstrApp.onSessionExpired();
                        }
                    } else {
                        callback.failure(res);
                    }
                }

                // Do some cleanup
                if (window[jsonp]) {
                    if (callback.complete) {
                        callback.complete();
                    }
                    //delete the global variable
                    window[jsonp] = undefined;
                    try {
                        delete window[jsonp];
                    } catch (e) {
                    }

                    //remove the script node
                    head.removeChild(script);
                }
            };

            head.insertBefore(script, head.firstChild);
            this.requestCount++;
            script.src = appendUrlParams("GET", url, params); // This will trigger a HTTP POST request to the target web server

            //If the script is not loaded or evaluated successfully, it will fail silently.
            //We need to handle this case by waiting for a reasonable amount of time(10s).
            setTimeout(function () {
                var fn = window[jsonp];
                if (fn) {
                    fn();
                }
            }, this.timeToWait);
        },

        hasRequests: function () {
            return this.requestCount > 0;
        }
    };
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.dom",
        "mstrmojo.array",
        "mstrmojo.string");

    var $D = mstrmojo.dom,
        $S = mstrmojo.string,
        $A = mstrmojo.array;

    /**
     * A utility class for browser sniffing.
     *
     * @namespace mstrmojo.css
     */
    mstrmojo.css = mstrmojo.provide(
        "mstrmojo.css",

        /**
         * @lends mstrmojo.css
         */
        {

            /**
             * The browser appropriate display property for a table.
             *
             * @type {string}
             * @constant
             */
            DISPLAY_TABLE: $D.isNSIE ? 'block' : 'table',

            /**
             * The browser appropriate display property for a table cell.
             *
             * @type {string}
             * @constant
             */
            DISPLAY_CELL: $D.isNSIE ? 'block' : 'table-cell',

            /**
             * The browser appropriate property for min-height.
             *
             * @type {string}
             * @constant
             */
            MINHEIGHT: $D.isIE6 ? 'height' : 'minHeight',

            /**
             * <p>Adds one or more of class names to the class name attribute of the supplied element.</p>
             *
             * <p>If the class name is already present, it will ignore it.</p>
             *
             * @param {HTMLElement|Node} el The element to receive the classes.
             * @param {string|string[]} s Array of one or more classes to add.
             *
             * @returns {HTMLElement|Node} The modified node.
             */
            addClass: function addClass(el, s) {
                if (el) {
                    if (s.constructor !== Array) {
                        s = [ s ];
                    }
                    var cls = el.className || '',
                        start = ' ' + cls + ' ',
                        bAdded = false,
                        len = s.length,
                        i;

                    for (i = 0; i < len; i++) {
                        var c = s[i];
                        if (!start.match(new RegExp("\\s" + c + "\\s"))) {
                            cls += ' ' + c;
                            bAdded = true;
                        }
                    }

                    if (bAdded) {
                        el.className = $S.trim(cls);
                    }
                }

                return el;
            },

            /**
             * <p>Removes one or more class names from the class name attribute of the supplied element.</p>
             *
             * <p>If the class name is not present, it will ignore it.</p>
             *
             * @param {HTMLElement|Node} el The element whose class name is to be edited.
             * @param {string|string[]|RegExp|RegExp[]} s Array of one or more classes to remove.
             */
            removeClass: function removeClass(el, s) {
                if (!el) {
                    return;
                }

                if (s.constructor !== Array) {
                    s = [ s ];
                }
                var cls = ' ' + (el.className || '') + ' ',
                    len = s.length,
                    i;

                for (i = 0; i < len; i++) {
                    cls = cls.replace(new RegExp("\\s" + s[i] + "\\s", "g"), " ");
                }
                el.className = $S.trim(cls);
            },

            /**
             * <p>Adds classes to the space delimited {@link mstrmojo.Widget.cssClass} property.</p>
             *
             * <p><strong>NOTE:</strong> This is only effective before rendering.  After rendering the {@link mstrmojo.css.addClass} method should be used.</p>
             *
             * @param {mstrmojo.Widget} widget The widget whose cssClass property should be changed.
             * @param {string|string[]} classes An array of css class names to add (will also work with a single class name).
             */
            addWidgetCssClass: function addWidgetCssClass(widget, classes) {
                // Split original class names into an array.
                var origClasses = widget.cssClass,
                    existing = (origClasses && origClasses.split(' ')) || [],
                    i;

                // Ensure classes is an array.
                classes = [].concat(classes);

                // Check if the new classes already exist.
                for (i = 0; i < classes.length; i++) {
                    var cls = classes[i];

                    // Does the class already exist in the existing classes collection ?
                    if ($A.indexOf(existing, cls) === -1) {
                        existing.push(cls);
                    }
                }

                // Reset cssClass property to new collection of classes.
                widget.cssClass = existing.join(' ');
            },

            /**
             * <p>Removes classes from the space delimited {@link mstrmojo.Widget.cssClass} property.</p>
             *
             * <p><strong>NOTE:</strong> This is only effective before rendering.  After rendering the
             * {@link mstrmojo.css.removeClass} method should be used.</p>
             *
             * @param {mstrmojo.Widget} widget The widget whose cssClass property should be changed.
             * @param {string|string[]} classes An array of css class names to add (will also work with a single class name).
             */
            removeWidgetCssClass: function removeWidgetCssClass(widget, classes) {
                // Split original class names into an array.
                var origClasses = widget.cssClass,
                    existing = (origClasses && origClasses.split(' ')) || [],
                    i;

                // Ensure classes is an array.
                classes = [].concat(classes);

                // Check if the new classes already exist.
                for (i = 0; i < classes.length; i++) {
                    var cls = classes[i];

                    // Does the class already exist in the existing classes collection ?
                    var classIndex = $A.indexOf(existing, cls);

                    // Does the class exist ?
                    if (classIndex !== -1) {
                        // Remove the class from the css class collection.
                        existing.splice(classIndex, 1);
                    }
                }

                // Reset cssClass property to new collection of classes.
                widget.cssClass = existing.join(' ');
            },

            /**
             * <p>Adds (or removes) one or more class names from the class name attribute of the supplied element.</p>
             *
             * <p>If the class name is not present, it will ignore it.</p>
             *
             * @param {HTMLElement|Node} el The element whose class name is to be edited.
             * @param {string|string[]} s Array of one or more classes to remove.
             * @param {boolean} b True if the class names should be added.
             */
            toggleClass: function toggleClass(el, s, b) {
                if (b) {
                    this.addClass(el, s);
                } else {
                    this.removeClass(el, s);
                }
            },

            /**
             * <p>Check if the class name is present in the class name attribute of the supplied element.</p>
             *
             * @param {HTMLElement|Node} el The element whose class name is to be checked.
             * @param {string} c The class to be checked
             *
             * @returns {boolean}
             */
            hasClass: function hasClass(el, c) {
                if (el) {
                    var cls = ' ' + (el.className || '') + ' ';

                    return !!cls.match(new RegExp("\\s" + c + "\\s"));
                }

                return false;
            },

            /**
             * Applies a drop shadow to the supplied element.
             *
             * @param {HTMLElement} el The HTMLElement that will receive the drop shadow.
             * @param {int} xOff The offset x value for the drop shadow.
             * @param {int} yOff The offset y value for the drop shadow.
             * @param {int} spread The spread value for the drop shadow (does not apply to IE).
             * @param {string} color The hexidecimal color value for the drop shadow (must be full 7 digits for IE).
             */
            applyShadow: function applyShadow(el, xOff, yOff, spread, color) {
                var s = el.style;
                if ($D.isDXIE) {
                    s.filter += "progid:DXImageTransform.Microsoft.dropshadow(OffX=" + xOff + "px, OffY=" + yOff + "px, Color='" + color + "')";
                } else if ($D.isFF || $D.isWK || $D.isIE10) {
                    s[$D.CSS3_BOXSHADOW] = xOff + 'px ' + yOff + 'px ' + spread + 'px ' + color;
                }
            },

            /**
             * Removes any drop shadow from the supplied element.
             *
             * @param {HTMLElement} el The HTMLElement whose drop shadow should be removed.
             */
            removeShadow: function removeShadow(el) {
                var s = el.style;
                //                if ($D.isIE) {
                //                    s.filter += "progid:DXImageTransform.Microsoft.dropshadow(OffX=" + xOff + "px, OffY=" + yOff + "px, Color='" + color + "')";
                if ($D.isFF || $D.isWK || $D.isIE10) {
                    s[$D.CSS3_BOXSHADOW] = '';
                }
            },

            /**
             * Set opacity value on the given element.
             * NOTE: This method is originated from <code>getFilter</code> and <code>setFilter</code> method in DHTML.js.
             *
             * @param {HTMLElement} el The target HTMLElement to apply the opacity on.
             * @param {int} val of opacity(between 0 and 100)
             */
            setOpacity: function setOpacity(el, val) {
                if ($D.isDXIE && !$D.isIE9) {
                    var filterText = el.currentStyle.filter;
                    var filter = null;
                    if (filterText.length > 0) {
                        filter = el.filters['DXImageTransform.Microsoft.Alpha'];
                    }

                    if (filter) {
                        filter.opacity = val;
                        filter.enabled = (val !== 100);
                    } else if (val < 100) {
                        var filterDefinition = 'progid:DXImageTransform.Microsoft.Alpha(Opacity=' + val + ')';
                        el.style.filter = (filterText || "") + " " + filterDefinition;
                    }
                } else {
                    // TODO: Add validation for IE10??
                    el.style.opacity = val / 100 - ($D.isIE9 ? 0.00001 : 0);
                }
            },

            /**
             * Builds an object with the browser specific property css name and value for a gradient.
             *
             * @param {int} t The type of gradient (0 = vertical, 1 = horizontal).
             * @param {string} sc The start color.
             * @param {string} ec The end color.
             *
             * @returns {Object}
             */
            buildGradient: function buildGradient(t, sc, ec) {
                if ($D.supports($D.cssFeatures.GRADIENTS)) {
                    var rtn = {};

                    if ($D.isDXIE) {
                        rtn.n = 'filter';
                        rtn.v = "progid:DXImageTransform.Microsoft.Gradient(GradientType=" + t + ",StartColorStr='" + sc + "',EndColorStr='" + ec + "')";

                    } else if ($D.isFF) {
                        rtn.n = 'background-image';
                        rtn.v = '-moz-linear-gradient(' + ((t === 0) ? 'top' : 'left') + ',' + sc + ',' + ec + ')';

                    } else if ($D.isWK) {
                        rtn.n = 'background';
                        rtn.v = '-webkit-gradient(linear,' + ((t === 0) ? 'left top, left bottom' : 'left top, right top') + ',from(' + sc + '),to(' + ec + '))';
                    } else if ($D.isIE10 || $D.isIEW3C) {
                        rtn.n = 'background';
                        rtn.v = 'linear-gradient(' + ((t === 0) ? 'to bottom' : 'to right') + ',' + sc + ',' + ec + ')';
                    }
                    return rtn;
                }

                return null;
            },

            /**
             * Returns a String of browser specific css for rounded corners.
             *
             * @param {int} r The single radius value for all borders.
             * @param {boolean} t True if the top corners are the only rounded corners.
             *
             * @returns {string}
             */
            buildRoundCorners: function buildRoundCorners(r, t) {
                if ($D.supports($D.cssFeatures.ROUND_CORNERS)) {
                    var v = r + 'px';
                    var radiusValue = v + (t ? ' ' + v + ' 0 0' : '') + ';';

                    if ($D.isFF || $D.isWinPhone || $D.isIE10) {
                        return 'border-radius:' + radiusValue;
                    }

                    if ($D.isWK) {
                        // Are all four corners the same?
                        if (!t) {
                            // Send one value.
                            return '-webkit-border-radius:' + v + ';';
                        }

                        // Otherwise, send four separate values.
                        var ds = ['left', 'right'],
                            css = [],
                            x = -1,
                            i;

                        for (i = 0; i < 2; i++) {
                            css[++x] = '-webkit-border-top-' + ds[i] + '-radius:' + v;    // Top is rounded.
                            css[++x] = '-webkit-border-bottom-' + ds[i] + '-radius:0';    // Bottom is not.
                        }

                        return css.join(';');
                    }
                }

                return '';
            },

            /**
             * Converts a css "border-width" or "padding" value to an object with individual border width or padding values in pixels.
             * "border-width" and "padding" have the same format so deal with them the same
             *
             * @param {string} b The value of the "border-width" or "padding" css property which may have 4, 3, 2 or 1 individual border widths or paddings.
             * @param {int} dpi The users DPI settings value.
             *
             * @returns {Object} An object with 't' (top), 'r' (right), 'b' (bottom), 'l' (left), 'h' (top  + bottom) and 'w' (left + right) properties which contain the
             *  individual border widths or paddings (in pixels) for the supplied border-width or padding value.
             */
            getBorderWidthsOrPaddings: function getBorderWidthsOrPaddings(b, dpi) {
                // Create empty borders object.
                var o = {
                    t: 0,
                    r: 0,
                    b: 0,
                    l: 0,
                    h: 0,
                    w: 0
                };

                // Is b undefined or empty?
                if (!b) {
                    return o;
                }

                // Split border value into components.
                var a = b.split(' '),
                    len = a.length,
                    i;

                // Convert point values to pixels.
                for (i = 0; i < len; i++) {
                    a[i] = Math.round(dpi * parseFloat(a[i]) / 72);
                }

                // Normalize the components array so there are always four border width values.
                if (len < 4) {
                    // Is there only one value?
                    if (len === 1) {
                        // Add three duplicated values for right, bottom and left.
                        a[1] = a[2] = a[3] = a[0];
                    } else {
                        // Must be 2 or 3 so left border will match right border.
                        a[3] = a[1];
                        // Are there only two values?
                        if (len === 2) {
                            // Bottom border will match top border.
                            a[2] = a[0];
                        }
                    }
                }

                // Configure and return borders object.
                o.t = a[0];
                o.r = a[1];
                o.b = a[2];
                o.l = a[3];
                o.h = o.t + o.b;
                o.w = o.l + o.r;

                return o;
            },

            /**
             * Refer to getBorderWidthsOrPaddings
             */
            getBorderWidths: function getBorderWidths(p, dpi) {
                return this.getBorderWidthsOrPaddings(p, dpi);
            },

            /**
             * Refer to getBorderWidthsOrPaddings
             */
            getPaddings: function getPaddings(p, dpi) {
                return this.getBorderWidthsOrPaddings(p, dpi);
            },

            /**
             * <p>Parks an element to the left of the viewport after it fades out.</p>
             *
             * @param {Event} evt An event with a "target" property that points to the element that has faded.
             *
             * @returns {boolean} True if the element was parked.
             */
            parkAfterFade: function parkAfterFade(evt) {
                // Get the style of the element.
                var elStyle = evt.target.style;

                // Is the element hidden?
                if (elStyle.opacity === 0) {
                    // Park the element off to the left of the viewport so it doesn't mask touch events.
                    elStyle.left = '-10000px';

                    // Restore the opacity after a timeout. (Bugfix - in iPhone we see 2 flashes because
                    //the opacity changes before the mask has been parked
                    window.setTimeout(function () {
                        elStyle.opacity = 0.99;
                    }, 0);

                    // Return true to indicate that the element was parked.
                    return true;
                }

                // Return false to indicate that the element was NOT parked.
                return false;
            },

            /**
             * Returns computed style property value for specified CSS property, like 'height', etc.
             *
             * @param {HTMLElement} el The html element
             * @param {string} prop The css property name
             *
             * @returns {string}
             */
            getStyleValue: function getStyleValue(el, prop) {
                var propIsFloat = (prop === 'float'),
                    value;

                if (el.currentStyle) { //IE
                    prop = propIsFloat ? 'styleFloat' : prop;
                    value = el.currentStyle[prop];

                } else if (document.defaultView && document.defaultView.getComputedStyle) { //FF
                    prop = propIsFloat ? 'cssFloat' : prop;
                    var styles = document.defaultView.getComputedStyle(el, null);
                    value = styles ? styles[prop] : null;
                }

                return value;
            },

            /**
             * <p>Returns the computed style of current element.</p>
             *
             * <p>To use, call this method to retrieve the elements style, then query the result for individual properties.</p>
             *
             * <pre>
             *     var computedStyle = mstrmojo.css.getComputedStyle(elem),
             *         color = cs.color,
             *         vis = cs.visibility;
             * </pre>
             *
             * @param {HTMLElement} element The HTMLElement for which to get the computed style.
             * @param {string} [pseudoElement] An optional string specifying the pseudo-element to match.  Must be omitted for regular elements.
             *
             * @returns {CSSStyleDeclaration}
             */
            getComputedStyle: function getComputedStyle(element, pseudoElement) {
                var fn = (window.getComputedStyle) ? function (element, pseudoElement) {
                        return window.getComputedStyle(element, pseudoElement || null);
                    } : function (element) {
                        return element.currentStyle || {};
                    };

                mstrmojo.css.getComputedStyle = fn;

                return fn(element, pseudoElement);
            },

            /**
             * Converts an object with css property names and css property values to a CSS text string.
             *
             * @param {Object.<string, string>} obj The CSS object.
             *
             * @returns {string}
             */
            getCssTextFromObj: function getCssTextFromObj(obj) {
                var s = '',
                    k;

                // Iterate object.
                for (k in obj) {
                    // Add css name/property to return string.
                    s += k + ':' + obj[k] + ';';
                }

                // Return result.
                return s;
            },

            /**
             * Callback a function after a transition is done, if transitions are not supported by the browser the function is called asynchronously
             *
             * @param {HTMLElement} el The HTMLElement for which to listen for the transition end.
             * @param {Function} cb callback to be executed
             */
            onTransitionEnd: function onTransitionEnd(el, cb) {
                var t = "transition",
                    modernizr = window.Modernizr;

                //Check if transitions are supported
                if (modernizr.testProp(t)) {
                    // Attach one time event listener to hear when event happens
                    $D.attachOneTimeEvent(el, $D.transEndEvtNames[modernizr.prefixed(t)], cb);
                } else {
                    //browser doesn't support animations so just callback
                    window.setTimeout(cb, 0);
                }
            },

            /**
             *Callback a function after an animation is done, if animations are not supported by the browser the function is called asynchronously
             * @param el{HTMLElement} el The HTMLElement for which to listen for the animation end.
             * @param {Function} cb callback to be executed
             */
            onAnimationEnd: function onAnimationEnd(el, cb) {
                var t = "animation",
                    modernizr = window.Modernizr;

                //Check if transitions are supported
                if (modernizr.testProp(t)) {
                    // Attach one time event listener to hear when event happens
                    $D.attachEvent(el, $D.animationEndEvtNames[modernizr.prefixed(t)], cb);
                } else {
                    //browser doesn't support animations so just callback
                    window.setTimeout(cb, 0);
                }
            },

            /**
             * <p>Applies one or more css classes on the given DOM element for a given duration and then removes it.</p>
             *
             * @param {HTMLElement|Node} el The element whose class name is to be edited.
             * @param {String|String[]} cls Array of one or more classes to add or remove.
             * @param {int} duration The duration for which we need to flash the class(es)
             */
            flashClass: function flashClass(el, cls, duration) {
                this.toggleClass(el, cls, true);

                var $DOM = this;
                window.setTimeout(function () {
                    $DOM.toggleClass(el, cls, false);
                }, duration);
            },

            /**
             * Converts the passed hyphen delimited CSS style string (e.g., background-color) to it's corresponding camelCase version (e.g., backgroundColor).
             *
             * @param {String} cssName The string to convert.
             *
             * @returns {String}
             */
            convertCssToCamelCase: function convertCssToCamelCase(cssName) {
                return cssName.replace(/\-([a-z])/gi, function (match, hyphenated) {
                    return hyphenated.toUpperCase();
                });
            },

            /**
             * Debug function that loops through all the stylesheets prints the rules and the selectors displayed in it.
             *
             * @param {String=} fileName An optional file name to limit the output to a single file's information.
             * @ignore
             */
            printCSSInfo: function printCSSInfo(fileName) {
                var styleSheets = document.styleSheets,
                    totalStyleSheets = styleSheets.length,
                    j,
                    i;

                // Loop through all the stylesheets defined on the page.
                for (i = 0; i < totalStyleSheets; i++) {
                    var styleSheet = styleSheets[i],
                        rules = styleSheet.cssRules,
                        totalRulesInStylesheet = rules ? rules.length : 0,
                        totalSelectorsInStylesheet = 0;

                    // Find all the selectors defined within the rules.
                    for (j = 0; j < totalRulesInStylesheet; j++) {
                        var selectorText = rules[j].selectorText;

                        // Do we have a selector text ?
                        if (selectorText) {
                            try {
                                totalSelectorsInStylesheet += selectorText.split(',').length;
                            } catch (err) {
                                // Fail silently.
                            }
                        }
                    }

                    // Grab the link of the stylesheet.
                    var cssFileName = styleSheet.href;

                    // Do we not have any filenames provided or if it is provided, is it the one we care about ?
                    if (!fileName || (cssFileName && cssFileName.indexOf(fileName) > -1)) {
                        // Print the stylesheet link, if it doesn't exist, very likely it's an inline CSS block.
                        console.log("Stylesheet: " + cssFileName || "Inline CSS Block");

                        // Next - print the rules and number of selectors in the given stylesheet.
                        console.log("Total rules: " + totalRulesInStylesheet);
                        console.log("Total selectors: " + totalSelectorsInStylesheet);
                    }
                }
            },

            /*
            Copyright Mathias Bynens <https://mathiasbynens.be/>

            Permission is hereby granted, free of charge, to any person obtaining
            a copy of this software and associated documentation files (the
            "Software"), to deal in the Software without restriction, including
            without limitation the rights to use, copy, modify, merge, publish,
            distribute, sublicense, and/or sell copies of the Software, and to
            permit persons to whom the Software is furnished to do so, subject to
            the following conditions:

            The above copyright notice and this permission notice shall be
            included in all copies or substantial portions of the Software.

            THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
            EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
            NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
            LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
            OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
            WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
             */
            cssEscape: function cssEscape(value) {
                if (arguments.length === 0) {
                    throw new TypeError('`CSS.escape` requires an argument.');
                }
                var string = String(value),
                    length = string.length,
                    index = -1,
                    codeUnit,
                    result = '',
                    firstCodeUnit = string.charCodeAt(0);
                while (++index < length) {
                    codeUnit = string.charCodeAt(index);
                    if (codeUnit == 0x0000) {
                        result += '\uFFFD';
                        continue;
                    }
                    if (
                        (codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
                        (index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||

                        (
                            index == 1 &&
                            codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
                            firstCodeUnit == 0x002D
                        )
                    ) {
                        // https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
                        result += '\\' + codeUnit.toString(16) + ' ';
                        continue;
                    }
                    if (
                        // If the character is the first character and is a `-` (U+002D), and
                    // there is no second character, […]
                    index == 0 &&
                    length == 1 &&
                    codeUnit == 0x002D
                    ) {
                        result += '\\' + string.charAt(index);
                        continue;
                    }
                    if (
                        codeUnit >= 0x0080 ||
                        codeUnit == 0x002D ||
                        codeUnit == 0x005F ||
                        codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
                        codeUnit >= 0x0041 && codeUnit <= 0x005A ||
                        codeUnit >= 0x0061 && codeUnit <= 0x007A
                    ) {
                        // the character itself
                        result += string.charAt(index);
                        continue;
                    }
                    result += '\\' + string.charAt(index);
                }
                return result;
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.string",
                         "mstrmojo.dom",
                         "mstrmojo.hash");

    var $STRING = mstrmojo.string,
        $HASH = mstrmojo.hash,
        $DOM = mstrmojo.dom;

    /**
     * An orphaned DOM element used for creating other elements.
     * @private
     * @static
     * @todo Need to add code to set creationElement to null when window unloads.
     */
    var creationElement = mstrmojo.usesFrames ? null : document.createElement('span');

    var REG_EXP_EVENTS = /mstrAttach:([\w,]+)/g;

    /**
     * <p>Used to determine if mouse event handlers should be rendered and if click event handlers should be replaced with touch start event handlers.</p>
     *
     * @default undefined If undefined at run time this value will be calculated (and then cached for performance).
     * @private
     */
    var isTouchEnabled;

    /**
     * Replaces tokens for event handlers in a given markupString with actual
     * event handler markup.
     *
     * @param {String} s The HTML template string with event handler tokens.
     *
     * @returns {String} The HTML string with replaced event handler tokens.
     * @private
     */
    function replaceEvtTokens(s, widget) {
        // Have we NOT calculated the isTouchEnabled flag?
        if (isTouchEnabled === undefined) {
            // Ask the Application if it is touch enabled (default to false if no application is found).
            isTouchEnabled = (mstrApp !== undefined && mstrApp.isTouchApp && mstrApp.isTouchApp()) || false;
        }

        return s.replace(REG_EXP_EVENTS, function hRepl(token, es) {
            var arr = es.split(","),
                out = [],
                len = arr.length,
                i;

            for (i = 0; i < len; i++) {
                var e = arr[i];
                if (e) {
                    // Is touch enabled for the application.
                    if (isTouchEnabled) {
                        // Is this a mouse event?
                        if (e.indexOf('mouse') > -1) {
                            // Ignore this event because touch has no equivalent.
                            continue;

                        // Is this a click event?
                        } else if (e === 'click') {
                            // Replace click with touchstart.
                            e = 'touchend';
                        }
                    }

                    // Add event handling markup.
                    out.push('on' + e + '="mstrmojo.dom.captureDomEvent(\'{@id}\',\'' + e + '\', self, event)"');
                }
            }
            return out.join(" ");
        });
    }

    var PRE = 'preBuildRendering',
        BUILD = 'buildRendering',
        POST = 'postBuildRendering';

    /**
     * <p>Creates a DOM node (and its descendants) for a given widget from its "markupString" property.</p>
     *
     * <p>The method accomplishes this by creating a (temporary) &lt;span&gt; container, setting its innerHTML,
     * then removing the resulting firstChild from the &lt;span&gt; container.  The innerHTML is set to the
     * Widget's markup string after some modifications (tokens representing dynamic values in HTML are replaced
     * with actual values).</p>
     *
     * @param {Object} widget The widget whose DOM will be built.
     * @returns {HTMLElement|Node} The newly created HTMLElement.
     * @private
     */
    function buildDomNode(widget) {

        var s = widget.markupString;
        // Does the markupString template have abbreviated event handler tokens ("mstrAttach")?
        if (s.match(/mstrAttach:/)) {
            // Yes, replace those tokens with unabbreviated markup.
            s = replaceEvtTokens(s, widget);
            // Optimization: If the template is used for all class instances...
            if (widget.markupString === widget.constructor.prototype.markupString) {
                // ...update the template for all instances.
                widget.constructor.prototype.markupString = s;
            }
        }
        var html = $STRING.apply(s, widget);
        if (html) {

            //hasContextMenuEvent is a flag for whether current object has attached contextmenu event, for taphold.js to trigger contextmenu event
            if (html.indexOf('oncontextmenu') > -1) {
                widget.hasContextMenuEvent = true;
            }

            if (mstrmojo.usesFrames) {
                // Optimization: only do doc-check if our app is using frames.
                // Otherwise, assume there is only one global doc object for this code's lifespan.
                var doc = (widget.domNode && widget.domNode.ownerDocument) || window.document;
                if (!creationElement || creationElement.ownerDocument !== doc) {
                    creationElement = doc.createElement('span');
                }
            }
            creationElement.innerHTML = html;
            var d = creationElement.removeChild(creationElement.firstChild);
            // Drag-drop manager assumes ever widget.domNode has an mstrmojoId expando property.
            d.mstrmojoId = widget.id;
            return d;
        }
        return null;
    }

    /**
     * Calls the given widget's "markupSlots" methods to retrieve the slot nodes for that widget.
     *
     * @param {mstrmojo._HasMarkup} widget The widget.
     *
     * @returns {Object.<string, Node>} A hash (Object) of slot nodes, keyed by slot name.
     * @private
     */
    function callSlots(widget) {
        // Walk the collection of slot setter functions.
        var ms = widget.markupSlots,
            nodes,
            n;

        if (ms) {
            nodes = {};
            for (n in ms) {
                nodes[n] = ms[n].call(widget);
            }
        }
        return nodes;
    }

    /**
     * A mixin for classes that will be represented with markup in the page.
     *
     * @mixin
     * @public
     */
    mstrmojo._HasMarkup = mstrmojo.provide(
        "mstrmojo._HasMarkup",

        /**
         * @lends mstrmojo._HasMarkup.prototype
         */
        {
            /**
             * String template that specifies the HTML for this Widget's GUI.
             * @type {String}
             */
            markupString: null,

            /**
             * <p>Optional hash of methods that will be fired in response to specific events in this widget.</p>
             *
             * <p>This hash is used for reflecting the widget's state in its markup.  The hash is keyed by the events
             * to be monitored (e.g., "on&lt;eventName&gt;"). The hash values are each a Function that will be executed
             * when that event occurs.</p>
             *
             * <p>When a widget is first rendered, all of its markupMethods are called immediately, to initialize its DOM.</p>
             *
             * <p>One exception is the reserved key "sequence". That optional key's value is an array of key names.
             * This array lists the order in which these markupMethods should be fired. If missing, the order is arbitrary.</p>
             *
             * @type {Object}
             */
            markupMethods: null,

            /**
             * <p>A hash of functions that will return the node for the key from within this widget's markup.</p>
             *
             * @type {Object.<string, Function>}
             */
            markupSlots: null,

            onRender: mstrmojo.emptyFn,

            onUnRender: mstrmojo.emptyFn,

            /**
             * <p>Manages the rendering of this widget's domNode.</p>
             *
             * <p>The method calls "buildRendering", as well as calls to optional "preBuildRendering" and "postBuildRendering" hooks
             * for customization. If any method returns exactly false, aborts the rendering.</p>
             *
             * @return {Boolean} True if the rendering changed.
             */
            render: function render() {
                if ((this[PRE] && this[PRE]() === false) || (this[BUILD]() === false) || (this[POST] && this[POST]() === false)) {
                    return false;
                }

                this.hasRendered = !!this.domNode;

                this.onRender();

                // Is anybody listening for the hasRendered event?
                var evtName = 'renderComplete';
                if (mstrmojo.publisher.hasSubs(this.id, evtName)) {
                    // Raise the event.
                    this.raiseEvent({
                        name: evtName
                    });
                }

                return true;
            },


            buildDom: function buildDom() {
                return buildDomNode(this);
            },

            /**
             * Called after the domNode is generated.
             *
             * @type {Function}
             */
            postBuildDom: null,

            /**
             * Called before the domNode is rendered.
             *
             * @type {Function}
             */
            preBuildRendering: mstrmojo.emptyFn,

            /**
             * <p>Builds and sets this.domNode.</p>
             *
             * <p>This method will build this.domNode by applying the HTML markup string in this
             * instance's "markupString" property.</p>
             *
             * @return {Boolean} True.
             */
            buildRendering: function buildRendering() {

                // Build a new DOM node according to this Widget's markupString.
                var dnWas = this.domNode,
                    dn = this.buildDom();

                this.domNode = dn;

                // Hook for customizations immediately after markup generation.
                if (this.postBuildDom) {
                    this.postBuildDom();
                }

                // Clear any old slots from previous renderings.
                if (this.slotNames) {
                    this.removeSlots(this.slotNames);
                }
                // Call all the "markupSlots" getters and record the slots found.
                this.addSlots(callSlots(this));

                // Call all the "markupMethods", to initial state of this Widget's DOM.
                this.paint();

                // Now that the DOM is ready, we can place it in the HTML page.
                if (dn) {
                    // Our placeholder is either the previous "domNode"...
                    var ph = dnWas;
                    if (!ph) {
                        // ..or if we don't have a previous "domNode", use the "placeholder" property.
                        ph = this.placeholder;
                        if (ph) {
                            // If its a string, assume its a node's id.
                            if (typeof ph === 'string') {
                                ph = document.getElementById(ph);
                            }
                            // Clear the placeholder property after it's been used one time.
                            delete this.placeholder;
                        }
                    }
                    if (ph) {
                        $DOM.replace(ph, dn);
                    }
                }

                // Optimization: Notify your parent (if any) directly that your domNode has
                // changed.  This used to be done indirectly by having the Container parent
                // listen for the "domNodeChange" event but that leads to thousands of events
                // being raised on page load.
                var fn = "onchildRenderingChange",
                    p = this.parent;
                if (p && p[fn]) {
                    p[fn](this);
                }

                return true;
            },

            /**
             * Called after the domNode is rendered.
             *
             * @type {Function}
             */
            postBuildRendering: mstrmojo.emptyFn,

            /**
             * <p>Removes this widget's domNode from the document, resets the widget's "domNode" property to null,
             * clears all of its slots (if any), and resets its "hasRendered" to false.</p>
             *
             * <p>If this widget's hasRendered is false, this method does nothing.</p>
             *
             * @param {Boolean} ignoreDom If true we don't need to remove the domNode from the document (meaning, it's being handled
             * by a parent or ancestor).
             */
            unrender: function unrender(ignoreDom) {
                // If the element is in the DOM then we need to remove it.
                if (this.hasRendered) {
                    if (!ignoreDom) {
                        try {
                            var dn = this.domNode;
                            // if the node has a parent then remove it
                            if (dn.parentNode) {
                                dn.parentNode.removeChild(dn);
                            }
                            // if we are running in IE, wipe out the outerHTML to force IE to release memory
                            if (mstrmojo.dom.isIE && dn.outerHTML !== "undefined") {
                                dn.outerHTML = "";
                            }
                        } catch (ex) {
                          //swallow
                        }
                    }
                    this.domNode = null;
                    this.removeSlots(this.slotNames);
                    this.hasRendered = false;

                    this.onUnRender();
                }
            },

            /**
             * <p>Executes all the given widget's markupMethods to initialize state of the widget's DOM.</p>
             *
             * <p>Typically the markupMethods are called in batch only once per rendering, immediately after the widget's domNode
             * is built. Subsequently, markupMethods are called individually in response to events as they occur.  To allow the
             * methods to distinguish between the first (batch) call and subsequent individual calls, a single optional Boolean param is
             * passed into the methods. This param is set to true only during the initial batch call.</p>
             */
            paint: function paint() {
                var ms = this.markupMethods;
                if (!ms) {
                    return;
                }
                var me = this,
                    callM = function (n) {
                        var f = ms[n];
                        if (f) {
                            try {
                                f.apply(me, [true]);
                            } catch (localErr) {
                                throw new Error([
                                    "Error in markup method.",
                                    "Script class: " + me.scriptClass,
                                    "Widget id: " + me.id,
                                    "Method name: " + n,
                                    "Err: " + localErr.message
                                ].join('\n\n'));
                            }
                        }
                    };
                var s = ms.sequence,
                    len,
                    i,
                    n;

                if (s) {
                    len = s.length || 0;
                    for (i = 0; i < len; i++) {
                        callM(s[i]);
                    }
                } else {
                    for (n in ms) {
                        callM(n);
                    }
                }
            },

            /**
             * <p>Called when a redraw of this widget is needed.</p>
             *
             * @return {boolean} true if redrawing was successful.
             * @default false
             */
            redraw: function redraw() {
                return false;
            },

            /**
             * <p>Forces a re-render of this widget.</p>
             *
             * <p>If this widget is already rendered, this method unrenders and then re renders it;
             * otherwise, does nothing.</p>
             *
             * <p>When refreshing an orphan, this method temporarily sets the previous domNode as the placeholder
             * for the next domNode, and asks the unrender not to remove that placeholder from the document.
             * This not done for children as they rely on slots rather placeholders.</p>
             *
             * @param {Function} [postUnrender] Callback to be notified after the unrender (if any) but before the re-render.
             */
            refresh: function refresh(postUnrender) {
                // Has this widget rendered already?
                if (this.hasRendered) {
                    // Ask widget to redraw.  If it doesn't explicitly return true then proceed to render again.
                    if (this.redraw() !== true) {
                        // Cache handle to the domNode even if we are a child of a container; otherwise
                        // we may lose our place within our siblings that share the same slot.
                        var ph = this.domNode;
                        // When unrendering, don't try to remove domNode from HTML; we need it to
                        // stay put so we can replace it with the new domNode after re-rendering.
                        this.unrender(true);
                        this.placeholder = ph;
                        if (postUnrender) {
                            postUnrender();
                        }
                        this.render();
                    }
                }
            },

            /**
             * <p>Extends the set() method from _Observable so that it calls the corresponding markup method for the property, thus updating the DOM.</p>
             *
             * <p>This is done regardless of whether or not an event is published corresponding to the change in property value.</p>
             *
             * <p>If a property named "<n>" is changed, the corresponding markupMethod to call is assumed to be named "on<n>Changed".</p>
             *
             * @param {String} n The name of the property whose value is to be set.
             * @param {*} v The new value.
             *
             * @returns {Object} this
             */
            set: function set(n, v) {
                // We must call the super method first to update the property value,
                // because the markup method will assume the property value has been updated.
                this._super(n, v);

                if (this.domNode) {  //was: this.hasRendered, changed it in order to fire this code in mid-rendering cycle
                    // If an event is published, ideally the markup method should be
                    // done before publishing the event to external listeners so that the DOM
                    // response is immediate, but for now that can't be done, because the
                    // superclass method already took care of the publishing.
                    var ms = this.markupMethods,
                        f = ms && ms["on" + n + "Change"];
                    if (f) {
                        f.apply(this);
                    }
                }
                return this;
            },


            /**
             * <p>A hash of names used for DOM node slots.</p>
             *
             * <p>A "slot" is a DOM node in a Widget's rendering which has some special significance. Such a node would be labeled with a special attribute in the Widget's markup string.
             * This mixin will store a reference to each such dom node as a property of this Widget; the property's name is designed by the "mstrSlot"
             * attribute of the DOM node.  This allows javascript convenient access to meaningful nodes in the DOM rendering beyond just the root "domNode".</p>
             *
             * <p>All slot label names that are found in this Widget's DOM are recorded in an internal hash so the references to those nodes can be destroyed
             * later for garbage collection.<p>
             *
             * @type {Object}
              */
            slotNames: null,

            /**
             * <p>Given a hash of DOM nodes, keyed by slot name, this method sets properties on this widget that point to the DOM nodes.</p>
             *
             * <p>Each property is named after the slot name.  Additionally, each property name is stored in the widget's internal "this.slotNames" hash for future reference.</p>
             *
             * @param {Object} slots A has of slot names to add.
             */
            addSlots: function addSlots(slots) {
                // Initialize internal hash table of slot names.
                var ns = this.slotNames,
                    n;

                if (!ns) {
                    ns = {};
                    this.slotNames = ns;
                }

                // Add each given slot to our hash tables.
                for (n in slots) {
                    this[n] = slots[n];
                    ns[n] = true;
                }
            },

            /**
             * <p>Given a hash table of slot names, removes each slot-named property value from this widget.</p>
             *
             * <p>This method also removes the given slot names from the internal hash of used slot names
             * for this widget (this.slotNames).</p>
             *
             * @param {Object} slots A hash of slot names to remove, keyed by slot name.
             */
            removeSlots: function removeSlots(slots) {
                if (slots) {
                    var sns = this.slotNames,
                        n;

                    for (n in slots) {
                        delete this[n];
                        if (sns) {
                            delete sns[n];
                        }
                    }
                }
            },

            /**
             * <p>Generic method to wire up DOM events to widget's handlers.</p>
             *
             * <p>This generic method can be called from any DOM handler in the markup.  It acts as a bridge between the
             * markup's native DOM handler and the widget's handler method for that event. This method synthesizes
             * an object representing the event, and raises that event. If DOM provides an event object, that DOM event object is
             * enclosed in the synthesized object, along with an optional config hash of params.</p>
             *
             * <p>Typical usage: a Widget subclass typically implements the preXXX & postXXX methods, but leaves the
             * onXXX method empty, to be specified by the app developer in the config of the Widget instance.</p>
             *
             * <p>Example:</p>
             * <pre>var myButton = new mstrmojo.Button({onclick: function () {alert("Hello world!")});</pre>
             *
             * @param {String} type The name of the DOM event.
             * @param {Window} hWin The DOM window in which the event originated.
             * @param {Event} [e] The DOM event object, if provided by the browser.
             * @param {Object} [config] Hash of configuration settings to be passed along to the widget handler.
             */
            captureDomEvent: function captureDomEvent(type, hWin, e, config) {
                if (this.enabled !== false) {
                    this.raiseEvent(mstrmojo._HasMarkup.newDomEvent(type, hWin, e || hWin.event, config));
                }
            },

            /**
             * <p> Method to play an effect expressed by a json object on this widget. </p>
             * TO-DO: where would be the best place to locate this?
             */
            playEffect: function playEffect(n) {
                var fx = this[n];
                if (fx && fx.constructor === Object) {
                    fx = mstrmojo.insert(mstrmojo.hash.clone(fx)); //TO-DO: do we really need to make a copy of fx first?
                    fx.widget = this;
                    this[n] = fx;
                }
                if (fx) {
                    fx.play();
                }
            }
        }
    );

    /**
     * Adds the passed markup methods to the prototype of the passed class constructor.
     *
     * @param {Object} clazz The class constructor to augment.
     * @param {Object} methods The methods to add.
     *
     * @static
     */
    mstrmojo._HasMarkup.addMarkupMethods = function addMarkupMethods(clazz, methods) {
        // Replace markup methods with an augmented copy of the original markup methods.
        clazz.prototype.markupMethods = $HASH.copy(methods, $HASH.copy(clazz.prototype.markupMethods));
    };

    /**
     * @typedef {{
     *     name: String,
     *     hWin: Window,
     *     e: MouseEvent,
     *     config: Object,
     *     ctrlKey: boolean,
     *     shiftKey: boolean,
     *     metaKey: boolean,
     *     cancel: Function,
     *     preventDefault: Function,
     *     getTarget: function():EventTarget|Node
     * }}
     *
     * @property {String} name The name of the event.
     * @property {Window} hWin The parent window of the event.
     * @property {Event} e The native Mouse Event.
     * @property {Object} [config] An optional configuration object.
     * @property {boolean} ctrlKey True if the control key is depressed.
     * @property {boolean} shiftKey True if the shift key is depressed.
     * @property {boolean} metaKey True if the meta key (mac) is depressed.
     * @property {Function} cancel Stops native event propagation.
     * @property {Function} preventDefault Prevents the native default action.
     * @property {function():EventTarget|Node} getTarget Returns the target of the event.
     */
    mstrmojo._HasMarkup.MSTRDomEventType = null;

    /**
     * Returns a new MSTR DOM event instance.
     *
     * @param {String} type The name of the DOM event.
     * @param {Window} hWin The DOM window in which the event originated.mstrAttach
     * @param {Event} winEvt The DOM event object, if provided by the browser.
     * @param {Object} [config] An optional hash of configuration settings.
     *
     * @returns {mstrmojo._HasMarkup.MSTRDomEventType}
     */
    mstrmojo._HasMarkup.newDomEvent = function (type, hWin, winEvt, config) {
        return /** @type {mstrmojo._HasMarkup.MSTRDomEventType} **/ {
            name: type,
            hWin: hWin,
            e: winEvt,
            config: config,
            ctrlKey: $DOM.ctrlKey(hWin, winEvt),
            shiftKey: $DOM.shiftKey(hWin, winEvt),
            metaKey: $DOM.isMetaKey(hWin, winEvt),

            /**
             * Cancels the event propagation.
             * @ignore
             */
            cancel: function () {
                $DOM.stopPropogation(hWin, winEvt);
            },

            /**
             * Prevents the events default behavior.
             * @ignore
             */
            preventDefault: function () {
                $DOM.preventDefault(hWin, winEvt);
            },

            /**
             * Returns the target of the event.
             *
             * @returns {EventTarget|Node}
             * @ignore
             */
            getTarget: function () {
                return $DOM.eventTarget(hWin, winEvt);
            }
        };
    };
}());
(function () {

    mstrmojo.requiresCls(
        "mstrmojo.locales",
        "mstrmojo.string",
        "mstrmojo.array"
    );

    var _L = mstrmojo.locales,
        _S = mstrmojo.string,
        _G = window.mstrConfig,
        $ARR = mstrmojo.array,
        _unit = _G.units,
        UNIT = {
            CM: 1,
            IN: 2,
            MM: 3,
            PT: 4,
            PC: 5,
            PX: 6
        },
        UNIT_SYMBOL = {
            1: 'cm',
            2: 'in',
            3: 'mm',
            4: 'pt',
            5: 'pc',
            6: 'px'
        },
        CAT = {
            DEFAULT: -2,
            FIXED: 0,
            CURR: 1,
            PERCENT: 4,
            FRACTION: 5,
            SCIENTIFIC: 6,
            GENERAL: 9
        };

    var DPI_CONVERSION = 96;

    String.prototype.reverse = function () {
        var res = "",
            i;
        for (i = this.length; i > 0; --i) {
            res += this.charAt(i - 1);
        }
        return res;
    };

    /**
     * A helper function to remove '"' from string.
     *
     * @param {String} formatMask
     * @param {Array} customStrings optional
     */
    function removeDoubleQuote(formatMask, customStrings) {

        formatMask = formatMask || '';
        customStrings = customStrings || formatMask.match(/\".+?\"/g) || [];

        for (var i = 0; i < customStrings.length; i++) {
            // TQMS900596: the replace method will consider '$$' as '$'
            formatMask = formatMask.replace(customStrings[i],
                customStrings[i].substring(1, customStrings[i].length - 1).replace(/\$/g, '$$$$'));
        }

        return formatMask;
    }

    /**
     * Convert a number to date.
     *
     * @param {Number} value
     * @returns {Date}
     */
    function convertIntToDate(value) {
        // create constant for conversion
        var millisecondsPerDay = 86400000, //1000 * 60 * 60 * 24;
            baseDate = new Date(1900, 0, 1, 0, 0, 0, 0), // excel base date for integer conversion
            datePart = Math.floor(value) - 1,
            timePart = value - datePart - 1;

        // some tweak for excel conversion bug (1900\2\29 doesn't exist)
        if (value >= 59) {
            datePart--;
        }

        // add the millisecond equivalent of the integer value to the base date to convert it
        var convertedDate = new Date(baseDate.getTime() + (datePart * millisecondsPerDay));

        convertedDate.setTime(convertedDate.getTime() + timePart * millisecondsPerDay + 500);

        return convertedDate;

    }

    /**
     * Format a date to a string based on the given mask.
     *
     * @param {Date} date
     * @param {String} formatMask
     * @returns {String}
     */
    function formatDate(date, formatMask, value) {
        var dataInfo = {
            "d+" : date.getDate(),    //day
            "h+|H" : date.getHours(),   //hour
            "s+" : date.getSeconds() //second
        },
            DATETIME = _L.datetime,
            k;

        // Format year.
        if (/(y+)/.test(formatMask)) {
            var yearStr = date.getFullYear().toString(),
                yearRegExp = RegExp.$1,
                isShortYear = yearRegExp.length === 2,
                yearLen = yearStr.length;
            formatMask = formatMask.replace(yearRegExp, yearStr.substr(isShortYear ? yearLen - 2 : 0, isShortYear ? 2 : yearLen));
        }

        if (/(^\[h\])/.test(formatMask) && value) {
            formatMask = formatMask.replace(RegExp.$1, '' + (Math.floor(value * 24)));
        }

        // Format minute in case of conflict with month.
        // DE14039: Ignore double quote around colon.
        if (/(\"?:\"?mm)/.test(formatMask)) {
            var mnt = date.getMinutes();
            //formatMask = formatMask.replace(RegExp.$1, ':' + date.getMinutes());
            formatMask = formatMask.replace(RegExp.$1, ':' + (RegExp.$1.length === 1 ? mnt : ("00" + mnt).substr(mnt.toString().length)));
        }

        // Format AM/PM.
        if (/(AM\/PM)/.test(formatMask)) {
            var hours = dataInfo['h+'],
                isPM = hours > 11;

            dataInfo['h+'] = hours - (isPM ? 12 : 0);

            formatMask = formatMask.replace(RegExp.$1, isPM ? 'PM' : 'AM');
        }

        // Format day, hour and second.
        for (k in dataInfo) {
            if (new RegExp("(" + k + ")").test(formatMask)) {
                formatMask = formatMask.replace(RegExp.$1, RegExp.$1.length === 1 ? dataInfo[k] : ("00" + dataInfo[k]).substr((dataInfo[k].toString()).length));
            }
        }

        // Format month.
        if (/(mmmm)/.test(formatMask)) {
            // Format full month name in word.
            formatMask = formatMask.replace(RegExp.$1, DATETIME.MONTHNAME_FULL[date.getMonth()]);
        } else if (/(mmm)/.test(formatMask)) {
            // Format short month name in word.
            formatMask = formatMask.replace(RegExp.$1, DATETIME.MONTHNAME_SHORT[date.getMonth()].substr(0, 3));
        } else if (/((m|M)+)/.test(formatMask)) {
            // Format other month mask.
            var month = (date.getMonth() + 1).toString();
            formatMask = formatMask.replace(RegExp.$1, RegExp.$1.length === 1 ? month : ("00" + month).substr(month.length));
        }

        // DE14039: Remove "'" in the format mask.
        return removeDoubleQuote(formatMask);
    }

    /**
     * process the right part of decimal symbol with given format and return the valid length of decimal
     *
     * @param decimalLen
     * @param pattern
     * @returns {number}
     */
    /*
    var cases = [{
            format: "#.##",
            data:   250.436,
            expect: "250.44",
        }, {
            format: "#.##",
            data:   0.43,
            expect: "0.43",
        }, {
            format: "#.#0",
            data:   250.436,
            expect: "250.44",
        }, {
            format: "#.0##",
            data:   250.436,
            expect: "250.436",
        }, {
            format: "#.0#0",
            data:   250.436,
            expect: "250.436",
        }, {
            format: "#.0#00",
            data:   250.436,
            expect: "250.4360",
        }, {
            format: "#.0#0#",
            data:   250.436,
            expect: "250.436",
        }, {
            format: "#.#0",
            data:   125,
            expect: "125.0",
        }, {
            format: "#.0###",
            data:   125,
            expect: "125.0",
        }, {
            format: "#.00#0#",
            data:   125.123,
            expect: "125.1230",
        }
    ];
     */
    function extractDP(decimalLen, pattern) {
        var i = 0,
            len = pattern.length,
            dpLen = 0;
        for (; i < len; i++) {
            if (pattern[i] === '0') {
                dpLen++;
            } else if (pattern[i] === '#') {
                if (dpLen < decimalLen) {
                    dpLen++;
                }
            } else {
                continue;
            }
        }
        return dpLen;
    }

    /**
     * A utility class that provides utility functions related to numbers, such as number parsing/formatting.
     *
     * @namespace mstrmojo.num
     */
    mstrmojo.num = mstrmojo.provide(
        "mstrmojo.num",

        /**
         * @lends mstrmojo.num
         */
        {
            /**
             * Check whether a string is an integer in current locale.
             * Note that it is different from built-in isNaN function which does not consider locale.
             * @param {string} v The string to check against.
             */
            isInt: function isInt(v) {
                var thousand = this.getThousand(),
                    INT_THOUSAND = new RegExp('^(\-)?[0-9]{1,3}(\\' + thousand + '[0-9]{3})*$'),
                    INT_NO_THOUSAND = new RegExp('^(\-)?[0-9]+$');

                return (String(v).indexOf(thousand) && INT_THOUSAND.test(v)) || INT_NO_THOUSAND.test(v);
            },

            /**
             * Check whether a string is a numeric in current locale.
             * Note that it is different from built-in isNaN function which does not consider locale.
             * @param {string} v The string to check against.
             */
            isNumeric: function isNumeric(v) {
                //TO-DO: need to consider percentage input?
                var decimal = this.getDecimal(),
                    thousand = this.getThousand(),
                    NUMERIC_THOUSAND = new RegExp('^(\-)?[0-9]{1,3}(\\' + thousand + '[0-9]{3})*(\\' + decimal + '[0-9]+)?$'),
                    NUMERIC_NO_THOUSAND = new RegExp('^(\-)?[0-9]*(\\' + decimal + ')?[0-9]+$'),
                    //DE48509 very small values in scientific notation need to be considered number too
                    NUMERIC_SCIENTIFIC = new RegExp('^(-)?[0-9]{1}(\\' + decimal + ')[1-9]+[eE]{1}[-]{0,1}[0-9]+$');

                return (String(v).indexOf(thousand) && NUMERIC_THOUSAND.test(v)) || NUMERIC_NO_THOUSAND.test(v) || NUMERIC_SCIENTIFIC.test(v);
            },

            /**
             * check whether a string is a big decimal value.
             * @param {string} v The string to check against.
             */
            isBigDecimal: function(v) {
                if (!v) return false;
                // TODO: what should be the valid decimal pattern?
                var groups = String(v).match(/^#([^#]+)#$/);
                if (!groups || groups.length <= 1) return false;
                var num = groups[1];
                return this.isNumeric(num);
            },

            /**
             * A locale-aware version of built-in parseInt function.
             * @param {string} v The string to be parsed.
             * @param {int} r The radix, if not specified, 10.
             */
            parseInteger: function parseInteger(v, r) {
                if (!this.isInt(v)) {
                    return Number.NaN;
                }
                return parseInt(this.toString(v, true), r);
            },

            /**
             * A locale-aware version of built-in parseFloat function.
             * @param {string} v The string to be parsed.
             */
            parseNumeric: function parseNumeric(v) {
                //TO-DO: need to consider percentage input?
                if (!this.isNumeric(v)) {
                    return Number.NaN;
                }
                return parseFloat(this.toString(v, true));
            },

            /**
             * parse big decimal value quoted by #
             * @param {string} v The string to be parsed.
             * @return {string} the number as a string without #
             */
            parseBigDecimal : function(v) {
                // TODO: should we call toString to remove the thousand separator, etc.?
                return String(v).match(/^#(.+)#$/)[1];
            },

            /**
             * Compares a given non-null value with a minimum and maximum. If the value is below the minimum, returns -1.
             * If the value is above the maximum, returns 1.  Otherwise, returns 0.
             * @param {string} v The string to compare.
             * @param {string} min The minimum value.
             * @param {string} max The maximum value.
             */
            inNumericRange: function inNumericRange(v, min, max) {
                v = this.parseNumeric(v);
                max = (max != null) ? this.parseNumeric(this.toLocaleString(max)) : Number.NaN;
                min = (min != null) ? this.parseNumeric(this.toLocaleString(min)) : Number.NaN;
                if (max != Number.NaN && (v > max || isNaN(v))) {
                    return 1;
                }
                if (min != Number.NaN && (v < min || isNaN(v))) {
                    return -1;
                }
                return 0;
            },

            /**
             * <p>Convert a given measurements at given units to US inches.</p>
             * @param {int/string} value Measurement to be converted
             * @param {int} unit Unit code of this given measurement.
             * @param {boolean} doNotLocalize Flag to indicate whether to localize the converted value format.
             * @return {string} Localized value in inches
             */
            convertToUSUnits: function (value, unit, doNotLocalize) {
                var __result = value;

                unit = unit || _unit; //if not provided, use the one in mstrApp.
                switch (parseInt(unit, 10)) {
                case UNIT.CM:
                    __result = parseFloat(this.toString(value)) / 2.54 + '';
                    break;
                case UNIT.MM:
                    __result = parseFloat(this.toString(value)) / 25.4 + '';
                    break;
                case UNIT.PT:
                    __result = parseFloat(this.toString(value)) / 72 + '';
                    break;
                case UNIT.PC:
                    __result = parseFloat(this.toString(value)) / 6 + '';
                    break;
                case UNIT.PX:
                    __result = parseFloat(this.toString(value)) / DPI_CONVERSION + '';
                    break;
                }

                return doNotLocalize ? __result : this.toLocaleString(__result);
            },

            /**
             * <p>Convert a given measurements in inches to local units.</p>
             * @param {int/string} value Measurement to be converted
             * @param {int} unit Unit code of this given measurement.
             * @param {boolean} doNotLocalize Flag to indicate whether to localize the converted value format.
             * @return {string} Localized value in inches
             */
            convertToLocalUnits: function (value, unit, doNotLocalize) {
                var __result;

                unit = unit || _unit; //if not provided, use the one in mstrApp.
                switch (parseInt(unit, 10)) {
                case  UNIT.CM:
                    __result = (parseFloat(this.toString(value)) * 2.5400).toFixed(4) + '';
                    break;
                case UNIT.MM :
                    __result = (parseFloat(this.toString(value)) * 25.4000).toFixed(4) + '';
                    break;
                case UNIT.PT:
                    __result = (parseFloat(this.toString(value)) * 72.0000).toFixed(4) + '';
                    break;
                case UNIT.PC:
                    __result = (parseFloat(this.toString(value)) * 6.0000).toFixed(4) + '';
                    break;
                case UNIT.PX:
                    __result = (parseFloat(this.toString(value)) * DPI_CONVERSION) + '';
                    break;
                default:
                    __result = parseFloat(this.toString(value)).toFixed(4) + '';
                }

                return doNotLocalize ? __result : this.toLocaleString(__result);
            },

            /**
             * <p>Convert measurement from one unit to another <p>
             * @param {int} unitFrom
             * @param {int} unitTo
             * @param {int/string} value
             * @return {string} value string in 'To' unit
             */
            convertUnits: function (unitFrom, unitTo, value) {
                return this.convertToLocalUnits(this.convertToUSUnits(value, unitFrom, true), unitTo, true);
            },

            /**
             * <p>returns the localized string representation of a double value.</p>
             */
            toLocaleString: function (value) {
                return (value + '').replace(".", this.getDecimal());
            },

            /**
             * <p>returns the string representation of a double value.</p>
             */
            toString: function (value, removeThousandsSeparator) {
                if (removeThousandsSeparator === true) {
                    var regex = this.getThousandSepRegex();
                    if (regex) {
                        value = String(value).replace(regex, '');
                    }
                }
                return String(value).replace(this.getDecimal(), ".");
            },

            getThousandSepRegex: function () {
                if (this.thousandSeparatorRegex == null) {
                    this.thousandSeparatorRegex = new RegExp(this.getThousand().replace(/(\W){1}/g, '\\$1'), 'g');
                }
                return this.thousandSeparatorRegex;
            },

            /**
             * Add thousand separator to the integer string
             * @param {string} val Integer string
             */
            addSeparators: function (val, ts) {
                var _ts = ts;
                if (ts == '.' || ts == '*' || ts == '\\') {
                    _ts = '\\' + ts;
                }
                return val.reverse().replace(/(\d{3})/g, "$1" + ts).reverse().replace(new RegExp('^(-)?' + _ts), "$1");
            },

            /**
             * Add thousand separators to INTEGER strings which may contains other symbols at the beginning or end
             * @param {string} val String
             * @param {string} ts the thousand separator with locale
             */
            addSeparators2: function (val, ts) {
                var x = val,
                    rgx = /(\d+)(\d{3})/;

                while (rgx.test(x)) {
                    x = x.replace(rgx, '$1' + ts + '$2');
                }

                return x;
            },

            /**
             * <p>Format a number using category and decimal places<p>
             * @param {EnumGridFormatNumberCategory} category
             * @param {int} decimalPlaces Decimal places
             * @param {int/string} nm Input number
             * @param {string} curr Currency symbol
             * @return {string} formatted value string
             */
            format: function (category, decimalPlaces, curr, nm) {
                var pattern = '',
                    ds = (decimalPlaces > 0) ? '.' : '',
                    zeros = [];

                curr = (curr) ? curr : '';

                for (var i = 0; i < decimalPlaces; i++) {
                    zeros.push('0');
                }
                zeros = zeros.join('');

                switch (category) {
                case CAT.GENERAL:
                	pattern = '0.00';
                	break;
                case CAT.PERCENT:
                    pattern = '0' + ds + zeros + '%';
                    break;
                case CAT.SCIENTIFIC:
                    pattern = '0' + ds + zeros + 'E+00';
                    break;
                default:
                    pattern = '"' + curr + '"' + '#,##0' + ds + zeros;
                }
                return this.formatByMask(pattern, nm);
            },

            /**
             * <p>Calculate the decimal length in a pattern.</p>
             *
             * @param {string} pattern Format Mask pattern.
             * @returns {number} Decimal length.
             */
            getDecimalLength: function getDecimalLength(pattern) {
                var position = pattern.indexOf('.'), // pattern always uses '.' as decimal separator no matter what locales is.
                    decimalLength = 0;
                if (position !== -1) {
                    var decimalString = pattern.substr(position + 1, pattern.length).match(/\d+/);
                    if (decimalString && decimalString.length > 0) {
                        decimalLength = decimalString[0].length;
                    }
                }

                return decimalLength;
            },

            /**
             * <p>Format a number using format mask/pattern<p>
             * @param {string} formatMask Format Mask pattern
             * @param {int/string} nm Input number
             * @return {string} formatted value string
             */
            formatByMask: function (formatMask, nm) {
                var convertedDate,
                    result = '',
                    isDateByDefault,
                    hasSSFed = false;

                // Is this NOT a number?
                if (isNaN(nm)) {
                    // DE4461: Handle Date String.
                    convertedDate = new Date(nm);

                    // Is this NOT a Date?
                    if (isNaN(convertedDate)) {
                        return nm;
                    }

                    // The original number is actually a date string. Convert it to Date Object and pass it for formatDate().
                    isDateByDefault = true;
                }

                // Is the format mask for General category
                if (formatMask === 'General') {
                    // General category
                    // DE106829: we need to handle the decimal separator for i18n to keep consistent with iServer
                    var fixedVal = String(parseFloat(nm).toFixed(2));

                    result = fixedVal.split('.');
                    if (result.length === 2) {
                        return result.join(this.getDecimal());
                    }

                    return fixedVal;
                }

                var ptns = String(formatMask).split(';'),
                    pattern = ptns[0],
                    ph = '\u00A4',
                    qt = /"[^"]*"/g,
                    pf = (formatMask && formatMask.replace(qt, ph).replace(/\[.*\]/g, ph)) || '',
                    dateOrTimeStr = ['m', 'y', 'd', 'h', 's'],
                    isDateOrTime = false;

                // Does the format contains a date/time related character?
                $ARR.forEach(dateOrTimeStr, function (str) {
                    isDateOrTime = isDateOrTime || pf.indexOf(str, 0) !== -1;
                });

                // Is this format mask for date or time?
                if (isDateOrTime) {
                    // Leverage SSF for timing format
                    if (window.SSF && !hasSSFed) {
                        result = this.formatBySSF(formatMask, nm);
                        hasSSFed = true;
                    }
                    if (result !== '') {
                        return result;
                    } else {
                        return formatDate(isDateByDefault ? convertedDate : convertIntToDate(nm), formatMask, nm);
                    }

                }

                var ePos = pattern.indexOf("E+"),
                    pPos = pattern.indexOf("%"),
                    cs = pattern.match(/\".+?\"/g),
                    cf = pattern.match(/\[([=<>]*)(-?\d+\.?\d*)\]/),
                    fs = pattern.indexOf("?/?") > -1,
                    cat = (ePos != -1) ? CAT.SCIENTIFIC : ( (pPos != -1) ? CAT.PERCENT : ((cs && !cf) ? CAT.CURR : fs ? CAT.FRACTION : CAT.FIXED)),
                    currMask = '',
                    negMask = '',
                    isNeg = false,
                    sNm = new String(nm),
                    // DE30105: Number should be extracted irrespective of whether nm is in generic or locale-specific format.
                    // DE74307: Number should be calculated as a float initially in the case that it is a percentage or has other decimals.
                    nN = parseFloat(nm) || this.parseNumeric(nm);
                //Currency Mask
                if (cs) {
                    // for excel customization format, typically: "[$€-2]" "#,##0.00"
                    // Transform excel currency format into MSTR currency format
                    if (pattern.match(/\[\$.+?\]/g)) {
                        for (var dd = 0; dd < cs.length; dd++) {
                            // remove '"' from pattern
                            pattern = pattern.replace(cs[dd],
                                cs[dd].substring(1, cs[dd].length - 1));
                            // replace [$€-XXX] with "€" in cs
                            if (cs[dd].match(/\[\$.+?\]/g)) {
                                cs[dd] = cs[dd].replace(/\[\$.+?\]/g, cs[dd][cs[dd].indexOf("[$") + 2]);
                            }
                        }
                        // replace[$€-XXX] with "€" in pattern
                        pattern = pattern.replace(/\[\$.+?\]/g, '"#"'.replace('#', pattern[pattern.indexOf("[$") + 2]));
                    }

                    currMask = removeDoubleQuote(pattern, cs);

                    currMask = currMask.replace(pattern.replace(/\".+?\"/g, ""), ph);
                }

                //Negative Mask
                if (nN < 0) {
                    sNm = sNm.substring(1, sNm.length);
                    nN = -nN;
                    isNeg = true;
                    if (ptns.length > 1) {
                        var _ptns1 = ptns[1].replace(/\[.*\]/, ''); //remove color

                        // DE14035: Remove '"' from negative mask.
                        negMask = removeDoubleQuote(_ptns1.replace(ptns[0], ph));

                    }
                }

                //Negative
                var me = this,
                    negativeFormat = function (sNm, negMask) {
                        var res = negMask && negMask.replace(ph, sNm);
                        if (negMask && (res === negMask) && window.SSF) {
                            if (hasSSFed) {
                                return sNm;
                            } else {
                                hasSSFed = true;
                                return me.formatBySSF(negMask, sNm);
                            }

                        }
                        return (negMask) ? res : '-' + sNm;
                    };

                if (cat === CAT.FRACTION) {
                    var i,
                        j,
                        minIndex,
                        base = 10,
                        output,
                        intPart = 0,
                        v,
                        currentMin,
                        temp,
                        sepInt = false,
                        stemp;

                    // do we need to show separate integer part
                    if (formatMask.indexOf("# ") > -1) {
                        sepInt = true;
                    }

                    // what is the base
                    for (i = 5; i > 0; i--) {
                        stemp = "/";
                        for (j = 0; j < i; j++) {
                            stemp += "?";
                        }
                        if (formatMask.indexOf(stemp) > -1) {
                            for (j = 1; j < i; j++) {
                                base *= 10;
                            }
                            break;
                        }
                    }

                    if (sepInt) {
                        intPart = Math.floor(Number(nN));
                        nN -= intPart;
                    }

                    currentMin = base / 2;
                    minIndex = -1;
                    v = nN * base;
                    for (i = base - 1; i >= 2; i--) {
                        temp = (v * i) / base;
                        temp = temp - Math.floor(temp);
                        temp = temp * base;

                        if (Math.abs(temp - base) < temp) {
                            temp = Math.abs(temp - base);
                        }

                        temp = temp / i;

                        if (temp < currentMin) {
                            currentMin = temp;
                            minIndex = i;
                        }
                        else if ((temp == currentMin) && (temp == 0)) {
                            currentMin = temp;
                            minIndex = i;
                        }
                    }

                    output = Math.round(minIndex * v / base);

                    for (i = minIndex; i >= 2; i--) {
                        if ((output % i == 0) && (minIndex % i == 0)) {
                            output = output / i;
                            minIndex = minIndex / i;
                            break;
                        }
                    }

                    if (minIndex == base) {
                        minIndex = 1;
                        output = 0;
                    }
                    if (output == 0) {
                        minIndex = 1;
                    }
                    if (output == minIndex) {
                        if (sepInt) {
                            result = "" + (intPart + 1);
                        } else {
                            result = "1";
                        }
                    } else if (sepInt && intPart > 0) {
                        if (output == 0) { //DE5204
                            result = intPart;
                        } else {
                            result = intPart + " " + output + "/" + minIndex;
                        }
                    } else {
                        if (output == 0) {
                            result = "0";
                        } else {
                            result = output + "/" + minIndex;
                        }
                    }
                    if (isNeg) {
                        result = negativeFormat(result, negMask);
                    }
                } else if (cat == CAT.SCIENTIFIC) {//Scientific

                    if(nN != 0) {
                        var exp = Math.floor(Math.log(nN) / Math.LN10),
                            m = nN / Math.pow(10, exp),
                            beStr = pattern.substring(0, ePos),
                            dPos = beStr.indexOf('.'),
                            expFill = pattern.length - pattern.indexOf('E+') - ("" + Math.abs(exp)).length - 2,
                            i,
                            negExp = exp < 0;

                        exp = Math.abs(exp);
                        for(i = 0; i < expFill; i++){
                            exp = "0" + exp;
                        }

                        result += Number(m).toFixed((dPos != -1) ? beStr.length - dPos - 1 : 0);
                        result = ((isNeg) ? negativeFormat(result, negMask) : result ) + 'E' + (negExp ? '-' : '+') + exp;
                    }else{
                        result = "0";
                    }

                } else {
                    if (cat == CAT.PERCENT) {//Percentage
                        pattern = pattern.substring(0, pattern.length - 1);
                        sNm = String(nN * 100);
                    }

                    //tofixed
                    var dPos = pattern.indexOf('.'), // pattern always uses '.' as decimal separator no matter what locales is.
                        dp = 0,
                        decimalLen,
                        subPattern = dPos >= 0 ? pattern.substring(0, dPos) : pattern,
                        suffixPattern = dPos >= 0 ? pattern.substring(dPos + 1, pattern.length) : '',
                        hasTrimDecimal = false;

                    //DE4079, A comma following a placeholder scales the number by a thousand
                    // separate pattern like #,##0.0, by ".", if handles the prefix and else handles the suffix
                    if (subPattern.match(/[#0\?],$/)) {
                        nN /= 1000;
                        sNm = String(nN);
                    } else if (suffixPattern.match(/^[#0]*,/)) {
                        var ij = 0;
                        hasTrimDecimal = true;
                        while (ij < suffixPattern.length) {
                            if (suffixPattern[ij] === '0' || suffixPattern[ij] === '#') {
                                ij++;
                            } else if (suffixPattern[ij] === ',') {
                                nN /= 1000;
                                sNm = String(nN);
                                ij++;
                            } else {
                                break;
                            }
                        }
                    }

                    decimalLen = this.getDecimalLength(sNm);

                    if (dPos != -1) {
                        dp = extractDP(decimalLen, pattern.substr(dPos + 1, pattern.length));
                    }

                    //DE118997 handle the case that not round up/down correctly due to precision loss
                    result = String((+(Math.round(+(sNm.indexOf('e') > 0? String(parseFloat(sNm).toFixed(Math.min(dp+2, 20))): sNm + 'e' + Math.min(dp, 20))) + 'e' + -Math.min(dp, 20))).toFixed(Math.min(dp, 20)));

                    if (cat === CAT.FIXED) {
                        if (/[\[\]><=A-Za-z]|,{2}/.test(pattern) && window.SSF) {
                            var tempRes = this.formatBySSF(formatMask, nm);
                            result = tempRes !== '' ? tempRes : result;
                            hasSSFed = true;
                        }
                    }

                    //Pick the integer part of a number to add thousand separator
                    var nn = result.split('.');

                    // Fixed search separator bug. Separator exists only when there is symbol other than number/point/sharp among numbers.
                    var tsPos = pattern.replace(/"[^"]*"/g, '').match(/[#\d]+[^\.\d#]+[#\d]+/);
                    if (tsPos !== null) {
                        if (cat === CAT.CURR) {
                            // format the integer part of the result
                            nn[0] = (this.formatBySSF((hasTrimDecimal ? tsPos[0] && tsPos[0].trim() : tsPos.input && tsPos.input.trim()), parseFloat(nn[0])) || "").split('.')[0];
                            hasSSFed = true;
                        }

                        // if nn[0] contains default thousand separator
                        if (nn[0].indexOf(',') >= 0) {
                            nn[0] = nn[0].replace(/,/g, this.getThousand());
                        } else {
                            // if nn[0] doesn't contains thousand
                            if (!(this.getThousand() === ',' && nn[0].search(this.getThousand())>0)) {
                                nn[0] = this.addSeparators2(nn[0], this.getThousand());
                            }
                        }
                    }

                    result = nn.join(this.getDecimal());

                    //Add Currency symbol
                    if (cat == CAT.CURR) {
                        result = currMask.replace(ph, result);
                        // Well, in such cases, the parsing result can't be right, let SSF handle it.
                        if (result === currMask && window.SSF) {
                            result = this.formatBySSF(formatMask, nm, result);
                            hasSSFed = true;
                        }
                    }//Currency

                    //Add Percentage symbol
                    if (cat == CAT.PERCENT) {
                        result += '%';
                    }//Percentage

                    //Add negative mask
                    if (isNeg) {
                        result = negativeFormat(result, negMask);
                    }
                }

                return result;
            },

            /**
             * format number by SSF
             *
             * @param formatMask
             * @param nm
             * @param dftValue
             * @returns {*|string}
             */
            formatBySSF: function(formatMask, nm, dftValue) {
                var result = (dftValue !== undefined && dftValue !== null) ? dftValue : '';

                if (typeof nm === "string") {
                    nm = parseFloat(nm);
                }

                try {
                    result = window.SSF.format(formatMask, nm);
                } catch (e) {
                    if (window.mstr_profile) {
                        window.mstr_profile.log(e);
                    }
                    result = (dftValue || nm).toString();
                }

                return result;
            },

            /**
             * Validate format pattern.
             *
             * NOTE: the validation is not complete, currently only works for certain cases
             *
             * @param fm
             * @returns {boolean}
             */
            validateFormat: function (fm) {
                var _rtn = true,
                    ptns = String(fm).split(';');

                if (ptns[1] && ptns[1].indexOf(ptns[0]) < 0) {
                    _rtn = false;
                }

                return _rtn;
            },

            /**
             * generates unique ID of specified length
             * @param {int} keyLen number of digits to return
             * @returns string of hex digits
             * @type String
             */

            generateUniqueID: function (keyLen) {
                var chars = "0123456789ABCDEF".split(''),
                    id = [];
                for (var i = 0; i < keyLen; i++) {
                    id[i] = chars[0 | Math.random() * 16];
                }
                return id.join('');
            },
            /**
             * Returns the number of digits after decimal point.
             * This can be used to solve float number problem.
             * For example, 6 * 0.05 = 3.0000000000000004.
             * but if you do this (6*0.05).toFixed(mstrmojo.num.countOfDecimals(0.05)), it will return 3.00
             */
            countOfDecimals: function (v, decimalSep) {
                var sV = String(v);
                return sV.length - (sV.indexOf(decimalSep !== undefined ? decimalSep : this.getDecimal()) + 1); // when index = -1, index + 1 = 0
            },
            // Now thousand/decimal separator info is retrieved from the mstrmojo.locales which may be updated dynamically.
            // For example, android app may connect to multiple projects with different locales, mstrmojo.locales will get
            // updated while user switches among those projects.
            getThousand: function () {
                return mstrmojo.locales.number.THOUSANDSEPARATOR;
            },
            getDecimal: function () {
                return mstrmojo.locales.number.DECIMALSEPARATOR;
            }
        });

    mstrmojo.num.UNIT = UNIT;
    mstrmojo.num.UNIT_SYMBOL = UNIT_SYMBOL;

})();
(function () {

    mstrmojo.requiresCls("mstrmojo.locales");

    var _DT = function () {
            return mstrmojo.locales.datetime;
        },
        $S = mstrmojo.string;

    /**
     * A utility class that provides utility functions related to date/time, such as date parsing/formatting.
     *
     * @namespace mstrmojo.date
     */
    mstrmojo.date = mstrmojo.provide(
        "mstrmojo.date",

        /**
         * @lends mstrmojo.date
         */
        {
            monthNumbers: {
                Jan: 1,
                Feb: 2,
                Mar: 3,
                Apr: 4,
                May: 5,
                Jun: 6,
                Jul: 7,
                Aug: 8,
                Sep: 9,
                Oct: 10,
                Nov: 11,
                Dec: 12
            },

            REGEXPS: {
                DATES: {},  // To store regular expressions built from date formats.
                TIMES: {}   // To store regular expressions built from time formats.
            },

            CACHE: {
                PARSEDATE: {
                    CONTAINS: {},
                    EQUALS: {}
                },
                PARSETIME: {
                    CONTAINS: {},
                    EQUALS: {}
                }
            },

            /**
             * A cross browser function to get the current timestamp
             * IE < 9 would use the proxy one
             * Modern browser may use the native `Date.now` one for performance
             */
            now: Date.now || function now() {
                return new Date().getTime();
            },

            /**
             * Validation method for dates.  Returns true if the given string matches one of MSTR Web's input patterns (or
             * output pattern) for dates.
             * If bFormat, the method returns a converted String if there is a match; null otherwise.
             * Else if bFormat is false, the method instead just returns true|false depending on whether there is a match.
             * If the optional Boolean param "bContains" is true, then
             * a string which contains a valid date substring will be considered valid; otherwise
             * only a string which equals a valid date string will be considered valid.
             *
             * @param {string} s
             * @param {boolean} [bFormat=false]
             * @param {boolean} [bContains=false]
             */
            isDate: function isDate(s, bFormat, bContains) {
                // Try parsing the string according to our acceptable patterns.
                var dateInfo = this.parseDate(s, bContains);
                // If parsing succeeded, and the numbers are in the right range, validation successful.
                var isValid = !!(dateInfo && this.doesDateExist(dateInfo.month, dateInfo.day, dateInfo.year));
                if (bFormat) {
                    if (isValid) {
                        var formatted = this.formatDateInfo(dateInfo, _DT().DATEOUTPUTFORMAT);
                        if (bContains) {
                            return {match: dateInfo.match, formatted: formatted};
                        }
                        return formatted;
                    }
                    return null;
                }

                return !!isValid;
            },

            /**
             * This method applies a format String to a dateInfo object to produce a formatted date String.
             * The given dateInfo object is assumed to have the following properties:  "month" (1-12),
             * "day" (Integer), "year" (four digit Integer).  The format String is typically the out format
             * specified by MSTRWeb server.  In theory, this method should handle any such format String,
             * but to optimize this implementation, we make certain assumptions about the format String, namely:
             * the string may contain: "MMMM", "MMM", "MM", "M", "dd", "d", "yyyy", "yy"; all other chars
             * are taken as literals.
             *
             * @param {Object} dateInfo
             * @param {string} format
             */
            formatDateInfo: function formatDateInfo(dateInfo, format) {
                if (!format) {
                    return '';
                }
                var day = dateInfo.day,
                    month = dateInfo.month,
                    year = dateInfo.year;

                var s = format.replace(/dd/g, this.formatInteger(day, 2)
                    ).replace(/d/g, Number(day)
                    ).replace(/yyyy/g, Number(year)
                    ).replace(/yy/g, this.formatInteger(Number(year) % 100, 2)
                    ).replace(/MMM/g, "~~~~"
                    ).replace(/MM/g, "@@"
                    ).replace(/M/g, "^"
                    ).replace(/MMMM/g, _DT().MONTHNAME_FULL[Number(month) - 1]
                    ).replace(/\~\~\~\~/g, _DT().MONTHNAME_SHORT[Number(month) - 1]
                    ).replace(/\@\@/g, this.formatInteger(month, 2)
                    ).replace(/\^/g, Number(dateInfo.month)
                    );
                return s;
            },

            /**
             * Parses a given date string to determine the month, day and year values
             * it represents.  If the optional Boolean param "bContains" is true, then
             * a string which contains a valid date substring will be considered valid; otherwise
             * only a string which equals a valid date string will be considered valid.
             *
             * @param {string} s
             * @param {boolean} [bContains=false]
             * @param {string=} format
             */
            parseDate: function parseDate(s, bContains, format) {
                if (s == null) {
                    return false;
                }
                if (typeof s  !== 'string') {
                    s = String(s);
                }
                s = $S.trim(s);

                // Check our cache.  The cache is a hashtable; hash key = the given string (trimmed);
                // hash value = the parse result object (if date found) or a null (if date not found).
                var cache = this.CACHE.PARSEDATE[bContains ? "CONTAINS" : "EQUALS"],
                    cachedResult = cache[s];
                if (cachedResult || (cachedResult === null)) {
                    return cachedResult;
                }
                // Cached result not found.  Must parse date and store parsing result in cache.
                var parseResult = null;

                // Build an array of all acceptable date formats.
                var formats;
                if (format) {
                    formats = [format];
                } else {
                    formats = [].concat(_DT().DATEINPUTFORMATS);
                    formats.unshift(_DT().DATEOUTPUTFORMAT);
                }

                // Now compare the given string to each acceptable format.
                var i, len;
                for (i = 0, len = formats.length; i < len; i++) {
                    // Convert the format to a regular expression for javascript comparison.
                    var reInfo = this._buildRegExp4DateFormat(formats[i]),
                    // Does the given string match the regular expression?
                        result = reInfo && s.match(bContains ? reInfo.reContains : reInfo.reEquals);
                    if (result) {
                        // Yes, matched. Fetch parts: month, day and year.
                        parseResult = {
                            match: result[0],
                            year: reInfo.yearIndex && this.fourDigitYear(result[reInfo.yearIndex]),
                            day: reInfo.dayIndex && parseInt(Number(result[reInfo.dayIndex]), 10),
                            month: reInfo.monthIndex && this.numericMonth(result[reInfo.monthIndex])
                        };
                        break;
                    }
                } // end for loop walking the acceptable formats
                // Store parse result in cache for later re-use.
                cache[s] = parseResult;
                return parseResult;
            },

            /**
             * Validation method for times.  Returns true if the given string matches one of MSTR Web's input patterns (or
             * output pattern) for times.
             * If bFormat, the method returns a converted String if there is a match; null otherwise.
             * Else if bFormat is false, the method instead just returns true|false depending on whether there is a match.
             * If the optional Boolean param "bContains" is true, then
             * a string which contains a valid time substring will be considered valid; otherwise
             * only a string which equals a valid time string will be considered valid.
             *
             * @param {string} s
             * @param {boolean} [bFormat=false]
             * @param {boolean} [bContains=false]
             */
            isTime: function isTime(s, bFormat, bContains) {
                // Try parsing the string according to our acceptable patterns.
                var timeInfo = this.parseTime(s, bContains);
                // If parsing succeeded, and the numbers are in the right range, validation successful.
                var isValid = !!(timeInfo && this.doesTimeExist(timeInfo.hour, timeInfo.min, timeInfo.sec));
                if (bFormat) {
                    if (isValid) {
                        var formatted = this.formatTimeInfo(timeInfo, _DT().TIMEOUTPUTFORMAT);
                        if (bContains) {
                            return {match: timeInfo.match, formatted: formatted};
                        }
                        return formatted;
                    }
                    return null;
                }
                return !!isValid;
            },

            /**
             * Parses a given time string to determine the hour, minute and second values
             * it represents.  If the optional Boolean param "bContains" is true, then
             * a string which contains a valid time substring will be considered valid; otherwise
             * only a string which equals a valid time string will be considered valid.
             *
             * @param {string} s
             * @param {boolean} [bContains=false]
             * @param {string=} format
             */
            parseTime: function parseTime(s, bContains, format) {
                if (s == null) {
                    return false;
                }
                if (typeof s !== 'string') {
                    s = String(s);
                }
                s = $S.trim(s);

                // Check our cache.  The cache is a hashtable; hash key = the given string (trimmed);
                // hash value = the parse result object (if date found) or a null (if date not found).
                var cache = this.CACHE.PARSETIME[bContains ? "CONTAINS" : "EQUALS"],
                    cachedResult = cache[s];
                if (cachedResult || (cachedResult === null)) {
                    return cachedResult;
                }
                // Cached result not found.  Must parse date and store parsing result in cache.
                var parseResult = null;

                // Build an array of all acceptable time formats.
                var formats;
                if (format) {
                    formats = [format];
                } else {
                    formats = [].concat(_DT().TIMEINPUTFORMATS);
                    formats.unshift(_DT().TIMEOUTPUTFORMAT);
                }

                // Now compare the given string to each acceptable format.
                var i, len;
                for (i = 0, len = formats.length; i < len; i++) {
                    // Convert the format to a regular expression for javascript comparison.
                    var reInfo = this._buildRegExp4TimeFormat(formats[i]),
                    // Does the given string match the regular expression?
                        result = reInfo && s.match(bContains ? reInfo.reContains : reInfo.reEquals);
                    if (result) {
                        // Yes, matched. Fetch pieces: hour, min, sec, ampm, zone, etc.
                        var ampm = reInfo.ampmIndex && result[reInfo.ampmIndex];
                        parseResult = {
                            match: result[0],
                            // By convention, return a capital Hour (0-23), not a little hour (1-12)
                            hour: reInfo.hourIndex && this.capitalHour(result[reInfo.hourIndex], ampm),
                            min: reInfo.minIndex && parseInt(Number(result[reInfo.minIndex]), 10),
                            sec: reInfo.secIndex && parseInt(Number(result[reInfo.secIndex]), 10)
                        };
                        break;
                    }
                } // end for loop walking the acceptable formats
                // Store parse result in cache for later re-use.
                cache[s] = parseResult;
                return parseResult;
            },

            /**
             * This method applies a format String to a timeInfo object to produce a formatted time String.
             * The given timeInfo object is assumed to have the following properties:  "hour" (0-23),
             * "min" (0-59), "sec" (0-59, possibly missing).  The format String is typically the out format
             * specified by MSTRWeb server.  In theory, this method should handle any such format String,
             * but to optimize this implementation, we make certain assumptions about the format String, namely:
             * the string may contain: "HH", "H", "hh", "h", "mm", "m", "ss", "s", "a"; all other chars
             * are taken as literals.
             *
             * @param {Object} timeInfo
             * @param {string=} format
             */
            formatTimeInfo: function formatTimeInfo(timeInfo, format) {
                if (!format) {
                    return '';
                }
                //DE15538  Added "tt for the onetier application. The system locale returned
                //this for AM and PM
                //DE19707 Added AM/PM as in some cases the format contains it
                var twelveHour = !(Number(timeInfo.hour) % 12) ? 12 : (Number(timeInfo.hour) % 12),
                    s = format.replace(/HH/g, this.formatInteger(timeInfo.hour, 2)
                        ).replace(/H/g, Number(timeInfo.hour)
                        ).replace(/hh/g, this.formatInteger(twelveHour, 2)
                        ).replace(/h/g, twelveHour
                        ).replace(/mm/g, this.formatInteger(Number(timeInfo.min) || 0, 2)
                        ).replace(/m/g, Number(timeInfo.min) || 0
                        ).replace(/ss/g, this.formatInteger(Number(timeInfo.sec) || 0, 2)
                        ).replace(/s/g, Number(timeInfo.sec) || 0
                        ).replace(/a/g, (Number(timeInfo.hour) < 12) ? _DT().AM_NAME : _DT().PM_NAME
                        ).replace(/tt/g, (Number(timeInfo.hour) < 12) ? _DT().AM_NAME : _DT().PM_NAME
                        ).replace(/AM\/PM/g, (Number(timeInfo.hour) < 12) ? _DT().AM_NAME : _DT().PM_NAME
                        );
                return s;
            },

            /**
             * Returns true if the given time falls within the valid number range of hours, minutes
             * and seconds.  Seconds are optional, so if omitted, the time can still be considered valid.
             *
             * @param {int} capitalHour
             * @param {int} min
             * @param {int=} sec
             */
            doesTimeExist: function doesTimeExst(capitalHour, min, sec) {
                var h = parseInt(capitalHour, 10);
                if (h >= 0 && h <= 23) {
                    var m = parseInt(min, 10);
                    if (m >= 0 && m <= 59) {
                        if (!sec) {
                            return true;
                        }
                        var s = parseInt(sec, 10);
                        if (s >= 0 && s <= 59) {
                            return true;
                        }
                    }
                }
                return false;
            },

            /**
             * This method converts a given hour to a capital Hour.  "Capital Hour" means
             * an integer from 0-23.  The given hour can be either in capital Hour units
             * or in little hour units (1-12); but if given in little hour units, then the
             * ampm argument must be set to either "AM" or "PM" or their localized equivalents
             * (_DT().AM_NAME and _DT().PM_NAME).  The ampm param is case-insensitive.
             *
             * @param {string} hour
             * @param {string=} ampm
             */
            capitalHour: function capitalHour(hour, ampm) {
                // Assume that if no am/pm info is given, the hour is a capital Hour,
                // meaning 0-23.  Otherwise, if am/pm is given, the hour is a little hour,
                // meaning, 1-12.
                hour = parseInt(Number(hour), 10);
                if (ampm && (ampm.match(_DT().AM_NAME) || ampm.match(/AM/i))) {
                    // We have AM info, so hour is a little hour.
                    return hour % 12;
                }

                if (ampm && (ampm.match(_DT().PM_NAME) || ampm.match(/PM/i))) {
                    // We have PM info, so hour is a little hour.
                    return 12 + (hour % 12);
                }
                // Missing or invalid ampm param.
                // We don't have am/pm info, so hour is a capital Hour.
                return hour;
            },

            /**
             * This method returns a readable timestamp of current date and time
             *
             */
            getTimeStamp: function getTimeStamp() {
                // Create a date object with the current date and time
                var now = new Date();

                // Create date array with the current month, day and time
                var date = [ now.getMonth() + 1, now.getDate(), now.getFullYear() ];

                // Create time array with the current hour, minute and second
                var time = [ now.getHours(), now.getMinutes(), now.getSeconds() ];

                // Format time info in the array
                var suffix = ( time[0] < 12 ) ? "AM" : "PM";
                time[0] = ( time[0] < 12 ) ? time[0] : time[0] - 12;
                time[0] = time[0] || 12;
                for ( var i = 1; i < 3; i++ ) {
                    if ( time[i] < 10 ) {
                        time[i] = "0" + time[i];
                    }
                }

                // Return the formatted date-time string
                return date.join("-") + " " + time.join("") + " " + suffix;
            },

            /**
             * Validation to check if a given string is either (1) a date only, (2) a time only, or
             * (3) a date + time.
             * The bFormat param determines whether this method returns a string (bFormat = true)
             * or boolean (bFormat = false or missing).
             *
             * @param {string} s
             * @param {boolean} [bFormat=]
             */
            isDateAndOrTime: function isDateAndOrTime(s, bFormat) {
                return this.isDateTime(s, bFormat)
                    || this.isDate(s, bFormat)
                    || this.isTime(s, bFormat);
            },

            /**
             * Validation method for timestamps. Succeeds if the given string contains a
             * valid date and a valid time.  Note that if other extraneous chars are also present
             * in the string along valid date + time substrings, validation still succeeds.
             * The bFormat param determines whether this method returns a string (bFormat = true)
             * or boolean (bFormat = false or missing).
             * If bFormat is true, the method will return the formatted
             * date and time, if found; null otherwise.  If bFormat is false,
             * the method will return true if the date and time are found; false otherwise.
             * If bFormat is true and a match is made, the formatted date + formatted time strings
             * are concat'd together by a space (in whichever order they were found); other extraneous
             * pieces of the string are discarded.
             *
             * @param {string} s
             * @param {boolean} [bFormat=]
             */
            isDateTime: function isDateTime(s, bFormat) {
                // Try to parse the date and time info from the given string.
                // If parsing succeeded, and the numbers are in the right range, validation successful.
                var dateTimeInfo = this.parseDateAndOrTime(s),
                    dateInfo = dateTimeInfo && dateTimeInfo.date,
                    timeInfo = dateTimeInfo && dateTimeInfo.time,
                    isValid = !!dateInfo
                        && !!timeInfo
                        && this.doesDateExist(dateInfo.month, dateInfo.day, dateInfo.year)
                        && this.doesTimeExist(timeInfo.hour, timeInfo.min, timeInfo.sec);
                // Are we returning a formatted String, or a Boolean?
                if (bFormat) {
                    // Return formatted Strings concat'd together, if matched; otherwise return null.
                    if (isValid) {
                        // Format the strings and concat. Which came first, date or time?
                        var formattedDate = this.formatDateInfo(dateInfo, _DT().DATEOUTPUTFORMAT),
                            formattedTime = this.formatTimeInfo(timeInfo, _DT().TIMEOUTPUTFORMAT),
                            dateIndex = s.indexOf(dateInfo.match),
                            timeIndex = s.indexOf(timeInfo.match);
                        return (timeIndex < dateIndex) ?
                                formattedTime + ' ' + formattedDate :
                                formattedDate + ' ' + formattedTime;

                    }
                    return null;
                }
                // Return Boolean.
                return !!isValid;
            },

            /**
             * Parses a given string for date and time substring information.  If both date and time are not
             * found, parser returns null; otherwise, parser returns a composite object with two properties, "date" and "time", each of
             * which correspond to the return values from calling the methods "parseDate" and "parseTime" respectively.
             * If only date info is found, the "time" property is set to null; if only time info is found, the "date" property
             * is set to null.
             *
             * @param {string} s
             * @param {string} dateFormat
             * @param {string} timeFormat
             *
             * @returns {{date, time}}
             */
            parseDateAndOrTime: function parseDateAndOrTime(s, dateFormat, timeFormat) {
                // First look for a date substring.
                var dateInfo = this.parseDate(s, true, dateFormat);
                // Now look for a time substring; search in the string after removing the date (if found), so that we
                // don't mistake some of the date as part of a time.
                var sWithoutDate = $S.trim((dateInfo && dateInfo.match) ?
                        s.replace(dateInfo.match, "") :
                        s),
                    timeInfo = this.parseTime(sWithoutDate, false, timeFormat); // by passing false, we are asking for exactly match

                // If we didn't find a time nor a date, we are done.
                if (!dateInfo && !timeInfo) {
                    return null;
                }
                // We found a date or a time, or both. Return the results of both parsings.
                return {
                    date: dateInfo,
                    time: timeInfo
                };
            },

            /**
             * Compares a given value with a minimum and maximum. If the value is below the minimum, returns -1.
             * If the value is above the maximum, returns 1.  Otherwise, returns 0.  Note that the value, min & max
             * are all assumed to use the current locale's formats for date & time.
             *
             * @returns {int}
             */
            inDateTimeRange: function inDateTimeRange(val, min, max) {
                // Parse the value's date and/or time.
                var valInfo = this.parseDateAndOrTime(val),
                    valDateInfo = valInfo && valInfo.date,
                    valTimeInfo = valInfo && valInfo.time;
                // If both date & time failed to parse, exit.
                if (!valDateInfo && !valTimeInfo) {
                    return 0;
                }

                // Minimum comparison.
                if (min != null) {
                    // Parse the minimum's date and/or time.
                    var minInfo = this.parseDateAndOrTime(min);
                    // Compare the minimum's date, if any.
                    if (valDateInfo && minInfo && minInfo.date) {
                        var minDiff = this.compareDate(valDateInfo, minInfo.date);
                        if (minDiff < 0) {
                            // The given date is less than the minimum.
                            return -1;
                        }

                        if (minDiff == 0) {
                            // The given date is the same as the minimum date.
                            // Compare the minimum's time, if any.
                            if (valTimeInfo && minInfo.time && (this.compareTime(valTimeInfo, minInfo.time) < 0)) {
                                // The given date's time is less than the minimum.
                                return -1;
                            } // end if compareTime with minInfo
                        } // end else if minDiff == 0
                    } // end if valDateInfo && minInfo.date
                } // end if min

                // Maximum comparison.
                if (max != null) {
                    // Parse the maximum's date and/or time.
                    var maxInfo = this.parseDateAndOrTime(max);
                    // Compare the maximum's date, if any.
                    if (valDateInfo && maxInfo && maxInfo.date) {
                        var maxDiff = this.compareDate(valDateInfo, maxInfo.date);
                        if (maxDiff > 0) {
                            // The given date is greater than the maximum.
                            return 1;
                        }

                        if (maxDiff == 0) {
                            // The given date is the same as the maximum date.
                            // Compare the maximum's time, if any.
                            if (valTimeInfo && maxInfo.time && (this.compareTime(valTimeInfo, maxInfo.time) > 0)) {
                                // The given date's time is greater than the maximum.
                                return 1;
                            } // end if compareTime of max
                        } // end else if maxDiff == 0
                    } // end if valDateInfo && maxInfo.date
                } // end if max
                return 0;
            },

            /**
             * Compares two non-null localized date strings. If val1 is lesser, returns a negative.
             * If val1 is greater, returns a postive. Otherwise returns zero.
             * The caller may also pass in Objects, rather than Strings, for either value, where the
             * Object passed in the Object returned by calling mstrmojo.date.parseDate(..) with the
             * localized date string.
             *
             * @param {string|Object} val1
             * @param {string|Object} val2
             *
             * @returns {int}
             */
            compareDate: function compareDate(val1, val2) {
                if (val1 === val2) {
                    return 0;
                }
                var date1 = typeof val1  === 'string' ? this.parseDate(val1) : val1,
                    date2 = typeof val2  === 'string' ? this.parseDate(val2) : val2;
                if (!date1) {
                    return -1;
                }
                if (!date2) {
                    return 1;
                }
                return (date1.year - date2.year)
                    || (date1.month - date2.month)
                    || (date1.day - date2.day)
                    || 0;
            },

            /**
             * Compares two non-null localized time strings. If val1 is lesser, returns a negative.
             * If val1 is greater, returns a postive. Otherwise returns zero.
             * The caller may also pass in Objects, rather than Strings, for either value, where the
             * Object passed in the Object returned by calling LocaleParser.parseTime(..) with the
             * localized time string.
             *
             * @param {string|Object} val1
             * @param {string|Object} val2
             *
             * @returns {int}
             */
            compareTime: function compareTime(val1, val2) {
                if (val1 === val2) {
                    return 0;
                }
                var time1 = typeof val1  === 'string' ? this.parseTime(val1) : val1,
                    time2 = typeof val2  === 'string' ? this.parseTime(val2) : val2;
                if (!time1) {
                    return -1;
                }
                if (!time2) {
                    return 1;
                }
                return (time1.hour - time2.hour)
                    || (time1.min - time2.min)
                    || (time1.sec - time2.sec)
                    || 0;
            },

            /**
             * Compares two non-null localized datetime strings. If val1 is lesser, returns a negative.
             * If val1 is greater, returns a positive. Otherwise returns zero.
             *
             * @param {string|Object} val1
             * @param {string|Object} val2
             */
            compareDateTime: function compareDateTime(val1, val2) {
                return this.compareDate(val1, val2) || this.compareTime(val1, val2);
            },

            /**
             * @param {string|Object} val1
             * @param {string|Object} val2
             */
            compareDateAndOrTime: function compareDateAndOrTime(val1, val2) {
                if (val1 === val2) {
                    return 0;
                }
                var dt1 = typeof val1 === 'string' ? this.parseDateAndOrTime(val1) : val1,
                    dt2 = typeof val2 === 'string' ? this.parseDateAndOrTime(val2) : val2;

                if (!dt1) {
                    return -1;
                }
                if (!dt2) {
                    return 1;
                }

                var d1 = dt1.date, d2 = dt2.date, t1 = dt1.time, t2 = dt2.time;
                return this.compareDate(d1, d2) || this.compareTime(t1, t2);
            },

            /**
             * Converts a given date format string from MSTRWeb server to a javascript
             * regular expression that will be used to match that string against a
             * user-given value.
             * This method makes many assumptions about the format strings:
             * 1) The string has chars "M", "d" and "y" (case-sensitive).
             * 2) The "d"s are grouped together consecutively, as are the "M"s and "y"s.
             * 3) There are either 1 or 2 "d"s, 1 to 4 "M"s, and either 2 or 4 "y"s.
             *
             * @param {string=} formatStr
             */
            _buildRegExp4DateFormat: function re4DateFmt(formatStr) {

                if (!formatStr) {
                    return null;
                }
                // Lookup local cached result.
                var reInfo = this.REGEXPS.DATES[formatStr];
                if (!reInfo) {
                    // Cache not found, build result and cache it.
                    if (!this.REGEXPS.MONTHNAME_FULL) {
                        this.REGEXPS.MONTHNAME_FULL = _DT().MONTHNAME_FULL.join("|");
                        this.REGEXPS.MONTHNAME_SHORT = _DT().MONTHNAME_SHORT.join("|");
                    }
                    // The result is an object with several properties...
                    reInfo = this.REGEXPS.DATES[formatStr] = {};
                    // The "formatStr" prop has the original format string.
                    reInfo.formatStr = formatStr;
                    // The "re" prop has a regular expression derived from the format string.
                    // This requires several string replacements:
                    // 1) First, we need to escape any string chars which are not:
                    // "M", "d", "y", or white space.
                    // 2) Replace "dd" with 2 digits, to be captured as a whole.
                    // 3) Replace "d" with 1 or 2 digits, to be captured as a whole.
                    // Note that 2 & 3 must be done before the rest, because the digit placeholder
                    // is "\d" in RE syntax, which might be confused with "d" for day in Date syntax.
                    // 4) Replace 4 "y"s with 4 digits, to be captured as a whole.
                    // 5) Replace 2 "y"s with 2 digits, to be captured as a whole.
                    // 6) Replace 4 "M"s with a placeholder for a list of full month names
                    // (this placeholder should avoid "M"s)
                    // 7) Replace 3 "M"s with a placeholder for a list of short month names
                    // (this placeholder should avoid "M"s and should avoid being confused
                    // with the parts of the list of full month names).
                    // 8) Replace 2 "M"s with 2 digits, to be captured as a whole.
                    // 9) Replace "M" with 1 or 2 digits, to be captured as a whole.
                    // 10) Replace the 4 "M"s placeholder with the actual list of full month names.
                    // 11) Replace the 3 "M"s placeholder with the actual list of short month names.
                    var reStr = reInfo.reStr = formatStr.replace(/([^M|d|y|\s])/g, "\\$1"
                        ).replace(/dd/g, "~~~~" // temporary place holder so the following "d" replacement wont touch "dd"s
                        ).replace(/d/g, "(\\d{1,2})"
                        ).replace(/\~\~\~\~/g, "(\\d\\d)"   // replace temporary placeholder for "dd"s
                        ).replace(/yyyy/g, "(\\d\\d\\d\\d)"
                        ).replace(/yy/g, "(\\d\\d)"
                        ).replace(/MMMM/g, "@@@@"
                        ).replace(/MMM/g, "@@@"
                        ).replace(/MM/g, "(\\d\\d)"
                        ).replace(/M/g, "(\\d{1,2})"
                        ).replace("@@@@", "(" + this.REGEXPS.MONTHNAME_FULL + ")"
                        ).replace("@@@", "(" + this.REGEXPS.MONTHNAME_SHORT + ")");
                    // Now instantiate the reg expr objects and cache them; one object for
                    // an "equals" match, another for a "contains" match.
                    reInfo.reEquals = new RegExp("^" + reStr + "$");
                    reInfo.reContains = new RegExp("^" + reStr + "\\b");
                    // When we apply this reg expr and a match is found, the
                    // results of match() will yield the month, day and year
                    // parts that matched the pattern.  But they'll be sorted in
                    // the order they are found.  So we record their order in order
                    // to identify them later when examining the results of a match.
                    var indices = [
                        {key: "monthIndex", index: formatStr.indexOf("M")},
                        {key: "dayIndex", index: formatStr.indexOf("d")},
                        {key: "yearIndex", index: formatStr.indexOf("y")}
                    ];
                    indices.sort(function (a, b) {
                        return a.index - b.index;
                    });
                    var counter = 1,
                        i;

                    for (i = 0; i < 3; i++) {
                        reInfo[indices[i].key] = indices[i].index > -1 ? counter++ : null;
                    }
                }
                return reInfo;
            },

            /**
             * Converts a given time format string from MSTRWeb server to a javascript
             * regular expression that will be used to match that string against a
             * user-given value.
             * This method makes many assumptions about the format strings:
             * 1) The string may have chars "H", "h", "m", "s", "a", "z" and "Z" (case-sensitive).
             * 2) These chars above are grouped together consecutively.
             * 3) Some chars are assumed to occur a max # of times (e.g., no more than 2 "H"s, "s"s, "m"s, etc).
             * 4) A single quote (') is used to enclose a set of literal chars.
             * 5) Two single quotes ('') are used to represent a single quote.
             *
             * @param {string=} formatStr
             */
            _buildRegExp4TimeFormat: function re4TimeFmt(formatStr) {

                if (!formatStr) {
                    return null;
                }
                // Lookup local cached result.
                var reInfo = this.REGEXPS.TIMES[formatStr];
                if (!reInfo) {
                    // Cache not found, build result and cache it.
                    if (!this.REGEXPSTR_AMPM) {

                        this.REGEXPSTR_AMPM = [_DT().AM_NAME,
                            _DT().PM_NAME,
                            String(_DT().AM_NAME).toLowerCase(),
                            String(_DT().PM_NAME).toLowerCase()
                            ].join("|");
                    }
                    // The result is an object with several properties...
                    reInfo = this.REGEXPS.TIMES[formatStr] = {};
                    // The "formatStr" prop has the original format string.
                    reInfo.formatStr = formatStr;
                    // The "re" prop has a regular expression derived from the format string.
                    // This requires several string replacements:
                    // 1) First, we temporarily replace every double-single-quote with
                    // a placeholder so it will be ignored in the next step.
                    var reStr = formatStr.replace(/\'\'/g, '"');
                    // 2) Next, we temporarily remove every literal that is enclosed
                    // in single quotes, so it won't be modified by the following steps.
                    // We'll reinsert these literals back in after those steps are done.
                    var literals = reStr.match(/\'(.+?)\'/g);
                    reStr.replace(/\'(.+?)\'/g, '*');
                    // 3) we need to escape any string chars which are not:
                    // "H", "h", "m", "s", "z", "Z", "a", or white space.
                    // 4) Replace these special chars with correct placeholders.
                    //DE15538  Added "tt for the onetier application. The system locale returned
                    //this for AM and PM placeholders
                    /*DE19795,DE19852 if the formatStr contains AM/PM their regex being built is becoming invalid.
                      And also consider formatStr containing only a to represent AM/PM
                    */
                    reStr = reStr.replace(/([^H|h|m|s|z|Z|a|t|\s|A|P|M|\/])/g, "\\$1"
                    ).replace(/HH|hh/g, "(\\d\\d)"
                    ).replace(/H|h/g, "(\\d{1,2})"
                    ).replace(/mm/g, "(\\d\\d)"
                    ).replace(/m/g, "(\\d{1,2})"
                    ).replace(/ss/g, "(\\d\\d)"
                    ).replace(/s/g, "(\\d{1,2})"
                    ).replace(/a/g, "(" + this.REGEXPSTR_AMPM + ")"
                    ).replace(/AM\/PM/, "(" + this.REGEXPSTR_AMPM + ")"
                    ).replace(/tt/g, "(" + this.REGEXPSTR_AMPM + ")"
                    ).replace(/z|Z/g, "(.+?)");
                    // 5) Now we are ready to reinsert our literals back in.
                    var i,
                        len;
                    for (i = 1, len = (literals && literals.length) || 0; i < len; i++) {
                        reStr = reStr.replace(/\*/, literals[i]);
                    }
                    // 6) And we can undo our first step; replacing the double single quotes.
                    reStr = reStr.replace(/\"/g, "'");

                    // Now instantiate the reg expr object and cache it.
                    // Now instantiate the reg expr objects and cache them; one object for
                    // an "equals" match, another for a "contains" match.
                    reInfo.reEquals = new RegExp("^" + reStr + "$");
                    reInfo.reContains = new RegExp(reStr);
                    // When we apply this reg expr and a match is found, the
                    // results of match() will yield the month, day and year
                    // parts that matched the pattern.  But they'll be sorted in
                    // the order they are found.  So we record their order in order
                    // to identify them later when examining the results of a match.
                    var indices = [
                        {key: "hourIndex", index: formatStr.search(/h|H/)},
                        {key: "minIndex", index: formatStr.indexOf("m")},
                        {key: "secIndex", index: formatStr.indexOf("s")},
                        {key: "ampmIndex", index: formatStr.search(/tt|a|AM\/PM/)},
                        {key: "zoneIndex", index: formatStr.search(/z|Z/)}
                    ];
                    indices.sort(function (a, b) {
                        return a.index - b.index;
                    });
                    var counter = 1;
                    for (i = 0; i < 5; i++) {
                        reInfo[indices[i].key] = indices[i].index > -1 ? counter++ : null;
                    }
                }
                return reInfo;
            },

            /**
             * Returns true if the given date is an actual day on the calendar.
             * For example February 30th of any year would return false.
             *
             * @param {int} month
             * @param {int} day
             * @param {int} year
             * @returns {boolean}
             */
            doesDateExist: function doesDateExist(month, day, year) {
                var dt = new Date(year, month - 1, day);

                return year == dt.getFullYear() &&
                    month == dt.getMonth() + 1 &&
                    day == dt.getDate();
            },

            /**
             * Given a year integer that is between 0 and 99 inclusive,
             * this method will return a corresponding 4-digit year.
             *
             * @param {string|int} year
             */
            fourDigitYear: function fourDigitYear(year) {
                year = parseInt(Number(year), 10);
                if (!isNaN(year)) {
                    var twoDigitStart = (_DT().TWODIGITYEARSTART % 100) || 0;
                    if (year >= 0 && year <= twoDigitStart) {
                        year = 2000 + year;
                    } else if (year > twoDigitStart && year < 100) {
                        year = 1900 + year;
                    }
                }
                return year;
            },

            /**
             * Returns the 1-based (NOT 0-based) index of a given month name.  If not found, returns 0.
             * The name is searched for in the list of localized month names/abbrevs.
             *
             * @param {string|int} month
             */
            numericMonth: function numMonth(month) {
                // Were we given an integer (either as a String or a Number)? Then no work required.
                var monthInt = parseInt(Number(month), 10),
                    _A = mstrmojo.array;
                if (!isNaN(monthInt)) {
                    return monthInt;
                }

                // We were given a non-integer string. Must be a month name (long or short).
                // Search for it in our list of month names.
                var len = (month && month.length) || 0,
                    index = -1;
                if (len) {
                    // If the name is 3 chars long or shorter, start by looking in the abbreviations.
                    if (len <= 3) {
                        index = _A.indexOf(_DT().MONTHNAME_SHORT, month);
                    }
                    // If still not found, look for it in the full month names list.
                    if (index === -1) {
                        index = _A.indexOf(_DT().MONTHNAME_FULL, month);
                    }
                }
                return index + 1;
            },

            /**
             * This method converts a given integer into a string whose length is at least
             * equal to the given minimum length.  For example, if the integer 5 is passed
             * in with a given min length = 2, then this method returns "05".
             *
             * @param {int} num
             * @param {int} minLen
             *
             * @returns {string}
             */
            formatInteger: function fmtInt(num, minLen) {
                var s = String(num),
                    missing = Math.max(minLen - s.length, 0);
                if (missing > 0) {
                    var arr = [s],
                        i;
                    for (i = 1; i <= missing; i++) {
                        arr.push("0");
                    }
                    s = arr.reverse().join('');
                }
                return s;
            },

            /**
             * This method returns the first Date of a given month.
             */
            getFirstDateOfMonth: function (y, m) {
                return new Date(y, m - 1, 1);
            },

            /**
             * This method returns the Date object given values for various part of a Date object.
             */
            getDateObject: function (y, m, d, hh, mm, ss) {
                y = y || 0;
                m = m || 1;
                d = d || 1;
                hh = hh || 0;
                mm = mm || 0;
                ss = ss || 0;
                return new Date(y, m - 1, d, hh, mm, ss);
            },

            /**
             * This method returns a native Date object based on a date info object.
             */
            getDateFromDateInfo: function (dateInfo) {
                return this.getDateObject(
                    dateInfo.date && dateInfo.date.year,
                    dateInfo.date && dateInfo.date.month,
                    dateInfo.date && dateInfo.date.day,
                    dateInfo.time && dateInfo.time.hour,
                    dateInfo.time && dateInfo.time.min,
                    dateInfo.time && dateInfo.time.sec
                );
            },

            /**
             * This method returns a json given a Date object.
             */
            getDateJson: function (date) {
                return {year: date.getFullYear(), month: date.getMonth() + 1, day: date.getDate(),
                    hour: date.getHours(), min: date.getMinutes(), sec: date.getSeconds()};
            },

            /**
             * This method checks whether a year is a leap or not.
             */
            isLeapYear: function (y) {
                return !(y % 400) || (!(y % 4) && !!(y % 100));
            },

            /**
             * This method returns the number of days in a given month.
             */
            getDaysOfMonth: function (y, m) {
                var days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
                if (m == 2 && this.isLeapYear(y)) {
                    return 29;
                }
                return days[m - 1];
            },

            /**
             * This method returns a previous month of a given month.
             */
            getPreMonth: function (y, m) {
                if (m === 1) {
                    return {y: y - 1, m: 12};
                }
                return {y: y, m: m - 1};
            },

            /**
             * This method returns a next month of a given month.
             */
            getNextMonth: function (y, m) {
                if (m === 12) {
                    return {y: y + 1, m: 1};
                }
                return {y: y, m: m + 1};
            }

        }
    );

}());
(function () {

    mstrmojo.requiresCls(
        "mstrmojo.array",
        "mstrmojo.hash",
        "mstrmojo.locales");

    var _A = mstrmojo.array, MTP = mstrmojo.meta.TP, MSTP = mstrmojo.meta.STP, H = mstrmojo.hash,
        _ET = {
            ANDOR: 14,
            MQ: 10,
            MC: 12,
            AQ: 2,
            AL: 6,
            AC: 9,
            AE: 5,
            F: 13,
            R: 21,
            B: 20,
            XML: 1,
            RLS: 15 //Relation set
        },
        _ETvals = {};

    var k;
    for (k in _ET) {
        _ETvals[_ET[k]] = true;
    }

    /**
     * <p>
     * Maps expression type to a ConditionModel property that specifies the
     * expression target (if any).
     * </p>
     *
     * @private
     */
    var ET2TGT = {};
    ET2TGT[_ET.AQ] = 'a';
    ET2TGT[_ET.AL] = 'a';
    ET2TGT[_ET.AC] = 'a';
    ET2TGT[_ET.AE] = 'a';
    ET2TGT[_ET.MQ] = 'm';
    ET2TGT[_ET.MC] = 'm';
    ET2TGT[_ET.F] = 'f';
    ET2TGT[_ET.R] = 'r';
    ET2TGT[_ET.XML] = 'p';
    ET2TGT[_ET.ANDOR] = 'nds';

    /**
     * <p>
     * Maps expression type to a list of relevant ConditionModel properties.
     * </p>
     *
     * @private
     */
    var ET2C = {};
    ET2C[_ET.MQ] = [ 'not', 'm', 'fn', 'fnt', 'cs', 'dmy', 'idcsi'];
    ET2C[_ET.MC] = [ 'not', 'm', 'fn', 'fnt', 'm2', 'm3', 'p', 'dmy', 'idcsi'];
    ET2C[_ET.AE] = [ 'not', 'a', 'fn', 'es', 'a2', 'fm2', 'p'];
    ET2C[_ET.AQ] = [ 'not', 'a', 'fm', 'fn', 'cs'];
    ET2C[_ET.AL] = [ 'not', 'a', 'fm', 'fn', 'cs'];
    ET2C[_ET.AC] = [ 'not', 'a', 'fm', 'a2', 'fm2', 'a3', 'fm3', 'fn', 'cs'];
    ET2C[_ET.R] = [ 'not', 'r' ];
    ET2C[_ET.F] = [ 'not', 'f' ];
    ET2C[_ET.XML] = [ 'not', 'n', 'p' ]; // only prompt in generic type is editable
    ET2C[_ET.ANDOR] = [ 'not', 'node', 'nds', 'fn' ];

    /**
     * <p>
     * Maps expression type to an mstrmojo.expr property that specifies the
     * function lookup array.
     * </p>
     *
     * @private
     */

    var _ET2FNS = {};
    _ET2FNS[_ET.MQ] = "METRIC_FNS";
    _ET2FNS[_ET.MC] = "METRIC_FNS";
    _ET2FNS[_ET.AQ] = "FORM_FNS";
    _ET2FNS[_ET.AL] = "FORM_FNS";
    _ET2FNS[_ET.AC] = "FORM_FNS";
    _ET2FNS[_ET.AE] = "ELEM_FNS";

    var _TP = {
        FILTER: 1,
        REPORT: 3,
        METRIC: 4,
        FOLDER: 8,
        PROMPT: 10,
        FUNCTION: 11,
        ATTR: 12,
        FACT: 13,
        DIM: 14,
        FORM: 21,
        ROLE: 43, //transformation
        CONS: 47  //consolidation
    }, _STP = {
        FILTER: 256,
        CUSTOMGROUP: 257,
        PROMPT: 2560,
        PROMPT_BOOLEAN: 2561,
        PROMPT_LONG: 2562,
        PROMPT_STRING: 2563,
        PROMPT_DOUBLE: 2564,
        PROMPT_DATE: 2565,
        PROMPT_OBJECTS: 2566,
        PROMPT_ELEMENTS: 2567,
        PROMPT_EXPRESSION: 2568,
        PROMPT_EXPRESSION_DRAFT: 2569,
        PROMPT_DIMTY: 2570,
        PROMPT_BIGDECIMAL: 2571,
        REPORT_GRID: 768,
        REPORT_GRAPH: 769,
        REPORT_ENGINE: 770,
        REPORT_TEXT: 771,
        REPORT_DATAMART: 772,
        REPORT_BASE: 773,
        REPORT_GRIDGRAPH: 774,
        REPORT_NONINTERACTIVE: 775,
        REPORT_CUBE: 776,
        REPORT_EMMACUBE: 779,
        CONS: 12032,    //Consolidation
        NDE: 12033      //ConsolidationManaged
    }, OBJKEY2TP = {
        a: _TP.ATTR,
        a2: _TP.ATTR,
        m: _TP.METRIC,
        m2: _TP.METRIC,
        r: _TP.REPORT,
        f: _TP.FILTER,
        p: _TP.PROMPT
    }, OBJKEY2STP = {
        f: _STP.FILTER
    };

    /**
     * <p>
     * Maps expression type to allowed target types.
     * </p>
     *
     * @private
     */
    var ET2TP = {};
    ET2TP[_ET.MQ] = _TP.METRIC;
    ET2TP[_ET.MC] = _TP.METRIC;
    ET2TP[_ET.AQ] = _TP.ATTR;
    ET2TP[_ET.AL] = _TP.ATTR;
    ET2TP[_ET.AC] = _TP.ATTR;
    ET2TP[_ET.AE] = _TP.ATTR;
    ET2TP[_ET.F] = _TP.FILTER;
    ET2TP[_ET.R] = _TP.REPORT;

    // NOTE, can not pre-process anything in locales here,
    // since at this time, locales may still have pre-set default values,
    // we only can keep the reference, later locales maybe updated by task to have real
    // locale related strings.
    var _funcTrans = function (funs) {
            var len = funs.length,
                r = {},
                i;

            for (i = 0; i < len; i++) {
                var f = funs[i];
                r[f.did] = f.n;
            }
            return r;
        },

        _tpTrans = function (funs) {
            var len = funs.length,
                i;

            for (i = 0; i < len; i++) {
                var fun = funs[i];
                if ('tp' in fun) {
                    fun.t = fun.tp;
                }
            }
            return funs;
        },
        _fnTrans = function (funs, t) {
            var len = funs.length,
                i;

            for (i = 0; i < len; i++) {
                var fun = funs[i];
                if ('tp' in fun) {
                    if (t) {
                        fun.t = t;
                    } else {
                        delete fun.t;
                    }
                }
            }
            return funs;
        },
        _arrRep = function (funs, desc) {
            if (!desc) {
                desc = [];
            }
            // clean
            desc.length = 0;
            var i,
                len;

            for (i = 0, len = funs.length; i < len; i++) {
                desc[i] = funs[i];
            }
            return desc;
        },
        FORM_PROHIBITED = {
            0: [ // DTP.NUM
                {
                    'did': '1,76'
                },
                {
                    'did': '1,79'
                },
                {
                    'did': '1,77'
                },
                {
                    'did': '1,80'
                },
                {
                    'did': '1,78'
                },
                {
                    'did': '1,81'
                },
                {
                    'did': '1,18'
                },
                {
                    'did': '1,43'
                }
            ],
            1: [ // DTP.CHAR
                {
                    'did': '2,1'
                },
                {
                    'did': '2,2'
                },
                {
                    'did': '3,1'
                },
                {
                    'did': '3,2'
                }
            ]
            // 2: Date is FORM_PROHIBITED['2'] = FORM_PROHIBITED[0].concat(FORM_PROHIBITED[1])
        };

    var METRIC_PROHIBITED = {
        0: [
            {
                'did': '1,22'
            },
            {
                'did': '1,57'
            }
        ]
    };

    /**
     * <p>Utility of functions related to filter expressions.</p>
     *
     * @namespace mstrmojo.expr
     */
    mstrmojo.expr = mstrmojo.provide(
        "mstrmojo.expr",

        /**
         * @lends mstrmojo.expr
         */
        {
            /**
             * <p>Enumeration of expression types.</p>
             *
             * @enum {string}
             */
            ET: _ET,

            ETs: _ETvals,

            ET2TGT: ET2TGT,

            ET2COND: ET2C,

            ET2TP: ET2TP,

            /**
             * Enumeration of function ids (Integers).
             *
             * @enum {int}
             */
            FN: {
                EQUAL: 6,
                NOT_EQUAL: 7,
                GREATER: 8,
                LESS: 9,
                GREATER_EQUAL: 10,
                LESS_EQUAL: 11,
                IN_LIST: 22,
                NOT_IN_LIST: 57,
                BETWEEN: 17,
                NOT_BETWEEN: 44,
                IS_NULL: 54,
                IS_NOT_NULL: 55,
                AND: 19,
                OR: 20,
                NOT: 21,
                SEARCH: 158,
                DESCENDANT: 187
            },

            /**
             * Enumeration of function ids (Integers) for metric ranking/percentage.
             *
             * @enum {int}
             */
            FN_MRP: {
                BETWEEN: 3,
                EXCLUDE_TOP: 4,
                EXCLUDE_BOTTOM: 5,
                BETWEEN_DESCENDING: 13
            },

            /**
             * Enumeration of function types (Integers).
             *
             * @enum {int}
             */
            FNT: {
                DEF: 1,
                RANK: 2,
                PER: 3
            },

            /**
             * Delimiter used in function keys to separate function type and id.
             *
             * @type {string}
             */
            FN_SEP: ",",

            /**
             * <p>Enumeration of object types (Integers).</p>
             *
             * @enum {int}
             */
            TP: _TP,

            /**
             * <p>Enumeration of object sub-types (Integers).</p>
             *
             * @enum {int}
             */
            STP: _STP,

            /**
             * <p>Enumeration of metric dimensionality unit types (Integers).</p>
             *
             * @enum {int}
             */
            DMY_TP: {
                ATTR: -1,
                DIM: -2
            },

            /**
             * <p>Enumeration of data types (Integers).</p>
             *
             * @enum {int}
             */
            DTP: {
                UNKNOWN: -1,
                INTEGER: 1,
                UNSIGNED: 2,
                NUMERIC: 3,
                DECIMAL: 4,
                REAL: 5,
                DOUBLE: 6,
                FLOAT: 7,
                CHAR: 8,
                VARCHAR: 9,
                LONGVARCHAR: 10,
                BINARY: 11,
                VARBIN: 12,
                LONGVARBIN: 13,
                DATE: 14,
                TIME: 15,
                TIMESTAMP: 16,
                SHORT: 21,
                LONG: 22,
                MBCHAR: 23,
                BOOLEAN: 24,
                PATTERN: 25,
                BIGDECIMAL: 30
            },

            /**
             * <p>Enumeration of base form types (Integers).</p>
             *
             * @enum {int}
             */
            BFTP: {
                RESERVED: 0,
                HIDDEN: -1,
                DATETIME: 1,
                NUMBER: 2,
                TEXT: 3,
                PICTURE: 4,
                URL: 5,
                EMAIL: 6,
                TAG: 7,
                DATE: 8,
                TIME: 9,
                SYMBOL: 10,
                BIGDECIMAL: 11,
                PHONENUMBER: 12
            },

            /**
             * <p>The default metric data type.</p>
             *
             *@type {int}
             */
            METRIC_DTP: 3, // TO DO: move to mstrmojo.locales?

            /**
             * <p>Enumeration of function data types (Integers).</p>
             *
             * @enum {int}
             */
            FN_DTP: {
                NUM: 0,
                CHAR: 1,
                DATE: 2
            },

            /**
             * <Mapping of data types to prompt object sub types.
             * </p>
             *
             * @enum {int}
             */
            DTP2PROMPT_STP: {
                "-1": _STP.PROMPT,
                1: _STP.PROMPT_LONG,
                2: _STP.PROMPT_LONG,
                3: _STP.PROMPT_LONG,
                4: _STP.PROMPT_DOUBLE,
                5: _STP.PROMPT_DOUBLE,
                6: _STP.PROMPT_DOUBLE,
                7: _STP.PROMPT_DOUBLE,
                8: _STP.PROMPT_STRING,
                9: _STP.PROMPT_STRING,
                10: _STP.PROMPT_STRING,
                14: _STP.PROMPT_DATE,
                15: _STP.PROMPT_DATE,
                16: _STP.PROMPT_DATE,
                21: _STP.PROMPT_LONG,
                22: _STP.PROMPT_LONG,
                23: _STP.PROMPT_STRING,
                24: _STP.PROMPT_BOOLEAN,
                30: _STP.PROMPT_BIGDECIMAL
            },

            /**
             * <Mapping of data types to function data types.
             * </p>
             *
             * @enum {int}
             */
            DTP2FN_DTP: {
                "-1": 0,
                1: 0,
                2: 0,
                3: 0,
                4: 0,
                5: 0,
                6: 0,
                7: 0,
                8: 1,
                9: 1,
                10: 1,
                11: 0,
                12: 0,
                13: 0,
                14: 0, // was: 2; temp: use numeric functions for date forms,
                15: 0, // was: 2; temp: use numeric functions for date forms,
                16: 0, // was: 2; temp: use numeric functions for date forms,
                21: 0,
                22: 0,
                23: 1,
                24: 0,
                25: 1,
                30: 0,
                34: 0
            },
            /**
             * <p>Computes the number of constants supported by a given function.</p>
             *
             * @param {int} fn The function id.
             * @param {int} fnt The function type.
             * @returns {int}} The number of constants supported by a given function.
             */
            fnCstCount: function fcc(fn, fnt) {
                var f = this.FN,
                    FN_MRP = this.FN_MRP,
                    FNT = this.FNT;

                if (fnt === FNT.DEF || fnt === undefined) {
                    switch (fn) {
                    case f.BETWEEN: // between
                    case f.NOT_BETWEEN: // not between
                        return 2;
                    case f.IS_NULL: // is null
                    case f.IS_NOT_NULL: // is not null
                        return 0;
                    }
                } else if (fnt === FNT.PER || fnt === FNT.RANK) {
                    switch (fn) {
                    case FN_MRP.BETWEEN: // between
                    case FN_MRP.BETWEEN_DESCENDING: // between descending
                        return 2;
                    }
                }

                return 1;
            },

            /**
             * Return true if the function is either IN_LIST or NOT_IN_LIST.
             *
             * @returns {boolean}
             */
            fn_List: function fn_List(fn, fnt) {
                var f = this.FN;
                return fn == f.IN_LIST || fn == f.NOT_IN_LIST;
            },

            /**
             * Return true for the function/function type that allows AC or MC expression.
             *
             * @returns {boolean}
             */
            fn_AC_MC: function fn_AC_MC(fn, fnt) {
                var f = this.FN;
                return (fn == f.EQUAL) || (fn == f.NOT_EQUAL) || (fn == f.GREATER) || (fn == f.LESS) || (fn == f.GREATER_EQUAL) || (fn == f.LESS_EQUAL);
            },

            /**
             * Looks up the name for a given function.
             *
             * @returns {string}
             */
            fnName: function fnn(et, fn, fnt, dtp) {
                var arr = this[_ET2FNS[et]];
                if (arr && arr.constructor === Object) {
                    arr = arr[this.DTP2FN_DTP[dtp]] || arr["*"];
                }

                // TQMS936204: Support Metric Rank/Percentage functions for MQ.
                if (et === _ET.MQ) {
                    arr = arr.concat(mstrmojo.locales.expression.MetricRP);
                }

                var i = _A.find(arr, "did", (fnt || 1) + this.FN_SEP + fn);
                if (i > -1) {
                    return arr[i].n;
                }
                return '';
            },

            /**
             * Searches a given expression node and its subnodes for conditions with
             * a target (attribute, metric, embedded object).
             *
             * @param {Object} nd The expression node.
             * @param {String} idField The name of the property which specifies a target's id. Used to filter our duplicate targets from the
             *            result.
             * @param {Object} h The hash table in which to record results; if missing, one is created. Useful for building up results from
             *            separate searches in multiple expression trees.
             *
             * @returns {Object} Hashtable of all unique targets found; keyed by the given idField.
             */
            findTargets: function fndT(nd, idField, h) {
                if (!h) {
                    h = {};
                }
                if (nd) {
                    // Walk the targets (attributes, metrics).
                    var k;
                    for (k in OBJKEY2TP) {
                        var t = nd[k];
                        if (t) {
                            if (!t[MTP]) { // renamed "tp" to "t"
                                t[MTP] = OBJKEY2TP[k]; // renamed "tp" to "t"
                            }
                            if (!t[MSTP] && OBJKEY2STP[k]) {
                                t[MSTP] = OBJKEY2STP[k];
                            }
                            h[t[idField]] = t;
                        }
                    }
                    // Walk the dimensionality units (attributes; ignore dimensions).
                    if (nd.dmy) {
                        var A = this.TP.ATTR, DA = this.DMY_TP.ATTR, uts = nd.dmy.uts,
                            u,
                            uLen;

                        for (u = 0, uLen = (uts && uts.length) || 0; u < uLen; u++) {
                            var ut = uts[u];
                            if (ut && ut.utp === DA) {
                                var dt = ut.utgt;
                                if (!dt.t) {
                                    dt.t = A;
                                }
                                h[dt[idField]] = dt;
                            }
                        }
                    }

                    // If we have children, walk them (recursively).
                    var ch = nd.nds, i, len;
                    for (i = 0, len = (ch && ch.length) || 0; i < len; i++) {
                        this.findTargets(ch[i], idField, h);
                    }
                    var cs = nd.cs,
                        clen = cs && cs.length;
                    if (clen) {
                        for (i = 0; i < clen; i++) {
                            this.findTargets(cs[i], idField, h);
                        }
                    }
                }
                return h;
            },

            onLocaleUpdated: function () {
                var _STRS = mstrmojo.locales.expression,
                    _E = mstrmojo.expr;
                /**
                 * Lookup of branch qual function names.
                 */
                _E.BRANCH_FNS = H.copy(_funcTrans(_STRS.BranchQual), _E.BRANCH_FNS);
                /*{
                 19 : "AND",
                 20 : "OR",
                 21 : "NOT"
                 },*/

                /**
                 * <p>
                 * Lookup of element list functions (operators).
                 * </p>
                 */
                _E.ELEM_FNS = _arrRep(_fnTrans(_STRS.Element, 'fn'), _E.ELEM_FNS);
                /*[ {
                 did : '1,22',
                 n : 'In List',
                 t : 'fn'
                 }, // renamed "tp" to "t"; assumes mstrmojo.meta.TP is "t"
                 {
                 did : '1,57',
                 n : 'Not In List',
                 t : 'fn'
                 } // renamed "tp" to "t"
                 ],*/

                /**
                 * <p>Lookup for metric functions (operators), keyed by metric's data type
                 * ("*" = default).</p>
                 */
                _E.METRIC_FNS = {
                    "*": _fnTrans(_A.filter(_STRS.Metric.concat(_STRS.MetricRP), function (item) {
                        return item.did && (_A.find(METRIC_PROHIBITED['0'], 'did', item.did) < 0);
                    }))
                    /*[ {
                     did : '1,6',
                     'n' : 'Equal to'
                     }, {
                     did : '1,7',
                     'n' : 'Not Equal to'
                     }, {
                     did : '1,8',
                     'n' : 'Greater than'
                     }, {
                     did : '1,10',
                     'n' : 'Greater than or equal to'
                     }, {
                     did : '1,9',
                     'n' : 'Less than'
                     }, {
                     did : '1,11',
                     'n' : 'Less than or equal to'
                     }, {
                     did : '1,17',
                     'n' : 'Between'
                     }, {
                     did : '1,44',
                     'n' : 'Not between'
                     }, {
                     did : '1,54',
                     'n' : 'Is Null'
                     }, {
                     did : '1,55',
                     'n' : 'Is not null'
                     }, {
                     did : '1,22',
                     'n' : 'In'
                     }, {
                     did : '1,57',
                     'n' : 'Not in'
                     }, {
                     did : '2,1',
                     'n' : 'Highest'
                     }, {
                     did : '2,2',
                     'n' : 'Lowest'
                     }, {
                     did : '3,1',
                     'n' : 'Highest (%)'
                     }, {
                     did : '3,2',
                     'n' : 'Lowest (%)'
                     } ]*/
                };
                /**
                 * <p>Lookup for attribute form functions (operators), keyed by form's data
                 * type ("*" = default).</p>
                 */
                _E.FORM_FNS = {
                    0: // DTP.NUM
                        _fnTrans(_A.filter(_STRS.Attribute, function (item) {
                            return item.did && (_A.find(FORM_PROHIBITED['0'], 'did', item.did) < 0);
                        })),
                    1: // DTP.CHAR
                        _fnTrans(_A.filter(_STRS.Attribute, function (item) {
                            return item.did && (_A.find(FORM_PROHIBITED['1'], 'did', item.did) < 0);
                        })),
                    2: // DTP.DATE
                        _fnTrans(_A.filter(_STRS.Attribute, function (item) {
                            return item.did && (_A.find(FORM_PROHIBITED['0'], 'did', item.did) < 0) && (_A.find(FORM_PROHIBITED['1'], 'did', item.did) < 0);
                        }))

                    /*[ // DTP.NUM
                     {
                     did : '1,6',
                     n : 'Equal to'
                     }, {
                     did : '1,7',
                     'n' : 'Not Equal to'
                     }, {
                     did : '1,8',
                     'n' : 'Greater than'
                     }, {
                     did : '1,10',
                     'n' : 'Greater than or equal to'
                     }, {
                     did : '1,9',
                     'n' : 'Less than'
                     }, {
                     did : '1,11',
                     'n' : 'Less than or equal to'
                     }, {
                     did : '1,17',
                     'n' : 'Between'
                     }, {
                     did : '1,44',
                     'n' : 'Not between'
                     } ],
                     1 : [ // DTP.CHAR
                     {
                     did : '1,6',
                     n : 'Equal to'
                     }, {
                     did : '1,7',
                     'n' : 'Not Equal to'
                     }, {
                     did : '1,8',
                     'n' : 'Greater than'
                     }, {
                     did : '1,10',
                     'n' : 'Greater than or equal to'
                     }, {
                     did : '1,9',
                     'n' : 'Less than'
                     }, {
                     did : '1,11',
                     'n' : 'Less than or equal to'
                     }, {
                     did : '1,17',
                     'n' : 'Between'
                     }, {
                     did : '1,44',
                     'n' : 'Not between'
                     }, {
                     did : '1,76',
                     'n' : 'Contains'
                     }, {
                     did : '1,79',
                     'n' : 'Does not contain'
                     }, {
                     did : '1,77',
                     'n' : 'Begins with'
                     }, {
                     did : '1,80',
                     'n' : 'Does not begin with'
                     }, {
                     did : '1,78',
                     'n' : 'Ends with'
                     }, {
                     did : '1,81',
                     'n' : 'Does not end with'
                     }, {
                     did : '1,18',
                     'n' : 'Like'
                     }, {
                     did : '1,43',
                     'n' : 'Not like'
                     }, {
                     did : '1,54',
                     'n' : 'Is Null'
                     }, {
                     did : '1,55',
                     'n' : 'Is not null'
                     }, {
                     did : '1,22',
                     'n' : 'In'
                     }, {
                     did : '1,57',
                     'n' : 'Not in'
                     } ]*/
                };

                _E.DIMTYLEVELS = _arrRep(_fnTrans(_STRS.DimtyLevels), _E.DIMTYLEVELS);
                /*[ {
                 did : 0,
                 n : 'Default level'
                 }, {
                 did : 1,
                 n : 'Metric level'
                 }, {
                 did : 2,
                 n : 'Report level'
                 } ],*/
            },

            /**
             * Returns a new array with sorted objects ordered by type group then by name.
             * Types are grouped into attribute-like ones, metric-like ones, and others.
             *
             * @param objects
             * @returns {Array}
             */
            getSortedObjectsByTypeGroup: function getSortedObjectsByTypeGroup(objects) {
                var TYPE_GROUP_BUTTON = -1,// US96335: Change browse button to top of the list.
                    TYPE_GROUP_ATTRIBUTE = 0,
                    TYPE_GROUP_METRIC = 1,
                    TYPE_GROUP_GENERAL = 2;

                function typeGroup(object) {
                    switch (object.t) {
                    case _TP.METRIC:
                        return TYPE_GROUP_METRIC;
                    case _TP.ATTR:
                    case _TP.DIM:
                    case _TP.CONS:
                        return TYPE_GROUP_ATTRIBUTE;

                    case _TP.FILTER:
                        return object.st === _STP.CUSTOMGROUP ? TYPE_GROUP_ATTRIBUTE : TYPE_GROUP_GENERAL;

                    case -1:
                        return TYPE_GROUP_BUTTON;

                    default:
                        return TYPE_GROUP_GENERAL;
                    }
                }

                objects = _A.map(objects || [], function (it) {
                    return H.copy(it, {});
                });

                return objects.sort(function (o1, o2) {
                    // #1 type group
                    var typeGroupDiff = typeGroup(o1) - typeGroup(o2);
                    if (typeGroupDiff) {
                        return typeGroupDiff;
                    }

                    // #2 case-insensitive name
                    var upper1 = o1.n.toUpperCase(),
                        upper2 = o2.n.toUpperCase(),
                        upperDiff = upper1.localeCompare(upper2);

                    if (upperDiff) {
                        return upperDiff;
                    }

                    // #3 case-sensitive name
                    return o1.n.localeCompare(o2.n);
                });
            },

            /**
             * Map from base form type to data type.
             *
             * @param {Number} baseFormType Base from type.
             *
             * @return {Number} the data type.
             */
            mapBaseFormTypeToDataType: function mapBaseFormTypeToDataType(baseFormType) {
                baseFormType = parseInt(baseFormType);

                if (baseFormType === NaN) {
                    return -1;
                }

                var BFTP = this.BFTP,
                    DTP = this.DTP;

                // Same mapping in com.microstrategy.web.objects.WebAttributeFormImpl::mapBFTToDT(int).
                switch(baseFormType) {
                case BFTP.DATETIME:
                    return DTP.TIMESTAMP;
                case BFTP.DATE:
                    return DTP.DATE;
                case BFTP.TIME:
                    return DTP.TIME;
                case BFTP.NUMBER:
                    return DTP.REAL;
                case BFTP.TEXT:
                    return DTP.CHAR;
                case BFTP.BIGDECIMAL:
                    return DTP.BIGDECIMAL;
                default:
                    return DTP.CHAR;
                }

            }
        }
    );

    mstrmojo.expr.onLocaleUpdated();
}());
(function () {

    mstrmojo.requiresCls('mstrmojo.css');

    var $CSS = mstrmojo.css;

    /**
     * <p>A mixin for UI widgets that wish for their children to use a theme.
     *
     * @mixin
     * @public
     */
    mstrmojo.ui._HasUITheme = mstrmojo.provide(
        'mstrmojo.ui._HasUITheme',

        /**
         * @lends mstrmojo.ui._HasUITheme
         */
        {
            _mixinName: 'mstrmojo.ui._HasUITheme',

            /**
             * The theme class this component (and it's descendants) will use.
             *
             * @type {String}
             * @default ''
             */
            themeClassName: '',

            postBuildRendering: function postBuildRendering() {
                // Is there a theme class name?
                var themeClass = this.themeClassName;
                if (themeClass) {
                    // Trigger initial theme class change.
                    this.onthemeClassNameChange({
                        value: themeClass
                    });
                }

                return this._super();
            },

            onthemeClassNameChange: function onthemeClassNameChange(evt) {
                // Do we have a DOM node?
                var domNode = this.domNode;
                if (domNode) {
                    var newClass = evt.value,
                        oldClass = evt.valueWas;

                    // Is there a new theme class?
                    if (newClass) {
                        // Add class to DOM Node.
                        $CSS.addClass(domNode, evt.value);
                    }

                    // Is there an old class?
                    if (oldClass) {
                        // Remove class from DOM node.
                        $CSS.removeClass(domNode, evt.valueWas);
                    }
                }
            }
        }
    );

    /**
     * An enum to define the default theme names
     * @type {{LIGHT_THEME: string, DARK_THEME: string}}
     */
    mstrmojo.ui._HasUITheme.EnumThemeNames = {
      LIGHT_THEME: 'mojo-theme-light',
      DARK_THEME: 'mojo-theme-dark'
    };

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.css",
        "mstrmojo.dom",
        "mstrmojo.fx");

    var $CSS = mstrmojo.css,
        $DOM = mstrmojo.dom,
        $ARR = mstrmojo.array,
        $SB_PROPS = {
            v: {
                styleDim: 'height',
                styleDir: 'top',
                dimension: 'h',
                position: 'y',
                scroll: 'scrollTop',
                scrollDimension: 'scrollHeight',
                cls: 'vertical',
                hostCls: 'hasVertical',
                scrollNodeCls: 'hasVertical'
            },
            h: {
                styleDim: 'width',
                styleDir: 'left',
                dimension: 'w',
                position: 'x',
                scroll: 'scrollLeft',
                scrollDimension: 'scrollWidth',
                cls: 'horizontal',
                hostCls: 'hasHorizontal',
                scrollNodeCls: 'hasHorizontal'
            }
        },
        CSS_SCROLLING_MODE = 'scrollingMode',
        CSS_SCROLLING = 'scrolling',
        SCROLLBAR_MIN_BUFFER = 3;

    /*
     * Flag of Mac OS X
     * @type {boolean}
     */
    var isMac = $DOM.getOSInfo().name.toLowerCase().indexOf('mac') >= 0;

    /**
     * Returns the configured scroll host element or the parent node of the scroll node.
     *
     * @returns {HTMLElement|Node} The host node for the scrollbars.
     * @private
     */
    function getScrollbarHostNode() {
        return (this.scrollbarHostNode || (this.scrollNode && this.scrollNode.parentNode));
    }

    /**
     * @param vScrollable {boolean} whether it is scrollable vertically
     * @param hScrollable {boolean} whether it is scrollable horizontally
     */
    function toggleScrollStyle(vScrollable, hScrollable) {
        var scrollNode = this.scrollNode,
            hostNode = getScrollbarHostNode.call(this),
            scrollable = {
                v: vScrollable,
                h: hScrollable
            };

        $ARR.forEach(['v', 'h'], function (direction) {
            var scrollBarProps = $SB_PROPS[direction];
            $CSS.toggleClass(hostNode, scrollBarProps.hostCls, scrollable[direction]);
            $CSS.toggleClass(scrollNode, scrollBarProps.scrollNodeCls, scrollable[direction]);
        });
    }

    /**
     * Event listener for when the user clicks on the scroll track.
     *
     * @param {Event} evt
     * @param {window} hWin
     *
     * @private
     */
    function scrollTrackClick(evt, hWin) {
        var target = $DOM.eventTarget(hWin, evt),
            scrollNode = this.scrollNode,
            scrollNodePos = $DOM.position(scrollNode),
            scrollTrackNodes = this.scrollTrackNodes,
            scrollBarNodes = this.scrollBarNodes,
            processTrackClick = function processTrackClick(direction) {
                var isScrollTrack = target === scrollTrackNodes[direction];

                // Has the user clicked on the scroll track ?
                if (isScrollTrack) {
                    var scrollBarProps = $SB_PROPS[direction],
                        scrollBar = scrollBarNodes[direction],
                        targetPos = $DOM.position(scrollBar),
                        clickPos = $DOM.getMousePosition(evt, hWin)[scrollBarProps.position],
                        scrollbarDelta = clickPos - targetPos[scrollBarProps.position],
                        sign = scrollbarDelta > 0 ? 1 : -1,
                        scrollDimension = scrollNode[scrollBarProps.scrollDimension],
                    // Try to align the scrollbar to the center of the mouse click.
                        scrollNodeDelta = Math.abs(scrollbarDelta - (targetPos.h / 2)) * (scrollDimension / scrollNodePos[scrollBarProps.dimension]),
                        animateProps = {};

                    // Set hte property to be animated.
                    animateProps[scrollBarProps.scroll] = {
                        isStyle: false,
                        start: scrollNode[scrollBarProps.scroll],
                        stop: scrollNode[scrollBarProps.scroll] + (sign * Math.min(scrollDimension / 3, 500, scrollNodeDelta)),
                        ease: mstrmojo.ease.linear
                    };

                    // Animate the scroll top/left...
                    (new mstrmojo.fx.AnimateProp({
                        props: animateProps,
                        duration: 200,
                        interval: 10,
                        target: scrollNode
                    })).play();
                }
            };

        // Process clicks in both directions...
        processTrackClick.call(this, 'h');
        processTrackClick.call(this, 'v');
    }

    /**
     * Handler for mouse wheel event on scroll track/bar.
     * @param evt
     * @param hWin
     */
    function scrollTrackWheelHandler(evt, hWin) {
        var scrollNode = this.scrollNode,
            isMouseWheelEvt = evt.type === 'mousewheel',
        //MouseWheel event's wheelDelta is opposite to delta or the scrolling direction,
        // need to negate it to the right data for scrollingTop/Left.
            negation = isMouseWheelEvt ? -1 : 1;

        // Handle both scrolling direction
        mstrmojo.array.forEach(['h', 'v'], function (direction) {
            var scrollBarProps = $SB_PROPS[direction],
            //Chromium CEF only supports 'mousewheel' event which provides property 'wheelDelta' not 'delta'.
                wheelDeltaProp = isMouseWheelEvt ? 'wheelDelta' : 'delta',
                wheelDelta = evt[wheelDeltaProp + {h: 'X', v: 'Y'}[direction]] * negation, //wheelDelta is opposite to delta
                wheelDeltaAbs = Math.abs(wheelDelta),
                sign = wheelDelta / wheelDeltaAbs,   //scrolling direction
                isFirefoxOnWin = wheelDeltaAbs === 3 && $DOM.isFF && !isMac;

            // Mac OS X - Chrome/Firefox/Safari all provide actual scroll distance in event.deltaX/Y
            // Windows - Chrome/Safari/IE - provide actual scroll distance in event.deltaX/Y
            //         - Chrome always uses a fixed amount of 100
            //         - IEs get the amount depending on the ratio of container height(width) / scrollHeight(Width)
            //         - Firefox always provides evt.deltaX/Y as a constant (3/-3)
            //              but its actual scroll distance depends on ratio of document.documentElement height(width)/scrollHeight(width),
            //              and around constant 40 on a child element.
            //              -- It'd be ok to use browser-provided delta with Chrome/IE, but Firefox has to use 40 as a workaround below.

            // Update scrollNode scrollTop/Left to scroll
            scrollNode[scrollBarProps.scroll] += isFirefoxOnWin ? sign * 40 : wheelDelta;
        });

        $DOM.stopPropogation(hWin, evt);
        $DOM.preventDefault(hWin, evt);
    }

    /**
     * Helper function to determine whether a widget is scrollable on not in the indicated direction
     * @param direction {String} with values either 'h' ( stands for horizontal) or 'v' ( vertical)
     * @returns {boolean} If returns True, it means the widget is scrollable in the indicated direction
     */
    function iSNodeScrollable(direction) {
        var scrollBarProps = $SB_PROPS[direction],
            scrollNode = this.scrollNode,
            scrollNodePos = $DOM.position(scrollNode),
            scrollNodeDim = scrollNodePos[scrollBarProps.dimension],
            scrollDimension = scrollNode[scrollBarProps.scrollDimension],
            scrollRatio = Math.ceil(scrollNodeDim) / scrollDimension;
        return isScrollable(scrollRatio, scrollNodeDim, scrollDimension);
    }

    /**
     * Utility function which computes whether a node is scrollable or not based
     * on the given dimensions
     * @param scrollRatio
     * @param scrollNodeDim  {number} either (height) or w (width) of the node
     * @param scrollDimension {number} either 'scrollHeight' or 'scrollWidth' of the node
     * @returns {boolean} If returns True, it means the widget is scrollable in the indicated direction
     */
    function isScrollable(scrollRatio, scrollNodeDim, scrollDimension) {
        return (!isNaN(scrollRatio) && scrollRatio < 1) && (Math.abs(scrollNodeDim - scrollDimension) > SCROLLBAR_MIN_BUFFER);
    }

    /**
     * Private helper function to set up the scrollbar nodes for a single direction.  If this function returns true if means
     * that the widget is scrollable in the indicated direction.
     *
     * @param {String} direction
     *
     * @returns {boolean}
     * @private
     */
    function setupScrollBars(direction) {
        var px = 'px',
            scrollBarProps = $SB_PROPS[direction],
            scrollNode = this.scrollNode,
            hostNode = getScrollbarHostNode.call(this),
            scrollNodePos = $DOM.position(scrollNode),
            scrollNodeDim = scrollNodePos[scrollBarProps.dimension],
            scrollDimension = scrollNode[scrollBarProps.scrollDimension],
            scrollRatio = Math.ceil(scrollNodeDim) / scrollDimension,
            scrollBarNodes = this.scrollBarNodes,
            scrollBar = scrollBarNodes[direction],
            scrollTrackNodes = this.scrollTrackNodes,
            scrollTrack = scrollTrackNodes[direction],
            isNodeScrollable = isScrollable(scrollRatio, scrollNodeDim, scrollDimension),
            scrollCSSClass = scrollBarProps.cls;

        // Do we not have a scrollbar node in this direction?
        if (!scrollBar) {
            // Create the scroll track node.
            scrollTrack = scrollTrackNodes[direction] = document.createElement('div');

            // Attach a click listener on the scroll track and trigger it on the widget..
            var widget = this,
                clickHandler = function (e) {
                    scrollTrackClick.call(widget, e);
                },
                wheelHandler = function (e) {
                    scrollTrackWheelHandler.call(widget, e);
                },
                registerEventListener = function (e, evt, h) {
                    $DOM.attachEvent(e, evt, h);
                    widget.installedEventListeners.push({
                        e: e,
                        evt: evt,
                        fn: h
                    });
                };

            registerEventListener(scrollTrack, 'click', clickHandler);

            // Add specific class names and the direction class name to the scroll bar.
            scrollTrack.className = 'mstrmojo-scrolltrack ' + scrollCSSClass;

            // Create the scroll indicator.
            scrollBar = scrollBarNodes[direction] = document.createElement('div');


            // Add specific class names and the direction class name to the scroll bar.
            scrollBar.className = 'mstrmojo-scrollbar ' + scrollCSSClass;

            // Append the scrollbar to it's corresponding scroll track node.
            scrollTrack.appendChild(scrollBar);

            // Append both the scrollbar nodes in the host node.
            hostNode.appendChild(scrollTrack);

            // Attach mouse wheel event listener on the scrollTrack/scrollBar nodes
            //Chromium CEF only supports 'mousewheel'.
            var wheelEvent = mstrApp.isSingleTier ? 'mousewheel' : 'wheel';

            registerEventListener(scrollTrack, wheelEvent, wheelHandler);
            registerEventListener(scrollBar, wheelEvent, wheelHandler);
        }

        var scrollBarStyle = scrollBar.style,
            percentageScrolled = (scrollNode[scrollBarProps.scroll] / scrollNode[scrollBarProps.scrollDimension]),
            scrollNodeDelta = $DOM.delta(scrollNode, getScrollbarHostNode.call(this))[scrollBarProps.position],
            scrollTrackStyle = scrollTrack.style;

        // Is the scroll node scrollable?
        if (isNodeScrollable) {
            // In case the scroll node is offset from the scroll host, adjust the track.
            scrollTrackStyle[scrollBarProps.styleDir] = scrollNodeDelta + px;

            // Set the scrollbar's dimension.

            var scrollbarDim = scrollRatio * scrollNodeDim, //Scrollbar Height or Width
                MIN_DIM = 35, //MIN Height/Width
                scrollBarDir = scrollNodeDim * percentageScrolled, //ScrollBar Top/Left direction
                maxDir = scrollNodeDim - 35; //Max Top/Left

            // DE92549;pay respect to the minWith/minHeight:35px
            scrollBarStyle[scrollBarProps.styleDim] = (scrollbarDim < MIN_DIM ? MIN_DIM : scrollbarDim) + px;
            // Set the position of the scroll bar based on the scroll position
            scrollBarStyle[scrollBarProps.styleDir] = (scrollBarDir > maxDir ? maxDir : scrollBarDir) + px;
        }

        return isNodeScrollable;
    }

    /**
     * Returns whether the application should show scrollbars.
     *
     * @returns {boolean}
     */
    function shouldShowScrollbars() {
        // Return false for SingleTier Macs since the native Mac scrollbar is pretty cool!
        return !(mstrApp.isSingleTier && isMac);
    }

    /**
     * <p>A mixin for widgets that have a customized scroller.</p>
     *
     * @mixin
     * @public
     */
    mstrmojo.ui._HasScroller = mstrmojo.provide(
        'mstrmojo.ui._HasScroller',

        /**
         * @lends mstrmojo.ui._HasScroller
         */
        {
            _mixinName: "mstrmojo.ui._HasScroller",

            /**
             * Flag denoting whether the widget supports custom scrollbars.
             * @type {boolean}
             * @default null
             */
            hasCustomScrollbar: null,

            /**
             * The widget needs to be draggable to drag the scrollbars.
             *
             * @type {Boolean}
             * @default true
             */
            draggable: true,

            /**
             * Denotes that the widget will provide it's own avatar.
             *
             * @type {boolean}
             */
            ownAvatar: true,

            /**
             * <p>The scroll node to have the customized scrollbar.</p>
             *
             * @type {HTMLElement|Node}
             * @default undefined
             */
            scrollNode: undefined,

            /**
             * <p>An optional host node for the scrollbar nodes. If not specified, defaults to the parent of the scrollNode.</p>
             *
             * @type {HTMLElement|Node}
             * @default undefined
             * @optional
             */
            scrollbarHostNode: undefined,

            /**
             * <p>Internal property to hold the collection of the scrollbar dom nodes.</p>
             *
             * @ignore
             */
            scrollBarNodes: undefined,

            /**
             * <p>Abstract function that should be implemented to setup the scroll nodes for the scroller.</p>
             */
            setupScrollNodes: mstrmojo.emptyFn,

            /**
             * DOM event listeners attached that need disposing on destroy()
             * @type {Array}
             */

            installedEventListeners: null,


            init: function init(props) {
                // Call super.
                this._super(props);

                // Check if the scrollbars are supported and set it on a local property.
                if (this.hasCustomScrollbar === null) {
                    this.hasCustomScrollbar = shouldShowScrollbars();
                }

                this.installedEventListeners = [];
            },

            onRender: function onRender() {
                if (this._super) {
                    // Call Super.
                    this._super();
                }

                // Update the scroller config.
                this.updateScrollbars();

                this.addScrollNodeProperties();

            },

            /**
             * Add scroll node properties.
             * Refactored onRender() due to DE21236
             */
            addScrollNodeProperties: function addScrollNodeProperties() {

                var scrollNode = this.scrollNode,
                    isFirefoxOnWin = $DOM.isFF && !isMac;

                // Do we have a scroll node ready ?
                if (scrollNode) {
                    // Set an event listener to hear on the scroll node. TODO: How do we detect if a node already has a scroll listener?
                    var fnEventHandler = $DOM.attachMarkupEvent(this.id, scrollNode, 'scroll');

                    // Add to listener collection so that it can be disposed when unrendering.
                    this.installedEventListeners.push({
                        e: scrollNode,
                        evt: 'scroll',
                        fn: fnEventHandler
                    });
                }
                // Labels the browser type for browser/OS types that need special CSS properties
                if (isFirefoxOnWin) {
                    $CSS.addClass(scrollNode, 'firefox-on-windows');
                } else if ($DOM.isEdge) {
                    $CSS.addClass(scrollNode, 'ms-edge');
                }

                // Are the custom scrollbars not supported ?
                if (!this.hasCustomScrollbar) {
                    // Add a CSS class to ensure that the overflow is set up correctly on the scroll host node.
                    $CSS.addClass(getScrollbarHostNode.call(this), 'mstrmojo-sb-host-show-default');

                    // Add a CSS class to ensure that the overflow is set up correctly on the scroll node.
                    $CSS.addClass(scrollNode, 'mstrmojo-sb-show-default');

                    // Return - nothing to do here.
                    return;
                }

                // Do we have a scroll node ready ?
                if (scrollNode) {
                    // Add a CSS class on the host node.
                    $CSS.addClass(getScrollbarHostNode.call(this), 'mstrmojo-scrollbar-host');

                    // Add a CSS class on the scroll node.
                    $CSS.addClass(scrollNode, 'mstrmojo-scrollNode');
                }
            },

            /**
             * <p>This function creates and updates the scrollbars dimension and position to match that of the scroll position
             * of the given node.</p>
             */
            updateScrollbars: function updateScrollbars() {
                // If the widget is not rendered - return!
                if (!this.hasRendered) {
                    return;
                }

                // Set up the scroll nodes.
                this.setupScrollNodes();

                var scrollNodeStyle,
                    RESET = false;

                // Check if the custom scrollbars are not supported and if not, return.
                if (!this.hasCustomScrollbar) {

                    /*DE18334-In mac one tier which uses the native scroll bars, unnecessary scroll bar is shown in the horizontal direction
                    * in certain scenario. With this change it will be avoided because we use SCROLLBAR_MIN_BUFFER */
                    if (this.scrollNode) {
                        scrollNodeStyle = this.scrollNode.style;
                        scrollNodeStyle.overflowY = iSNodeScrollable.call(this, 'v') ? 'scroll' : 'hidden';
                        scrollNodeStyle.overflowX = iSNodeScrollable.call(this, 'h') ? 'scroll' : 'hidden';
                    }
                    return;
                }

                // Do we have the scroll node configured?
                if (this.scrollNode) {
                    // Initialize the scrollbarNodes and track nodes collection if not already created.
                    this.scrollBarNodes = this.scrollBarNodes || {};
                    this.scrollTrackNodes = this.scrollTrackNodes || {};

                    //DE116270;Reset vertical and horizontal scroll bar as non-scrollable,
                    //to avoid padding affecting calculating whether we should enable scroll in setupScrollBars
                    toggleScrollStyle.call(this, RESET, RESET);

                    // Set up the scroll bar positions and dimensions.  If either dimension returns true then set overflow of scroll node to scroll.
                    scrollNodeStyle = this.scrollNode.style;
                    // TQMS948129: In Chrome when one direction is scrollable and the other is not, and the scroll node's height is very close to scrollHeight, unexpected native scroll bar will show.
                    // Change 'visible' to 'hidden' when there is no need to scroll.
                    var vScrollable = setupScrollBars.call(this, 'v'),
                        hScrollable = setupScrollBars.call(this, 'h');
                    scrollNodeStyle.overflowY = vScrollable ? 'scroll' : 'hidden';
                    scrollNodeStyle.overflowX = hScrollable ? 'scroll' : 'hidden';
                    toggleScrollStyle.call(this, vScrollable, hScrollable);
                }
            },

            onscroll: function onscroll() {
                var scrollNode = this.scrollNode;

                // Do we have a scroll node and do we support custom scrollbars ?
                if (scrollNode && this.hasCustomScrollbar) {
                    var getNumber = function getNumber(value) {
                            var n = parseInt(value);
                            return n === null || isNaN(n) ? 0 : n;
                        },
                        scrollNodePos = $DOM.position(scrollNode),
                        scrollNodeHeight = scrollNodePos.h - getNumber($CSS.getStyleValue(scrollNode, "padding-bottom")),
                        scrollNodeWidth = scrollNodePos.w - getNumber($CSS.getStyleValue(scrollNode, "padding-right")),
                        scrollBarNodes = this.scrollBarNodes,
                        vScrollBar = scrollBarNodes.v,
                        hScrollBar = scrollBarNodes.h;

                    // Update the position of the scrollbar nodes based on the scroll position.
                    if (scrollNode.scrollHeight - scrollNodeHeight > 0) {
                        vScrollBar.style.top = ((scrollNodeHeight - $DOM.position(vScrollBar).h) * (scrollNode.scrollTop / (scrollNode.scrollHeight - scrollNodeHeight))) + 'px';
                    }
                    if (scrollNode.scrollWidth - scrollNodeWidth > 0) {
                        hScrollBar.style.left = ((scrollNodeWidth - $DOM.position(hScrollBar).w) * (scrollNode.scrollLeft / (scrollNode.scrollWidth - scrollNodeWidth))) + 'px';
                    }
                }

                // Call super if it exists
                if (this._super) {
                    this._super();
                }

                // Call on scroll end hook.
                if (this.onScrollEnd) {
                    this.onScrollEnd();
                }
            },

            getDragData: function getDragData(context) {
                var scrollNode = this.scrollNode,
                    scrollNodePos = $DOM.position(scrollNode),
                    sourceNode = context.src.node,
                    scrollbarNodes = this.scrollBarNodes;

                // Is the user dragging the scroll bar node?
                if (this.isDraggingScrollBar(context)) {
                    return {
                        isScrollBar: true,
                        direction: sourceNode === scrollbarNodes.v ? 'v' : 'h',
                        scrollTop: scrollNode.scrollTop,
                        scrollLeft: scrollNode.scrollLeft,
                        conversionRatio: {
                            y: scrollNode.scrollHeight / scrollNodePos.h,
                            x: scrollNode.scrollWidth / scrollNodePos.w
                        }
                    };
                }

                return (this._super && this._super(context));
            },

            isDragValid: function isDragValid(context) {
                // If dragging scroll bar return true, otherwise return super or default to false.
                return this.isDraggingScrollBar(context) || (this._super && this._super(context)) || false;
            },

            /**
             * Helper function that checks if the user is dragging the scrollbar nodes.
             *
             * @param {Object} context The drag context object.
             * @returns {boolean} True if the user is dragging one of the scrollbar nodes.
             */
            isDraggingScrollBar: function isDraggingScrollBar(context) {
                var sourceNode = context.src.node,
                    scrollbarNodes = this.scrollBarNodes;

                return !!scrollbarNodes && (sourceNode === scrollbarNodes.v || sourceNode === scrollbarNodes.h);
            },

            ondragstart: function ondragstart(context) {
                // Are we dragging the scroll bars?
                if (this.isDraggingScrollBar(context)) {
                    // Attach a CSS class on the scroll node if we're dragging the scrollbar.
                    $CSS.addClass(context.src.node, CSS_SCROLLING);
                    $CSS.addClass(getScrollbarHostNode.call(this), CSS_SCROLLING_MODE);
                }

                if (this._super) {
                    this._super(context);
                }
            },

            shouldDragBubble: function shouldDragBubble(context) {
                var sourceNode = context.src.node,
                    scrollTrackNodes = this.scrollTrackNodes;

                // Prevent the drag from bubbling if the user clicked on the track nodes...
                return !(!!scrollTrackNodes && (sourceNode === scrollTrackNodes.v || sourceNode === scrollTrackNodes.h));
            },

            ondragmove: function ondragmove(context) {
                // Are we dragging the scroll bars?
                if (this.isDraggingScrollBar(context)) {
                    var target = context.tgt,
                        source = context.src,
                        targetPos = target.pos,
                        sourcePos = source.pos,
                        sourceNode = source.node,
                        scrollNode = this.scrollNode,
                        scrollbarNodes = this.scrollBarNodes,
                        dragData = source.data,
                        scrollbarDelta = {
                            y: (targetPos.y - sourcePos.y),
                            x: (targetPos.x - sourcePos.x)
                        },
                        conversionRatio = dragData.conversionRatio;

                    // Are we dragging the vertical scrollbar?
                    if (sourceNode === scrollbarNodes.v) {
                        // Set the scroll top so that that onscroll is triggered.
                        scrollNode.scrollTop = dragData.scrollTop + (scrollbarDelta.y * conversionRatio.y);
                    } else {
                        // Set the scroll left for the horizontal scrollbar.
                        scrollNode.scrollLeft = dragData.scrollLeft + (scrollbarDelta.x * conversionRatio.x);
                    }
                }

                // Call super
                if (this._super) {
                    this._super(context);
                }
            },

            ondragend: function ondragend(context) {
                // Are we dragging the scroll bars?
                //TODO:
                //DE71088, FilterExprTree.js getItemConfig function will override
                //ondragend function in tree node, which will cause problem
                //need to delete sanity check in the future.
                if (this.isDraggingScrollBar && this.isDraggingScrollBar(context)) {
                    // Remove the scrolling css class.
                    $CSS.toggleClass(context.src.node, CSS_SCROLLING, false);
                    $CSS.toggleClass(getScrollbarHostNode.call(this), CSS_SCROLLING_MODE, false);
                }

                // Call super
                if (this._super) {
                    this._super(context);
                }
            },

            widgetResized: function widgetResized() {
                if (this._super) {
                    this._super();
                }

                // If the widget's resized - update the scrollbars.
                this.updateScrollbars();
            },

            unrender: function unrender(ignoreDom) {
                // Clean up.

                $ARR.forEach(this.installedEventListeners, function (h) {
                    $DOM.detachEvent(h.e, h.evt, h.fn);
                });
                this.installedEventListeners = [];
                // Delete all the old properties.
                delete this.scrollNode;
                delete this.scrollbarHostNode;
                delete this.scrollBarNodes;
                delete this.scrollTrackNodes;

                // Call Super.
                this._super(ignoreDom);
            },

            /**
             * Returns the default Scroll bar properties for the given direction
             * @param direction
             *         Should be a String with values either 'h' or 'v'
             *         'h' - Stands for Horizontal
             *         'v' - Stands for Vertical
             */
            getDefaultScrollBarProps: function getDefaultScrollBarProps(direction) {
                return $SB_PROPS[direction];
            },

            disableScroll: function disableScroll(x, y) {
                var scrollNode = this.scrollNode,
                    hostNode = getScrollbarHostNode.call(this);

                $ARR.forEach(['v', 'h'], function (direction) {
                    var scrollBarProps = $SB_PROPS[direction];
                    $CSS.toggleClass(hostNode, scrollBarProps.hostCls, false);
                    $CSS.toggleClass(scrollNode, scrollBarProps.scrollNodeCls, false);
                });

                if (scrollNode) {
                    if (y || y === undefined) {
                        scrollNode.style.overflowY = 'hidden';
                    } else if (scrollNode.style.overflowY === 'hidden') {
                        scrollNode.style.overflowY = 'auto';
                    }
                    if (x || x === undefined) {
                        scrollNode.style.overflowX = 'hidden';
                    }
                }
            },

            enableScroll: function enableScroll() {
                this.updateScrollbars();
                //DE70781: special handling for Mac One-Tier
                if (!this.hasCustomScrollbar && this.scrollNode) {
                    this.scrollNode.style.overflowY = iSNodeScrollable.call(this, 'v') ? 'scroll' : 'hidden';
                }
            },

            /**
             * Custom shim for scrollIntoViewIfNeeded functionality that
             * scrolls an element outside scrolling area into view.
             * @param element The DOM element to scroll into view.
             *
             */
            scrollIntoViewIfNeeded: function (element) {
                var parent = this.scrollNode,
                    elementHeight = element.clientHeight,
                    parentHeight = parent.clientHeight,
                    elementPos = $DOM.position(element).y,
                    parentPos = $DOM.position(parent).y,
                    offsetTopDelta = elementPos - parentPos, // element's DOM position relative to its scrollNode
                    beyondTop = offsetTopDelta < 0, // element is on top beyond the scrolling area
                    beyondBottom = offsetTopDelta + elementHeight > parentHeight; // element is on bottom beyond the scrolling area

                // If element is hidden from view, display it within window,
                // at the scrolling area's center (or as close as possible).
                if (beyondTop || beyondBottom) {
                    parent.scrollTop += offsetTopDelta + elementHeight / 2 - parentHeight / 2;
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.dom",
        "mstrmojo.css");

    var $DOM = mstrmojo.dom,
        TOOLTIP_CLOSE_DELAY = 100,
        TOOLTIP_OPEN_DELAY = 700; //DE60490;change tooltipdisplaydelay back to 0.7s

    var SAFARI_HIDE_TOOLTIP_CLASS = "mojo-safari-hide-nativeTooltip",
        $CSS = mstrmojo.css;


    /**
     * Returns a function for handling mousemove or mouseover for the tooltip node.
     *
     * @param {string} id The widget ID.
     * @param {boolean} isDynamic Whether the tooltip show be attached to mousemove or mouseover.
     *
     * @returns {function(e:Event)}
     */
    function getTooltipHandler(id, isDynamic) {
        return function (e) {
            // Show (or hide) the tooltip.
            var widget = mstrmojo.all[id];
            if (widget.customTooltipHandler) {
                widget.customTooltipHandler(e);  // add custom handler
            }
            widget[(isDynamic ? 'move' : 'show') + 'Tooltip'](e, self);
        };
    }

    function attachTooltipEvents() {
        var node = this.tooltipNode || this.domNode,
            id = this.id,
            i,
            funcName = "_ontooltip" + (this.isDynamicTooltip ? "move" : "over");

        if (!this._ontooltipout) {
            this._ontooltipout = function (e) {
                mstrmojo.all[id].hideTooltip(e, self);
            };
        }
        if (!this[funcName]) { //mizhang. If and only if _ontooltipover is null, set default tooltip handler.
            this[funcName] = getTooltipHandler(id, this.isDynamicTooltip);
        }

        // Make sure node is an array.
        node = [].concat(node);

        // Iterate nodes.
        for (i = 0; i < node.length; i++) {
            // Make sure there is not a native tooltip.
            node[i].removeAttribute('title');

            // Attach event listeners.
            $DOM.attachEvent(node[i], (this.isDynamicTooltip ? "mousemove" : "mouseover"), this[funcName]);
            $DOM.attachEvent(node[i], 'mouseout', this._ontooltipout);
        }
    }

    function detachTooltipEvents() {
        var node = this.tooltipNode || this.domNode,
            i;

        if (node && node.constructor !== Array) {
            node = [node];
        }

        if (node) {
            var over = this._ontooltipover,
                out = this._ontooltipout,
                move = this._ontooltipmove;

            for (i = 0; i < node.length; i++) {
                // Do we have a mouse over handler?
                if (over) {
                    // Detach it.
                    $DOM.detachEvent(node[i], 'mouseover', over);
                }

                // Do we have a mouse out handler?
                if (out) {
                    // Detach it.
                    $DOM.detachEvent(node[i], 'mouseout', out);
                }

                if (move) {
                    $DOM.detachEvent(node[i], 'mousemove', move);
                }
            }
        }

    }

    /**
     * Mixin to provide rich tooltip functionality.
     *
     * @mixin
     * @public
     */
    mstrmojo._HasTooltip = mstrmojo.provide(
        'mstrmojo._HasTooltip',

        /**
         * @lends mstrmojo._HasTooltip
         */
        {

            /**
             * <p>The tooltip for this widget.</p>
             *
             * @type {string}
             */
            tooltip: '',

            /**
             * <p>The rich tooltip for this widget. </p>
             *
             * <p>It can be a string or a JSON object. If it is a JSON object, it can include the following information:</p>
             *
             *     <ul>
             *         <li>areaId - anything that uniquely identifies an area in the widget, like item index, slot name, DOM node, ...
             *         Moving to another area will incur a tooltip open delay.
             *         Areas are useful for lists and other widgets that display different tooltips for different visual areas.
             *         By default, the whole widget is a single area with areaId = undefined.</li>
             *         <li>content - the content to put into the rich tooltip. It can be HTML code.</li>
             *         <li>cssClass - the css class to be used for the tooltip</li>
             *         <li>top/left - the position of the tooltip </li>
             *         <li>keepArrowXPos/keepArrowYPos - under which axis we should keep the arrow if it has one when tooltip reposition happens.</li>
             *         <li>enableHover - whether we allow the user to mouse hover the tooltip. This also introduces a scrollbar if the content dose not fit<li>
             *     </ul>
             *
             * <p>If it is a string, then the string will be used as content, and rich tooltip will use its default implementation
             * for positioning and css class.</p>
             *
             * @type {string|{areaId:String, content:String, cssClass: String, top: String, left: String, keepArrowXPos: String, keepArrowYPos: String}}
             */
            richTooltip: null,

            /**
             * <p>The flag to control whether to use the rich tooltip.</p>
             *
             * When this flag is set to true, then rich tooltip will be used.
             * If richTooltip is defined, then it will be used. If richTooltip is not defined, then tooltip will be used.
             *
             * @type {boolean}
             */
            useRichTooltip: false,

            /**
             * <p>Should we invoke showTooltip based on mouse position</p>
             * @type {boolean}
             */
            isDynamicTooltip: false,

            /**
             * The node which will listen to mouse over/out event for rich tooltip feature. If this node is null, then the domNode will be used.
             *
             * @type {HTMLElement}
             */
            tooltipNode: null,

            /**
             * How long we need to wait to see the tooltip since last mousemove. The delay will not be applied if there is already a open tooltip for the widget.
             *
             */
            tooltipOpenDelay: 700,

            /**
             * Ingore tooltip close delay. Added for DE60490
             */
            isIgnoreTooltipCloseDelay: false,

            /**
             * Tooltip content to display widget instead html/text
             */
            hasWidgetContent: false,

            /**
             * delay to close tooltip
             * to specify a value for hasWidgetContent tooltip
             */
            tooltipCloseDelay: TOOLTIP_CLOSE_DELAY,

            /**
             * Whether the widget has a tooltip open right now.
             *
             * @type {boolean}
             */
            hasOpenTooltip: false,

            postBuildRendering: function () {
                var ret = this._super();

                // Do we have a rich tooltip?
                if (this.useRichTooltip) {
                    attachTooltipEvents.call(this);
                }

                return ret;
            },

            /**
             * Toggle useRichTooltip property on the fly by attaching and detaching corresponding event listeners.
             * TQMS 937143
             */
            onuseRichTooltipChange: function onuseRichTooltipChange() {
                if (this.hasRendered) {
                    // Do we have a rich tooltip?
                    if (this.useRichTooltip) {
                        attachTooltipEvents.call(this);
                        //@TODO  we should consider invoke showTooltip based on mouse position
                    } else {
                        detachTooltipEvents.call(this);
                        this.hideTooltip();
                    }
                }
            },

            /**
             * <p>Shows the tooltip.</p>
             *
             * @param {Event} e
             * @param {window} win
             */
            showTooltip: function showTooltip(e, win) {
                var $this = this;
                // Is the tooltip NOT already open or is the app not interactive?
                if (!$this.hasOpenTooltip && (!mstrApp.isInteractive || mstrApp.isInteractive && mstrApp.isInteractive())) {
                    mstrmojo.requiresCls("mstrmojo.tooltip");
                    if (this.updateTooltipConfig) {
                        this.updateTooltipConfig(e);
                    }
                    window.clearTimeout(this._tooltipTimeOut);

                    /*
                     It looks that for IE the event object is not passed when the thread is lost (setTimeout) so
                     a copy of the event has to be made. TQMS:838277
                     http://stackoverflow.com/questions/3531751/member-not-found-ie-error-ie-6-7-8-9
                     */
                    if (mstrmojo.dom.isIE) {
                        var eventCopy = {};
                        for (var i in e) {
                            eventCopy[i] = e[i];
                        }
                        e = eventCopy;
                    }

                    // Add a lag when hovering an inactive area. Use a time out to show tooltip.
                    // When we open a tooltip on an area, the area becomes active. It keeps active until we leave the area for a certain duration.
                    var newAreaId = this.richTooltip ? this.richTooltip.areaId : undefined;

                    if ($DOM.isSafari && e) {
                        var src = e.srcElement;
                        if (window.getComputedStyle(src)["text-overflow"] === 'ellipsis') { //DE52010 safari would pop up tooltip only when text-overflow as ellipsis
                            this.baseElement = src;
                            $CSS.toggleClass(src, SAFARI_HIDE_TOOLTIP_CLASS, true);
                        }
                    }

                    this._tooltipTimeOut = window.setTimeout(function () {
                        var richTooltip = $this.richTooltip;

                        if ($this._closeTooltipTimeout) {
                            window.clearTimeout($this._closeTooltipTimeout);
                            delete $this._closeTooltipTimeout;
                        }

                        mstrmojo.tooltip.open($this, e, win);


                        $this.tooltip.onmouseover = function () {
                            if ($this.richTooltip && $this.richTooltip.enableHover) {
                                window.clearTimeout($this._closeTooltipTimeout);
                                window.clearTimeout($this._deactivationTimeout);

                                if ($this.tooltip) {
                                    $this.tooltip.onmouseout = function (evt) {
                                        //US70225;handle cases when toElement|RelatedTarget is null, since when mouse out of browser, toElement and RelatedTarget would be null. Otherwise, $DOM.contain would throw error
                                        var e = evt.e;
                                        if ((!e.toElement && !e.relatedTarget) || !$DOM.contains(this.domNode, evt.e.toElement || evt.e.relatedTarget)) {
                                            $this.hideTooltip();
                                        }
                                    };
                                }
                            }
                        };

                        $this.tooltip.allowOtherTooltips = $this.allowOtherTooltips;

                        if (richTooltip && richTooltip.onClose) {
                            $this.tooltip.onClose = richTooltip.onClose;
                        }

                        $this.hasOpenTooltip = true;
                        $this._hasActiveArea = true;
                        $this._tooltipAreaId = newAreaId;

                        window.clearTimeout($this._deactivationTimeout);
                        delete $this._deactivationTimeout;

                    }, (this._hasActiveArea && newAreaId && newAreaId === this._tooltipAreaId) ? 0 : this.tooltipOpenDelay); // TQMS961158: Don't delay if newAreaId is not set by default.
                }
            },

            /**
             * <p>If tooltip is invoked based on mouse position, call this function</p>
             *
             * @param evt
             * @param win
             */
            moveTooltip: function moveTooltip(evt, win) {
                // if the mouse is moving, the tooltip should not be shown.
                if (this._tooltipTimeOut) {
                    window.clearTimeout(this._tooltipTimeOut);
                    this._tooltipTimeOut = null;
                    mstrmojo.tooltip.close();
                }

                var _this = this,
                    _evt = evt,
                    _win = win;

                this._tooltipTimeOut = setTimeout(function () {
                    mstrmojo.tooltip.open(_this, _evt, _win);
                }, this.tooltipOpenDelay);
            },

            /**
             * <p>Hides the tooltip.</p>
             */
            hideTooltip: function hideTooltip() {
                var $this = this;

                // Don't show tooltip if the mouse has moved out from button but the time out is still not triggered.
                window.clearTimeout(this._tooltipTimeOut);

                if ($DOM.isSafari && this.baseElement) {
                    $CSS.toggleClass(this.baseElement, SAFARI_HIDE_TOOLTIP_CLASS, false);
                }

                if (this._closeTooltipTimeout) {
                    window.clearTimeout(this._closeTooltipTimeout);
                }

                // If the mouse has been out of the active area for more than a duration, clear the active area.
                if (this._hasActiveArea && !this._deactivationTimeout) {
                    this._deactivationTimeout = window.setTimeout(function () {
                        delete $this._deactivationTimeout;

                        delete $this._hasActiveArea;
                        delete $this._tooltipAreaId;
                    }, 100);
                }

                mstrmojo.requiresCls("mstrmojo.tooltip");
                //DE60490;for dragging, always hide tooltip immediately, without delay
                if ((!this.isIgnoreTooltipCloseDelay) && $this.richTooltip && $this.richTooltip.enableHover) {
                    this._closeTooltipTimeout = window.setTimeout(function () {
                        mstrmojo.tooltip.close();

                        delete $this._closeTooltipTimeout;
                    }, $this.richTooltip.tooltipCloseDelay || this.tooltipCloseDelay);
                } else if ($this.tooltip) { // Do not close other tooltips if this one doesn't exist anymore
                    this.isIgnoreTooltipCloseDelay = false;//reset to default false
                    mstrmojo.tooltip.close();
                }
                this.hasOpenTooltip = false;
            },

            unrender: function unrender(ignoreDom) {
                detachTooltipEvents.call(this);

                this._super(ignoreDom);
            }
        }
    );

    mstrmojo._HasTooltip.TOOLTIP_OPEN_DELAY = TOOLTIP_OPEN_DELAY;
    mstrmojo._HasTooltip.TOOLTIP_CLOSE_DELAY = TOOLTIP_CLOSE_DELAY;
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Base",
                         "mstrmojo.registry",
                         "mstrmojo._Provider",
                         "mstrmojo.array");

    var $REG = mstrmojo.registry,
        $ARR = mstrmojo.array;

    /**
     * <p>Base class for an observable object.</p>
     *
     * <p>When an instance of Obj is constructed, it is automatically added to the "mstrmojo.all" collection, keyed by its
     * "id" property (if missing, an id will be auto-generated).  Hence the instance can be used with the "publisher" system
     * (mstrmojo.publisher) for raising and listening to "events". When the instance's "destroy" method is called, it is
     * removed from the "all" collection and from the publisher system.</p>
     *
     * <p>Each instance can have any arbitrary set of properties and values.  The instance has a "set" method for updating
     * its property values.  The "set" method is capable of raising an "event" which can then be heard by other objects who wish
     * to be notified of a change in the state of the instance. Those objects can sign up as "listeners" for events by calling the
     * "attachEventListener" and "removeEventListener" methods.</p>
     *
     * @class
     * @extends mstrmojo.Base
     * @mixes mstrmojo._Provider
     */
    mstrmojo.Obj = mstrmojo.declare(
        mstrmojo.Base,

        [ mstrmojo._Provider ],

        /**
         * @lends mstrmojo.Obj.prototype
         */
        {
            /**
             * The fully qualified class name for this object.
             *
             * @type String
             */
            scriptClass: "mstrmojo.Obj",

            /**
             * <p>The ID of this object.</p>
             *
             * <p>Typically the ID is auto generated when the object is added to the registry</p>
             *
             * @type {string}
             */
            id: '',

            /**
             * <p>Optional handler called after initialization.</p>
             *
             * <p>This handler is supported as a customization hook at the end of the instance creation process.
             * If specified, the handler will be called from constructor after the instance properties are finished
             * processing and the instance has been registered in the "mstrmojo.all" collection.</p>
             *
             * @type Function
             */
            //postCreate: null,

            /**
             * <p>Base class for an observable object.</p>
             *
             * <p>Constructs a new instance by doing the following:</p>
             * <ol>
             * <li>applying all the property values in a given hash table to the new instance,</li>
             * <li>calls the "postApplyProperties" handler, if any,</li>
             * <li>auto-assigns an "id" property value to the instance (if needed),</li>
             * <li>adds the instance to the "mstrmojo.all" collection,</li>
             * <li>calls the "postCreate" handler, if any.</li>
             * </ol>
             *
             * @param {Object} [props] Hash of property values to be applied to this instance.
             */
            init: function init(props) {
                // Create disposables collection.
                this.disposables = [];

                // Apply the given properties to this instance.
                this._super(props);

                // Add this instance to the mstrmojo.all collection so it can participate in event publishing/listening.
                $REG.add(this);

                // Hook for customizations after getting registered.
                if (this.postCreate) {
                    this.postCreate();
                }
            },

            /**
             * Adds an object that should be destroyed when this object is destroyed.
             *
             * @param {Object|Array.<Object>} obj The object to destroy (via the destroy or clear method).
             */
            addDisposable: function addDisposable(obj) {
                // Add to disposable collection.
                var disposables = this.disposables,
                    i,
                    len;
                if(obj.constructor === Array) {
                    for(i = 0, len = obj.length ; i < len; i++) {
                        disposables.push(obj[i]);
                    }
                } else {
                    disposables.push(obj);
                }

                // Return the added disposable object.
                return obj;
            },

            /**
             * Destroys all objects marked as disposable by this object.
             *
             * @param {boolean} [ignoreDOM=false] True if DOM elements associated with the disposable should NOT be destroyed.
             */
            destroyDisposables: function destroyDisposables(ignoreDOM) {
                // Iterate disposables.
                $ARR.forEach(this.disposables, function (d) {
                    // Does item have a destroy method?
                    if (d.destroy) {
                        // Destroy it.
                        d.destroy(ignoreDOM);

                    // Does item has a clear method?
                    } else if (d.clear) {
                        // Clear item.
                        d.clear();
                    }
                });

                // Reset the disposables collection.
                this.disposables = [];
            },

            /**
             * Throws an error that the given required abstract method is not implemented for this script class.
             *
             * @param {String} methodName The name of the required abstract method that is not implemented.
             */
            throwAbstractMethodError: function throwAbstractMethodError(methodName) {
                throw new Error(this.scriptClass + ' must implement ' + methodName + '.');
            },

            /**
             * Removes this instance from the mstrmojo.all collection and from any event subscriptions.
             */
            destroy: function destroy(ignoreDOM) {
                // if the object is destroyed before, then do not go through the destroy method again
                if (this.destroyed) {
                    return;
                }

                this._super(ignoreDOM);

                // Destroy disposables.
                this.destroyDisposables(ignoreDOM);

                // Remove this instance from event publishing/listening.
                $REG.remove(this);

                // DE9448 Helps reduce the size of memory leaks by detaching from any parent
                delete this.parent;

                // set the destroyed flag to be true to ensure the object gets destroyed only once
                this.destroyed = true;
            }
        }
    );

    // static convenience function for destroying and deleting an Obj object;
    // if you are disposing of lots of objects, recommendation is to define a local variable = mstrmojo.Obj.free and
    // use it to call this function.
    //
    // You may pass null and undefined variables to this function.
    //
    var obj = mstrmojo.Obj;
    obj.free = function free(o) {
        if (o instanceof obj) {
            o.destroy();
        }
    };
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo._LoadsScript",
                         "mstrmojo.Binding",
                         "mstrmojo._HasBindings",
                         "mstrmojo._HasMarkup",
                         "mstrmojo._HasTooltip",
                         "mstrmojo.css");

    /**
     * <p>Base UI widget class.</p>
     *
     * <p>A Widget is an enhanced Obj with the ability to:
     * <ul>
     * <li>load additional javascript methods at run-time,</li>
     * <li>use "bindings" to set its property values dynamically, and</li>
     * <li>render markup.</li>
     * </ul>
     * </p>
     *
     * @class
     * @extends mstrmojo.Obj
     * @mixes mstrmojo._LoadsScript
     * @mixes mstrmojo._HasBindings
     * @mixes mstrmojo._HasMarkup
     * @mixes mstrmojo._HasTooltip
     */
    mstrmojo.Widget = mstrmojo.declare(
        mstrmojo.Obj,

        [ mstrmojo._LoadsScript, mstrmojo._HasBindings, mstrmojo._HasMarkup, mstrmojo._HasTooltip ],

        /**
         * @lends mstrmojo.Widget.prototype
         */
        {
            scriptClass: "mstrmojo.Widget",

            /**
             * Handle to the root DOM node of this widget's HTML, if rendered.
             *
             * @type {HTMLElement}
             */
            domNode: null,

            /**
             * <p>Indicates whether this widget has been rendered.</p>
             *
             * @type {boolean}
             * @default false
             */
            hasRendered: false,

            /**
             * Specifies whether or not this widget's DOM node should be visible.
             *
             * @type {boolean}
             * @default true
             */
            visible: true,

            /**
             * Specifies whether or not this widget responds to events originating within its DOM.
             *
             * @type {boolean}
             * @default true
             */
            enabled: true,

            /**
             * <p>The tooltip for this widget.</p>
             *
             * @type {String}
             */
            tooltip: '',

            /**
             * Optional CSS class for the domNode. Used for customization.
             *
             * @type {String}
             */
            cssClass: "",

            /**
             * Optional text to appear in the domNode "style" attribute. Used for customization.
             *
             * @type {String}
             */
            cssText: "",

            /**
             * The display value to use when this widget is visible.
             *
             * @type {String}
             * @default block
             */
            cssDisplay: 'block',

            /**
             * The name of the slot within the parent {@link mstrmojo.Container} that this widget should be rendered within.
             *
             * @type {String}
             * @default ''
             */
            slot: '',

            /**
             * An optional name that the parent of this widget can use to get a reference to this widget.
             *
             * @type {String}
             * @default ''
             */
            alias: '',

            /**
             * The instance of {@link mstrmojo.Container} that owns this widget (may be null).
             *
             * @type {mstrmojo.Container}
             * @default null
             */
            parent: null,

            /*
             * <p>Extends the inherited method in order to do the following after initializing itself:
             *
             * 1. initialize this object's bindings (if any), and</li>
             * 2. call the "postCreateBindings" handler (if any).</li>
             */
            init: function init(props) {
                this._super(props);

                // If we are an orphan, init our bindings now (if any). Otherwise we have a parent,
                // and that parent is responsible for calling us later to init our bindings, after it
                // has finished constructing its children; exception: if our parent has already
                // initialized its bindings, we can do so now.
                // Note: even if we don't have a "bindings" property, we might have references to other
                // widgets (such as list items) which do have bindings, so we should still call initBindings.
                var p = this.parent;
                if (!p || p.hasInitBindings) {
                    this.initBindings();
                }
            },

            /**
             * <p>Extends the inherited method in order to unrender the widget and destroy its bindings before destroying the widget.</p>
             *
             * <p>Bindings are destroyed after the widget in unrendered in order to minimize DOM updates during the destruction of the bindings.</p>
             *
             * @param {Boolean} [skipCleanup] If true, this flag indicates that some parent/ancestor of this object
             * will handle some cleanup after this object is destroyed. Used as a performance optimization.
             *
             * @ignore
             */
            destroy: function dst(skipCleanup) {
                if (this.hasRendered) {
                    this.unrender(skipCleanup);
                }
                if (this.bindings) {
                    this.destroyBindings();
                }
                this._super();
            },

            /**
             * When this method is called it means that the widget is not being destroyed but it's data is no longer valid.
             */
            invalidate: mstrmojo.emptyFn,

            /**
             * <p>Abstract customization hook that gets triggered once a widget is resized.</p>
             */
            widgetResized: mstrmojo.emptyFn
        }
    );

    /**
     * Default markup method for use in subclasses of mstrmojo.Widget for when the cssText property changes.
     *
     * @static
     */
    mstrmojo.Widget.cssTextMarkupMethod = function () {
        this.domNode.style.cssText = this.cssText || '';
    };

    /**
     * Default markup method for use in subclasses of mstrmojo.Widget for when the visible property changes.
     *
     * @static
     */
    mstrmojo.Widget.visibleMarkupMethod = function () {
        this.domNode.style.display = (this.visible) ? this.cssDisplay : 'none';
    };

    /**
     * Default markup method for use in subclasses of mstrmojo.Widget for when the top property changes.
     *
     * @static
     */
    mstrmojo.Widget.topMarkupMethod = function () {
        // The style.top was set to '' if this.top is not existing, which might override the value set before by cssText.
        // Change it to set the value only when the value is existing.
        var top = this.top;
        if (top) {
            this.domNode.style.top = top;
        }
    };

    /**
     * Default markup method for use in subclasses of mstrmojo.Widget for when the left property changes.
     *
     * @static
     */
    mstrmojo.Widget.leftMarkupMethod = function () {
        // The style.left was set to '' if this.left is not existing, which might override the value set before by cssText.
        // Change it to set the value only when the value is existing.
        var left = this.left;
        if (left) {
            this.domNode.style.left = left;
        }
    };

    /**
     * Default markup method for use in subclasses of mstrmojo.Widget for when the height property changes.
     *
     * @static
     */
    mstrmojo.Widget.heightMarkupMethod = function () {
        // The style.height was set to '' if this.height is not existing, which might override the value set before by cssText.
        // Change it to set the value only when the value is existing.
        var height = this.height;
        if (height) {
            this.domNode.style.height = height;
        }

        // Call the custom hook to denote that the widget was resized.
        this.widgetResized();
    };

    /**
     * Default markup method for use in subclasses of mstrmojo.Widget for when the width property changes.
     *
     * @static
     */
    mstrmojo.Widget.widthMarkupMethod = function () {
        // The style.width was set to '' if this.width is not existing, which might override the value set before by cssText.
        // Change it to set the value only when the value is existing.
        var width = this.width;
        if (width) {
            this.domNode.style.width = width;
        }

        // Call the custom hook to denote that the widget was resized.
        this.widgetResized();
    };

    /**
     * Default markup method to use in subclasses of mstrmojo.Widget for when the enabled property changes.
     *
     * @static
     */
    mstrmojo.Widget.enabledMarkupMethod = function () {
        mstrmojo.css.toggleClass(this.domNode, 'disabled', !this.enabled);
    };
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.Obj");


    var constants = mstrmojo.DI.DIConstants,
        $ARR = mstrmojo.array,
        $DI_DB_TYPE = constants.dbType,
        $DI_XDA_TYPE = constants.xdaType,
        $DI_SOURCE = constants.sourceType,
        $DI_BE_SOURCE = constants.backendSourceSubtype;

    /**
     * @extends mstrmojo.Obj
     */
    mstrmojo.DI.DIDatabaseHelper = mstrmojo.declare(
        /** Superclass **/
        mstrmojo.Obj,

        /** Mixins **/
        null,

        /**
         * @lends mstrmojo.DI.DIDatabaseHelper.prototype
         */
        null
    );

    /**
     * Determine whether to show import option dialog.
     *
     *  @param {Integer} dbType Database type value
     *  @return {Boolean} Boolean flag indicating whether to show import option dialog
     */
    mstrmojo.DI.DIDatabaseHelper.getImportOptionByDBType = function getImportOption(dbType) {
        switch (dbType) {
            case $DI_DB_TYPE.SAP:
            case $DI_DB_TYPE.MSFT_AS:
            case $DI_DB_TYPE.ESSBASE:
            case $DI_DB_TYPE.TM1:
            case $DI_DB_TYPE.PIG:
                return false;
            default:
                return true;
        }
    };

    /**
     * Get source type
     *
     *  @param {Integer} dbType Database type value
     *  @return {Integer} Source type value
     */
    mstrmojo.DI.DIDatabaseHelper.getSourceTypeByDBType = function getSrcType(dbType) {
        switch (dbType) {
            case $DI_DB_TYPE.SAP:
            case $DI_DB_TYPE.MSFT_AS:
            case $DI_DB_TYPE.ESSBASE:
            case $DI_DB_TYPE.TM1:
                return $DI_XDA_TYPE.mdx;
            case $DI_DB_TYPE.PIG:
                return $DI_XDA_TYPE.ffsql;
            default:
                return -1;
        }
    };

    /**
     * Maps the database type to a description id
     * @param {mstrmojo.DI.DIConstants.dbType} dbType - the database type
     * @returns {number} - description id
     */
    mstrmojo.DI.DIDatabaseHelper.getDescriptionIdByDBType = function (dbType) {
        switch (dbType) {
        case $DI_DB_TYPE.MS_ACCESS:
            return 9149;
        case $DI_DB_TYPE.ORACLE:
            return 8545;
        case $DI_DB_TYPE.SQL_SERVER:
            return 8552;
        case $DI_DB_TYPE.INFORMIX:
            return 12995;
        case $DI_DB_TYPE.SYBASE:
            return 12998;
        case $DI_DB_TYPE.REDBRICK:
            return 10059;
        case $DI_DB_TYPE.DB2:
            return 8516; // DB2 Wire
        case $DI_DB_TYPE.TERADATA:
            return 8553;
        case $DI_DB_TYPE.SAP:
            return 13107;
        case $DI_DB_TYPE.NETEZZA:
            return 8558;
        case $DI_DB_TYPE.EXCEL:
            return 3958;
        case $DI_DB_TYPE.MSFT_AS:
            return 13225; // Microsoft Analysis Server
        case $DI_DB_TYPE.ESSBASE:
            return 13224; // Hyperion Essbase
        case $DI_DB_TYPE.MYSQL:
            return 8556;
        case $DI_DB_TYPE.POSTGRESQL:
            return 8541;
        case $DI_DB_TYPE.COMPOSITE:
            return 12991;
        case $DI_DB_TYPE.ASTER:
            return 10058;
        case $DI_DB_TYPE.VERTICA:
            return 10062;
        case $DI_DB_TYPE.PARACCEL:
            return 10056;
        case $DI_DB_TYPE.TM1:
            return 13223; // Cognos TM1
        case $DI_DB_TYPE.XQUERY:
            return 8560;
        case $DI_DB_TYPE.HIVE:
            return 8561;
        case $DI_DB_TYPE.SALESFORCE:
            return 9213;
        case $DI_DB_TYPE.SAPHANA:
            return 12997;
        case $DI_DB_TYPE.GOOGLE_BIGQUERY:
            return 12450;
        default:
            return 4444; // UNKNOWN
        }
    };

    /**
     * Maps the backend source sub type to an OAuth source type
     * @param {mstrmojo.DI.DIConstants.backendSourceSubtype} beType
     * @returns {mstrmojo.DI.DIConstants.sourceType} or -1 if not found
     */
    mstrmojo.DI.DIDatabaseHelper.getOASTFromBEST = function getOAuthSourceTypeFromBackendSourceType(beType) {
        switch (beType) {
        case $DI_BE_SOURCE.googleBigQuery: //oAuth source with DDA support
        case $DI_BE_SOURCE.googleBigQueryFFSQLModel:
        case $DI_BE_SOURCE.googleBigQuerySingleTable:
            return $DI_SOURCE.googleBigQuery;
        case $DI_BE_SOURCE.dropbox:
            return $DI_SOURCE.dropbox;
        case $DI_BE_SOURCE.googleAnalytics:
            return $DI_SOURCE.googleAnalytics;
        case $DI_BE_SOURCE.googleDrive:
            return $DI_SOURCE.googleDrive;
        case $DI_BE_SOURCE.facebook:
            return $DI_SOURCE.facebook;
        case $DI_BE_SOURCE.twitter:
            return $DI_SOURCE.twitter;
        case $DI_BE_SOURCE.salesforce:
            return $DI_SOURCE.salesforce;
        default:
            return -1;
        }
    };

    /**
     * check whether a cube's source type is OAuth
     * @param {mstrmojo.DI.DIConstants.sourceType} sourceType
     * @returns {Boolean} true or false
     */
    mstrmojo.DI.DIDatabaseHelper.isOAuthSourceType = function isOAuthSourceType(sourceType) {
        var oAuthSrcType = [
            $DI_SOURCE.googleBigQuery,
            $DI_SOURCE.dropbox,
            $DI_SOURCE.googleAnalytics,
            $DI_SOURCE.googleDrive,
            $DI_SOURCE.facebook,
            $DI_SOURCE.twitter,
            $DI_SOURCE.salesforce
        ];
        return $ARR.indexOf(oAuthSrcType, sourceType) !== -1;
    };


    /**
     * Filter database objects by ids.
     *
     *  @param {[]} dbs Array of database objects
     *  @param {[]} ids Array of ID values used as a filter
     *  @param {Boolean} mode Flag to indicate if this is a 'include' or 'exclude' filtering.
     *  @return {[]} Array of database objects filtered
     */
    mstrmojo.DI.DIDatabaseHelper.filterDBById = function filterDBById(dbs, ids, mode) {
        return $ARR.filter(dbs, function (db) {
            var idx = $ARR.indexOf(ids, db.id),
                result;
            if (idx > -1) {
                result = mode;
            } else {
                result = !mode;
            }
            return result;
        });
    };

    /**
     * Filter database objects by display option.
     *
     *  @param {[]} dbs Array of database objects
     *  @param {Integer} disp Value of display option
     *  @param {Array} dbIdExcludeFilter Array of db ids to exclude
     *  @return {[]} Array of database objects filtered
     */
    mstrmojo.DI.DIDatabaseHelper.filterDBByDispOption = function filterDBById(dbs, disp, dbIdExcludeFilter) {
        return $ARR.filter(dbs, function (db) {
            var isExcluded = false;

            if ((db.disp & disp) === disp) {
                $ARR.forEach(dbIdExcludeFilter, function (excludedDbId) {
                    if (db.id === excludedDbId) {
                        isExcluded = true;
                        return false;
                    }
                });

                return !isExcluded;
            }
        });
    };

    /**
     * Filter database objects by ids.
     *
     *  @param {[]} dbs Array of database objects
     *  @return {[]} Array of database ids
     */
    mstrmojo.DI.DIDatabaseHelper.getDBIds = function getDBIds(dbs) {
        var res = [];
        $ARR.forEach(dbs, function (db) {
            res = res.concat(db.id); //since db.id can be an array that contains both dbIDs for mac and windows
        });
        return res;
    };

    /**
     * Get unique database type values from database objects array.
     *
     *  @param {[]} dbs Array of database objects
     *  @return {[]} Array of database type values
     */
    mstrmojo.DI.DIDatabaseHelper.getUniqueDBTypes = function getUniqueDBTypes(dbs) {
        var res = [], idx;
        $ARR.forEach(dbs, function (db) { //YGUO TQMS-975389 Array object's forEach function is not supported in IE8.
            idx = $ARR.indexOf(res, db.dbType);
            if (idx < 0) {
                res.push(db.dbType);
            }
        });

        return res;
    };

    mstrmojo.DI.DIDatabaseHelper.filterDBByAdminConfig = function (dbTypes, adminConfig) {
        return $ARR.filter(dbTypes, function (dbType) {
            var idx = $ARR.indexOf(adminConfig, dbType.id),
                ret = true;
            if (idx >= 0) {
                ret = false;
            }
            return ret;
        });
    };

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Obj");

    var CONFIG_ENUM_CORNERS = {
        TOP_LEFT: 1,
        TOP_RIGHT: 2,
        BOTTOM_RIGHT: 3,
        BOTTOM_LEFT: 4
    };

    // enum for the direction of the submenu flow
    var CONFIG_ENUM_MENU_DIRECTION = {
        LEFT_TO_RIGHT: 0,
        RIGHT_TO_LEFT: 1
    };

    /**
     * An object for configuring the contents and position of objects that pop up from and are connected to menus.
     *
     * @class
     * @extends mstrmojo.Obj
     */
    mstrmojo.ui.PopupConfig = mstrmojo.declare(
        mstrmojo.Obj,

        null,

        /**
         * @lends mstrmojo.ui.PopupConfig.prototype
         */
        {
            scriptClass: 'mstrmojo.ui.PopupConfig',

            /**
             * An enumeration of corners for use with {@link mstrmojo.ui.PopupConfig.setAlignment} method.
             *
             * @enum {int}
             */
            ENUM_CORNERS: CONFIG_ENUM_CORNERS,

            /**
             * <p>A boolean flag that controls whether the menu is hosted within the host element or will it be hosted
             * in the body with a proxy host.</p>
             * <p>DE53943;Reminder when the host element has enabled scroll, suggest to use isHostedWithin to false to avoid pop up being cut-off
             *
             * @type {boolean}
             */
            isHostedWithin: true,

            /**
             * <p>An optional object that controls the position of the popup when
             * {@link mstrmojo.ui.PopupConfig.isHostedWithin} flag is set to false.</p>
             *
             *
             * @type {{
             *     x : int,
             *     y : int,
             *     w : int?,
             *     h : int?
             *  }}
             */
            position : null,

            /**
             * <p>An optional property that controls the css class in the event that the
             * {@link mstrmojo.ui.PopupConfig.isHostedWithin} flag is set to false.</p>
             *
             * @type {String}
             */
            hostProxyCssClass: '',

            /**
             * The ID of the {@link mstrmojo.Widget} that is opening (and will contain) the popup.
             *
             * @type {String}
             */
            hostId: '',

            /**
             * The Node within the host that will contain the popup.
             *
             * @type {HTMLElement|Node}
             */
            hostElement: null,

            /**
             * An optional property to specify which node the popup should anchor around, when it is not hosted within.
             *
             * It defaults to the host element if not specified.
             *
             * @type {HTMLElement|Node}
             */
            anchorElement: null,

            /**
             * The collection of popup handlers for this popup.
             *
             * @type {Object.<string, {}>}
             */
            popupHandlers: null,

            /**
             * The corners of the popup and host element that should be aligned.
             *
             * @see {mstrmojo.ui.PopupConfig.ENUM_CORNERS}
             *
             * @type {{host: number, popup: number}}
             */
            alignment: null,

            /**
             * A flag when isHostedWithin is false to allow adjusting popup 'top' position by the popup anchor element height
             * so to vertically align popup with the anchor element, i.e., popup top edget aligns with anchor top edget, or
             * popup bottom edge aligns with anchor bottom edget, based on popup corner setting
             *
             * @type {boolean}
             * @default false
             */
            alignWithAnchor: false,

            /**
             * Specifies if the popup uses rich tooltip
             *
             * @type {boolean}
             * @default false
             */
            useTooltip: false,

            /**
             * Specifies if the popup uses the (deprecated) dark theme
             *
             * @type {boolean}
             * @default false
             */
            useDarkTheme: false,

            /**
             * @override
             */
            init: function init(props) {
                // Initialize properties.
                this.clear();

                this._super(props);
            },

            /**
             * Configures the position of the popup by storing which corners of the popup and host should be aligned.
             *
             * @see {@link mstrmojo.ui.PopupConfig.ENUM_CORNERS}
             *
             * @param {number} hostCorner The corner of the host element that should align with the popup.
             * @param {number} popupCorner The corner of the popup that should align with the host element.
             */
            setAlignment: function setAlignment(hostCorner, popupCorner) {
                // Cache corner alignment.
                this.alignment = {
                    host: hostCorner,
                    popup: popupCorner
                };
            },

            /**
             * <p>Adds handler functions to be called when the popup opens and closes.</p>
             *
             * <p>The handlers are optional and will recieve a boolean parameter indicating whether the popup is opening or closing.</p>
             *
             * @param {string} scopeId The ID of the {@link mstrmojo.Obj} to use as the scope for the passed functions.
             * @param {function(boolean)=} fnOpen An optional Function to be called when the popup opens.
             * @param {function(boolean)=} fnClose An optional Function to be called when the popup closes.
             */
            addPopupHandlers: function addPopupHandlers(scopeId, fnOpen, fnClose) {
                // Create and cache handler object.
                this.popupHandlers[scopeId] = {
                    open: fnOpen,
                    close: fnClose
                };
            },

            /**
             * Resets the configuration to it's initial state.
             */
            clear: function clear() {
                // Initialize handlers and...
                this.popupHandlers = {};

                // set default alignment.
                var corners = this.ENUM_CORNERS;
                this.alignment = {
                    host: corners.BOTTOM_LEFT,
                    popup: corners.TOP_LEFT
                };
            },

            destroy: function(ignoreDom){
                this.anchorElement = null;
                this.hostElement = null;
                if(this._super) {
                    this._super(ignoreDom);
                }
            }
        }
    );

    /**
     * An enumeration of corners for use with {@link mstrmojo.ui.PopupConfig.setAlignment} method.
     *
     * @enum {int}
     */
    mstrmojo.ui.PopupConfig.ENUM_CORNERS = CONFIG_ENUM_CORNERS;

    /**
     * The flow direction for the menu. We're using a public class member so the flow is preserved across menus.
     * We also provide helper functions so we don't have to expose the enum.
     * @type {object}
     */
    mstrmojo.ui.PopupConfig.directionCfg = {
        menuDirection: CONFIG_ENUM_MENU_DIRECTION.LEFT_TO_RIGHT,

        /**
         * @returns {boolean} true if we're using the RTL flow
         */
        isRightToLeft: function rtl() {
            return this.menuDirection === CONFIG_ENUM_MENU_DIRECTION.RIGHT_TO_LEFT;
        },

        /**
         * Sets the direction RTL or LTR. We're using a public setter with a private member so we don't have to expose the enum
         * @param isRTL - whether or not we're setting direction right to left.
         */
        setDirection: function setDirection(isRTL) {
            this.menuDirection = isRTL ? CONFIG_ENUM_MENU_DIRECTION.RIGHT_TO_LEFT : CONFIG_ENUM_MENU_DIRECTION.LEFT_TO_RIGHT;
        }
    };
}());

(function () {

    mstrmojo.requiresCls("mstrmojo.ui.PopupConfig",
                         "mstrmojo.array",
                         "mstrmojo.hash",
                         "mstrmojo.css",
                         "mstrmojo.ui._HasUITheme",
                         "mstrmojo.vi.ui.theme",
                         "mstrmojo.dom");

    function toggleLockInfoWinForScroll(owner, lock) {
        if (!mstrmojo.DocInfoWindow) {
            return;
        }

        var w = owner;
        // lock\unlock all parent info wins
        while (w) {
            if (w instanceof mstrmojo.DocInfoWindow) {
                w[lock ? 'registerScrollLock' : 'releaseScrollLock'](this);
                break;
            }

            w = w.parent;
        }
    }

    var $ARR = mstrmojo.array,
        $DOM = mstrmojo.dom,
        $HASH = mstrmojo.hash,
        $CSS = mstrmojo.css,
        $PX = 'px',
        $ENUM_THEME_NAMES = mstrmojo.ui._HasUITheme.EnumThemeNames;

    var isDebugging = false;

    function toggleLockInfoWin(owner, lock) {
        if (!mstrmojo.DocInfoWindow) {
            return;
        }

        var w = owner;
        // lock\unlock all parent info wins
        while (w) {
            if (w instanceof mstrmojo.DocInfoWindow) {
                w[lock ? 'registerLock' : 'releaseLock'](this);
                this.lockIW = lock ? w : null;
                break;
            }

            w = w.parent;
        }
    }

    var $PC = mstrmojo.ui.PopupConfig,
        $DIRCFG = $PC.directionCfg,
        $ENUM_CORNERS = $PC.ENUM_CORNERS,
        ENUM_CORNER_TOP_LEFT = $ENUM_CORNERS.TOP_LEFT,
        ENUM_CORNER_TOP_RIGHT = $ENUM_CORNERS.TOP_RIGHT,
        ENUM_CORNER_BOTTOM_RIGHT = $ENUM_CORNERS.BOTTOM_RIGHT,
        ENUM_CORNER_BOTTOM_LEFT = $ENUM_CORNERS.BOTTOM_LEFT;

    /**
     * Private helper function to check if a corner aligns left.
     *
     * @param {int} corner The corner for which we wish to check the left edge.
     * @returns {boolean} Whether the corner is aligned left.
     * @private
     */
    function isCornerLeft(corner) {
        return (corner === ENUM_CORNER_BOTTOM_LEFT || corner === ENUM_CORNER_TOP_LEFT);
    }

    /**
     * Private helper function to check if a corner aligns right.
     *
     * @param {int} corner The corner for which we wish to check the right edge.
     * @returns {boolean} Whether the corner is aligned right.
     * @private
     */
    function isCornerRight(corner) {
        return (corner === ENUM_CORNER_TOP_RIGHT || corner === ENUM_CORNER_BOTTOM_RIGHT);
    }

    /**
     * Private helper function to check if a corner aligns bottom.
     *
     * @param {int} corner The corner for which we wish to check the bottom edge.
     * @returns {boolean} Whether the corner is aligned bottom.
     * @private
     */
    function isCornerBottom(corner) {
        return (corner === ENUM_CORNER_BOTTOM_RIGHT || corner === ENUM_CORNER_BOTTOM_LEFT);
    }

    /**
     * Private helper function to check if a corner aligns top.
     *
     * @param {int} corner The corner for which we wish to check the top edge.
     * @returns {boolean} Whether the corner is aligned top.
     * @private
     */
    function isCornerTop(corner) {
        return (corner === ENUM_CORNER_TOP_RIGHT || corner === ENUM_CORNER_TOP_LEFT);
    }

    /**
     * <p>Helper function that calculates the directions off the screen where the menu overflows the page.</p>
     *
     * @param {mstrmojo.ui.PopupConfig} cfg The instance of the config that this menu is rendering.
     * @param {{x: number, y: number, w: number, h: number}} bodyPos The coordinates and dimensions of the body node.
     * @param {{x: number, y: number, w: number, h: number}} hostElemPos The coordinates and dimensions of the host node.
     * @param {{x: number, y: number, w: number, h: number}} menuPos The coordinates and dimensions of the popup node.
     * @returns {{top: boolean, bottom: boolean, left: boolean, right: boolean}} An object with the four directions and whether it overflows.
     */
    function calculateOverflowDirections(cfg, bodyPos, hostElemPos, menuPos) {
        var hostX = hostElemPos.x,
            hostY = hostElemPos.y,
            hostWidth = hostElemPos.w || 0,
            hostHeight = hostElemPos.h || 0,
            menuWidth = menuPos.w,
            menuHeight = menuPos.h,
            corners = cfg.alignment,
            popupCorner = corners.popup,
            hostCorner = corners.host,
            isHostAlignedRight = isCornerRight(hostCorner),
            isHostAlignedBottom = isCornerBottom(hostCorner),
            hasOverflowedRight = false,
            hasOverflowedBottom = false,
            hasOverflowedLeft = false,
            hasOverflowedTop = false,
            checkOverflowLeft = false,
            checkOverflowTop = false,
            isMobile = $DOM.isMobile,
            DIRCFG = mstrmojo.ui.PopupConfig.directionCfg;

        // In order to check if the menu has overflowed off the right edge of the screen,
        // we only need to test if the popup corner is aligned to the left.
        if (isCornerLeft(popupCorner)) {
            // Initialize the menu's right position based on menu's x coordinates and the width of the popup.
            var menuRightPos = hostX + menuWidth + (isHostAlignedRight ? hostWidth : 0);

            // Let's check if the menu's total right position is greater than the body's width.
            hasOverflowedRight = bodyPos.w < menuRightPos;

            checkOverflowLeft = isMobile && (hasOverflowedRight || DIRCFG.isRightToLeft());
        }

        // In order to check if the menu has overflowed off the bottom edge of the screen,
        // we only need to test if the popup corner is aligned to the top.
        if (isCornerTop(popupCorner)) {
            // Initialize the menu's bottom position based on the menu's y coordinate and the height of the popup.
            var menuBottomPos = hostY + menuHeight + (isHostAlignedBottom ? hostHeight : 0);

            // Let's check if the menu's total bottom position is greater than the body's height.
            hasOverflowedBottom = bodyPos.h < menuBottomPos;

            checkOverflowTop = isMobile && hasOverflowedBottom;
        }

        // In order to check if the menu has overflowed off the left  edge of the screen,
        // we only need to test if the popup corner is aligned to the right.
        if (isCornerRight(popupCorner) || checkOverflowLeft) {
            var menuLeftPos = hostX - menuWidth + ((isHostAlignedRight && !checkOverflowLeft)? hostWidth : 0);

            // Let's check if the left most position is negative (off the left edge)
            hasOverflowedLeft = menuLeftPos < 0;
        }

        // In order to check if the menu has overflowed off the top edge of the screen,
        // we only need to test if the popup corner is aligned to the bottom.
        if (isCornerBottom(popupCorner) || checkOverflowTop) {
            var menuTopPos = hostY - menuHeight + ((isHostAlignedBottom && !checkOverflowTop)? hostHeight : 0);

            // Let's check if the top most position is negative (off the top edge)
            hasOverflowedTop = menuTopPos < 0;
        }

        return {
            top: hasOverflowedTop,
            bottom: hasOverflowedBottom,
            left: hasOverflowedLeft,
            right: hasOverflowedRight
        };
    }

    /**
     * Iterates the popup handlers object and calls the appropriate handler.
     *
     * @param {boolean=} isOpen If true the open handler will be called, otherwise, the close handler will be called.
     *
     * @this mstrmojo._IsPopup
     * @private
     */
    function callPopupHandlers(isOpen) {
        var popupConfig = this.popupConfig;

        // Do we have a popup config ?
        if (popupConfig) {
            // Iterate popup handlers.
            $HASH.forEach(popupConfig.popupHandlers, function (h, id) {
                // Is there a handler?
                var fn = h[isOpen ? 'open' : 'close'];
                if (fn) {
                    // Call it in the scope indicated, passing whether the popup is open or not.
                    fn.call(mstrmojo.all[id] || fn, !!isOpen);
                }
            });
        }
    }

    /**
     * Sets the host proxy's visibility to hidden or not based on whether we want to show it or not.
     *
     * @param {Boolean} show Whether to show the host proxy node or not.
     */
    function setHostProxyVisibility(show) {
        var cfg = this.popupConfig;

        // Is the popup not hosted within ?
        if (cfg && !cfg.isHostedWithin) {
            // Set the host proxy to be set to display none.
            var hostProxy = this.hostProxy;
            if (hostProxy) {
                hostProxy.style.display = show ? '' : 'none';
            }
        }
    }

    /**
     * Returns whether the value provided as a parameter is a number.
     *
     * @param {Number} v The value to check whether it is valid.
     *
     * @returns {boolean} Whether the value is a number
     */
    function isValidPosValue(v) {
        return v !== undefined && v !== null && !isNaN(v);
    }

    /**
     * Mixin to make any Widget a popup that can be opened or closed.
     *
     * @mixin
     * @public
     */
    mstrmojo._IsPopup = {

        /**
         * True when the popup is visible.
         *
         * @type {boolean}
         * @default false
         */
        visible: false,

        /**
         * Boolean value to control if the parent info window can be closed when scroll, default to false.
         *
         * @type Boolean
         */
        lockIWForScroll: false,

        /**
         * True when the popup is added as a disposable object of its opener.
         *
         * @type {boolean}
         * @default true
         */
        disposable: true,

        /**
         * <p>Handle back to the widget that called the popup open method.</p>
         *
         * <p>Set at run-time in open(). Reset to null when close() is called.</p>
         *
         * @type {mstrmojo.Widget}
         */
        opener: null,

        /**
         * Customizable event handler, called when open() is called.
         *
         * @abstract
         */
        onOpen: mstrmojo.emptyFn,

        /**
         * Customizable event handler, called when close() is called.
         *
         * @param {Object=} config Optional configuration settings.
         * @abstract
         */
        onClose: mstrmojo.emptyFn,

        /**
         * The popupConfiguration for this popup.
         *
         * @type {mstrmojo.ui.PopupConfig}
         */
        popupConfig: null,

        /**
         * Private property to hold a proxy host element node that will be used to host the menu when
         * the popup config is set up to not be hosted within.
         *
         * @type {HTMLElement|Node}
         * @ignore
         */
        hostProxy: undefined,

        /**
         * <p>Opens this popup, meaning makes it visible, calling its render() method if not already rendered.</p>
         *
         * @param {mstrmojo.Widget=} opener The widget that opened this popup.
         * @param {Object=} config An optional hash of properties for the popup.
         */
        open: function open(opener, config) {
            // Call the open popup handlers.
            callPopupHandlers.call(this, true);

            // Apply config props, if any. This will be done with a custom method, if the popup defines one;
            // otherwise, it is done by just setting properties.
            if (this.updatePopupConfig) {
                this.updatePopupConfig(config, opener);
            } else {
                $HASH.forEach(config, function (v, k) {
                    this.set(k, v);
                }, this);
            }

            // Define in-render CSS class.
            var positionCSS = 'popup-mid-render';

            // Update the opener. Do this before rendering, because setting the opener may cause
            // the contents to update themselves, and it's more efficient to avoid re-rendering DOM updates.
            this.set('opener', opener);

            // Has the popup NOT already rendered?
            if (!this.hasRendered) {
                // Cache current visible value and change to false.
                var currentVisible = this.visible;
                this.visible = false;

                // Render popup.
                this.render();

                // Add in-render CSS class and show popup.
                $CSS.addClass(this.domNode, positionCSS);
                this.set('visible', currentVisible);
            }

            // Customization hook.
            if (this.nudge) {
                this.domNode.style.top = '-10000px';
            }

            // Set the host proxy visibility to hidden.
            setHostProxyVisibility.call(this, true);

            // Ready to show to the end-user.
            this.set('visible', true);

            if (this.lockIWForScroll) {
                toggleLockInfoWinForScroll.call(this, this.opener, true);
            }

            // #789093,#788895.lock IW if popup is opened in it.
            if (config && config.lockIW) {
                toggleLockInfoWin.call(this, config.lockIW, true);
            }

            // Customization hook for positioning the popup.
            if (this.nudge) {
                this.nudge();
            }

            // DE71882; adjust the height and width of popup before adjusting its alignment
            if (this.adjustSize) {
                this.adjustSize();
            }

            // Adjust the popup alignment
            this.adjustCornersForPopupOverflow();

            // Customization hook.
            this.onOpen();

            // Remove in-render CSS class.
            $CSS.removeClass(this.domNode, positionCSS);
        },

        /**
         * Adjust the placement of the popup to make sure that it's always inside the window.
         *
         * All the popups that wants to fit into window should have a {@link mstrmojo.ui.PopupConfig} popupConfig property.
         *
         * @return {Boolean} If the replacement is done
         */
        adjustCornersForPopupOverflow: function adjustCornersForPopupOverflow() {
            var cfg = this.popupConfig;
            if (!cfg) {
                return false;
            }
            //DE16364 - Set the value for include scroll from the config, default is true.
            var includeScroll = (cfg.includeScroll !== undefined) ? cfg.includeScroll : true;

            // Cache or calculate the popups anchor position.
            var anchor = cfg.anchorElement || cfg.hostElement,
                popupAnchorPos = cfg.position || $DOM.position(anchor, includeScroll), // TQMS 837417: add true parameter to $DOM.position to include the scroll
                zIndex = anchor && anchor.style && anchor.style.zIndex;//DE58970;fix rwd document RMC contextmenu break, since rwd document anchor is Constr object, not a domNode

            // First, if the popup isn't hosted within, we add it to the host proxy; so we can calculate it's dimensions.
            if (!cfg.isHostedWithin) {

                //cache host proxy so it is removed later, this method might be called on refresh and if the menu
                //is still open the host proxy remains on the page
                var oldHostProxy = this.hostProxy,
                    hostProxyElement = this.hostProxy = document.createElement('div');

                // Add the host proxy element to the body.
                document.body.appendChild(hostProxyElement);

                // Add the menu within the proxy host element node.
                hostProxyElement.appendChild(this.domNode);

                // Remove any lingering old proxy hosts...
                if (oldHostProxy) {
                    oldHostProxy.parentNode.removeChild(oldHostProxy);
                }

                // Reposition domNode and apply the css and style properties.
                // Give it a width instead of height so that the popup list can have same width as the anchor element.
                var divStyle = hostProxyElement.style,
                    POS_TO_STYLE_ATTR_MAP = {
                        x: 'left',
                        y: 'top',
                        w: 'width'
                    };

                hostProxyElement.className = cfg.hostProxyCssClass;
                divStyle.position = 'absolute';
                divStyle.background = 'none';
                //DE53943;add mstrmojo-popup-widget-hosted to host proxy, since mouse event on target outside the menu root domNode, it would trigger widget.menuEditorClosefn for GMInteractivity
                $CSS.addClass(hostProxyElement, "mstrmojo-popup-widget-hosted");
                
                // Make the proxy height 0px so that it doesn't obstruct the original host.
                divStyle.height = '0';

                // Loop through x, y, and width of the anchor position and apply it to the host proxy.
                $ARR.forEach(['x', 'y', 'w'], function (posProp) {
                    var popupAnchorProp = popupAnchorPos[posProp];

                    // Is this popup anchor position valid?
                    if (isValidPosValue(popupAnchorProp)) {
                        // Set the corresponding property on the divs style.
                        divStyle[POS_TO_STYLE_ATTR_MAP[posProp]] = popupAnchorProp + $PX;
                    }
                });
            }

            var cornersEnum = cfg.ENUM_CORNERS,
                BOTTOM_LEFT = cornersEnum.BOTTOM_LEFT,
                BOTTOM_RIGHT = cornersEnum.BOTTOM_RIGHT,
                TOP_RIGHT = cornersEnum.TOP_RIGHT,
                TOP_LEFT = cornersEnum.TOP_LEFT;

            var bodyPos = $DOM.position(document.body),
                menuPos = $DOM.position(this.domNode),
                overflowDirections = calculateOverflowDirections(cfg, bodyPos, popupAnchorPos, menuPos),
                hasOverflowedRight = overflowDirections.right,
                hasOverflowedBottom = overflowDirections.bottom,
                hasOverflowedLeft = overflowDirections.left,
                hasOverflowedTop = overflowDirections.top,
                corners = cfg.alignment,
                originalPopupCorner = corners.popup,
                originalHostCorner = corners.host,
                popupCorner = originalPopupCorner,
                hostCorner = originalHostCorner,
                isMobile = $DOM.isMobile,
                isSubMenu = anchor && anchor.classList && anchor.classList.contains("mstrmojo-ui-Menu-item"),
                currentMenuId = this.id,
                parentNode = anchor && anchor.parentNode,
                parentElement = parentNode && parentNode.parentElement,
                parentMenu = anchor || this.domNode,
                parentPos,
                domNodeStyle = this.domNode.style;

            // Get the higher level parent menu
            if (parentElement && parentElement.classList.contains("mstrmojo-ui-Menu")) {
                parentMenu = parentElement;
            }
            parentPos = $DOM.position(parentMenu);

            // If a menu has overflown on both sides, and it has a parent menu, 
            // hide the parent menu and move the current menu into its place.
            if (isSubMenu && ((hasOverflowedLeft && hasOverflowedRight) || (hasOverflowedTop && hasOverflowedBottom))) {
                if (parentElement) {
                    // 1. Move submenu to parent menu's position. This is just a fail-safe for cfg.position below.
                    domNodeStyle.top = parentPos.y + "px";
                    domNodeStyle.left = parentPos.x + "px";

                    // 2. Hide parent and other (higher level) menus if any. Since there is no direct 
                    // way of tracking back to ancestor menus, hide all menus visible on the document.
                    var allMenus = document.getElementsByClassName("mstrmojo-ui-Menu");
                    $ARR.forEach(allMenus, function (currentMenu) {
                        // In some cases, the submenu is displayed beforehand. 
                        // So making sure it won't be hidden along with other menus.
                        // Use visibility instead of display to preserve position info.
                        if (currentMenuId !== currentMenu.id) {
                            currentMenu.style.visibility = "hidden";
                        }
                    });
                }

                cfg.anchorElement = parentMenu;
                cfg.position = {
                    h: 0,
                    w: 0,
                    x: (parentPos.x + menuPos.w) > bodyPos.w ? Math.min(parentPos.x, 5) : parentPos.x,
                    y: (parentPos.y + menuPos.h) > bodyPos.h ? Math.min(parentPos.y, 90) : parentPos.y
                };

                // 4. Recalculate overflowDirections.
                this.adjustCornersForPopupOverflow();
                return;
            }

            // In some cases, menuPos's width and height remain 0 until the adjustCornersForPopupOverflow function is manually 
            // triggered. Due to this, the overflow info is not captured accurately. So wait until menuPos.w has a valid value.
            if ($DIRCFG.isRightToLeft() && (!isMobile || menuPos.w > 0)) {
                if (!isMobile || !hasOverflowedLeft) {
                    // even if we have space to the right, we're in RTL mode so let's set this
                    hasOverflowedRight = true;
                } else if (!isMobile || !hasOverflowedRight) {
                    // Change direction since menu has overflown on the left
                    $DIRCFG.setDirection(false);
                    this.resetDirection = true;

                    // In RTL menu flow, the leftmost menu always gets displayed on the left. It can be cut off 
                    // on the left even when there is enough space for it on the right. And though the direction 
                    // has just been switched to LTR, it will not take effect immediately. Hence switching the 
                    // hostCorner here so that it will be properly reset to TOP_RIGHT or BOTTOM_RIGHT just below.
                    if (isMobile) { // TO-DO: Remove this condition later, since all platforms have the same issue. 
                        hostCorner = (hostCorner === TOP_RIGHT) ? TOP_LEFT : BOTTOM_LEFT;
                    }
                }
            } else if (hasOverflowedRight) {
                // if we've changed direction, we need to capture it here
                $DIRCFG.setDirection(true);
                this.resetDirection = true;
            }

            // Based on the current alignment, will the menu overflow horizontally (along the x-axis)?
            if (hasOverflowedRight || hasOverflowedLeft) {
                // Fix the host corner.
                if (isCornerLeft(hostCorner)) {
                    hostCorner = isCornerTop(hostCorner) ? TOP_RIGHT : BOTTOM_RIGHT;
                } else if (isCornerRight(hostCorner)) {
                    hostCorner = isCornerTop(hostCorner) ? TOP_LEFT : BOTTOM_LEFT;
                }

                // Fix the popup corner.
                if (hasOverflowedRight && isCornerLeft(popupCorner)) {
                    popupCorner = isCornerTop(popupCorner) ? TOP_RIGHT : BOTTOM_RIGHT;
                } else if (hasOverflowedLeft && isCornerRight(popupCorner)) {
                    popupCorner = isCornerTop(popupCorner) ? TOP_LEFT : BOTTOM_LEFT;
                }
            }

            // Check if the menu either overflows vertically (along the y-axis).
            if (hasOverflowedBottom || hasOverflowedTop) {
                // Fix the host corner.
                if (isCornerLeft(hostCorner)) {
                    hostCorner = isCornerTop(hostCorner) ? BOTTOM_LEFT : TOP_LEFT;
                } else if (isCornerRight(hostCorner)) {
                    hostCorner = isCornerTop(hostCorner) ? BOTTOM_RIGHT : TOP_RIGHT;
                }

                // Fix the popup corner.
                if (hasOverflowedBottom && isCornerTop(popupCorner)) {
                    popupCorner = isCornerLeft(popupCorner) ? BOTTOM_LEFT : BOTTOM_RIGHT;
                } else if (hasOverflowedTop && isCornerBottom(popupCorner)) {
                    popupCorner = isCornerLeft(popupCorner) ? TOP_LEFT : TOP_RIGHT;
                }
            }

            // If the alignment of the menu has changed from what the user configured
            if (hasOverflowedTop || hasOverflowedRight || hasOverflowedBottom || hasOverflowedLeft) {
                // If the debug flags are on, log which direction overflowed.
                if (isDebugging) {
                    console.log("Overflow directions: " + JSON.stringify(overflowDirections));
                }

                // Are we updating the alignment ? Cache the original ones so we can revert back to it later on.
                this._orgalgn = {
                    host: originalHostCorner,
                    popup: originalPopupCorner
                };

                // Update it on the config.
                cfg.setAlignment(hostCorner, popupCorner);
            }

            // Now that we've calculated that we've overflows, is this the non-hosted within case?
            if (!cfg.isHostedWithin) {
                // Do we have valid top and height props for the popupAnchor position ?
                if (isValidPosValue(popupAnchorPos.y) && isValidPosValue(popupAnchorPos.h)) {
                    // Move the host proxy to the top or bottom based on which corner it's anchored to.
                    this.hostProxy.style.top = (popupAnchorPos.y + (isCornerBottom(popupCorner) ? (cfg.alignWithAnchor === true ? popupAnchorPos.h : 0) : (cfg.alignWithAnchor === true ? 0 : popupAnchorPos.h))) + $PX;

                    //when it is non-hosted within, we need to change z-index to display it top
                    //if its anchor's zIndex >= 101, use anchor's zIndex +1, to ensure to display top than anchor
                    //else use customized default value 101
                    this.hostProxy.style.zIndex = (isValidPosValue(zIndex) && (zIndex > 100)) ? zIndex + 1 : 101;
                }
            }

            // Adjust position with precision by including host's border values.
            // Currently required for subMenus only.
            var hostStyle, hostBorder = {};
            if (cfg.isHostedWithin && !!this.opener) {
                hostStyle = $CSS.getComputedStyle(this.opener.domNode);
            }
            $ARR.forEach(['left', 'right', 'top', 'bottom'], function (position) {
                hostBorder[position] = hostStyle ? parseInt(hostStyle['border-' + position + '-width'] || 0, 10) : 0;
            });

            var isHostBottom = isCornerBottom(hostCorner),
                isHostRight = isCornerRight(hostCorner),
                isPopupBottom = isCornerBottom(popupCorner),
                isPopupRight = isCornerRight(popupCorner),
                setPositionToHundredPercent = function (pos, includeBorder) {
                    // Add includeBorder flag instead of removing the pos value for the given
                    // borders, as the submenu positioning logic may change again in the future.
                    return "calc(100% + " + (includeBorder ? hostBorder[pos] : 0) + "px)";
                },
                setPositionToZero = function (pos, includeBorder) {
                    // Add includeBorder flag instead of removing the pos value for the given
                    // borders, as the submenu positioning logic may change again in the future.
                    return (includeBorder ? -hostBorder[pos] : 0) + "px";
                };

            // Initialize position to auto.
            var top, right, bottom, left;
            top = right = bottom = left = 'auto';

            // Is the popup corner on the bottom?
            if (isPopupBottom) {
                // Set bottom to 0 or 100% based on host corner, adjust position based on host border.
                bottom = isHostBottom ? setPositionToZero('top') : setPositionToHundredPercent('top');
            } else {
                // Set top to 100% or 0 based on host corner, adjust position based on host border.
                top = isHostBottom ? setPositionToHundredPercent('bottom') : setPositionToZero('bottom');
            }

            // Is the popup corner on the right?
            if (isPopupRight) {
                // Set right to 100% or 0 based on host corner, adjust position based on host border.
                right = isHostRight ? setPositionToZero('left') : setPositionToHundredPercent('left');
            } else {
                // Set left to 100% or 0 based on host corner, adjust position based on host border.
                left = isHostRight ? setPositionToHundredPercent('right') : setPositionToZero('right');
            }

            // Reposition domNode.
            domNodeStyle.top = top;
            domNodeStyle.right = right;
            domNodeStyle.bottom = bottom;
            domNodeStyle.left = left;

            var curPos = $DOM.position(this.domNode),
                minMenuPos = 5;

            //Code refactored from from  Menu.js,
            //when there is overflow, then we need to consider whether it is overflow in body
            if(hasOverflowedBottom || hasOverflowedTop){
                var curY = curPos.y,
                    maxWinH = $DOM.getMaxScrollHeight() + "px",
                    scrollNode = this.scrollNode,
                    scrollNodeMaxHeight = scrollNode && scrollNode.style.maxHeight;

                // Does menu content overflow in body?
                if (curY < 0 || (curY + curPos.h > bodyPos.h)) {
                    //DE53943;Make sure to use the window's max height for scrollable popup, especially here it is used for scrollable pulldown list.
                    //since previously different pulldown probably use different max-height, but if is top and bottom overflow, we would reset to window's maxHeight
                    if (scrollNode && maxWinH !== scrollNodeMaxHeight) {
                        scrollNode.style.maxHeight = maxWinH;
                        this.updateScrollbars();
                    }
                    // Reposition menu content to 5px offset from body top
                    var domNodeStyleTop = (-popupAnchorPos.y + minMenuPos) + $PX;
                    //When it is not hosted within anchor node, set host proxy top to 0, and popup node top to 5px offset from host proxy
                    if (!cfg.isHostedWithin) {
                        if (this.hostProxy) {
                            this.hostProxy.style.top = 0;
                        }
                        domNodeStyleTop = minMenuPos + $PX;
                    }
                    domNodeStyle.top = domNodeStyleTop;
                    domNodeStyle.bottom = 'auto';
                }
            }

            // DE113221: Check if menu still overflows width-wise, after direction was changed.
            if (hasOverflowedLeft || hasOverflowedRight) {
                var curX = curPos.x;

                // Does menu content overflow in body?
                if (curX < 0 || (curX + curPos.w > bodyPos.w)) {
                    // Reposition menu content to 5px offset from body left
                    var domNodeStyleLeft = (-popupAnchorPos.x + minMenuPos) + $PX;
                    //When it is not hosted within anchor node, set host proxy top to 0, and popup node top to 5px offset from host proxy
                    if (!cfg.isHostedWithin) {
                        if (this.hostProxy) {
                            this.hostProxy.style.left = 0;
                        }
                        domNodeStyleLeft = minMenuPos + $PX;
                    }
                    domNodeStyle.left = domNodeStyleLeft;
                    domNodeStyle.right = 'auto';
                }
            }


            return true;
        },

        /**
         * <p>Closes this popup, making it invisible.</p>
         *
         * <p>The "opener" property is reset to null.</p>
         *
         * @param {Object=} config Optional configuration settings that will be passed along to the onClose handler (if any).
         */
        close: function close(config) {

            // Do we have a handler where we don't want the popup to close yet?
            if (this.keepOpen) {
                return;
            }

            // Do we have an onClose handler?
            if (this.onClose) {
                // Customization hook; execute it before we lose the handle to opener.
                this.onClose(config);
            }

            // Set the host proxy visibility to hidden.
            setHostProxyVisibility.call(this, false);

            if (this.lockIWForScroll) {
                toggleLockInfoWinForScroll.call(this, this.opener, false);
            }
            this.set('visible', false);
            this.set('opener', null);

            // #789093,#788895.lock IW if popup is opened in it.
            if (this.lockIW) {
                toggleLockInfoWin.call(this, this.lockIW, false);
            }

            // Call the close popup handlers.
            callPopupHandlers.call(this, false);

            // Did we have to update the alignment (i.e. - do we have a cached original alignment ?)
            var originalAlignment = this._orgalgn;
            if (originalAlignment) {
                // Update the alignment.
                this.popupConfig.setAlignment(originalAlignment.host, originalAlignment.popup);
            }

            // if this is the popup that changed the global flow then we should notify the global cfg.
            if (this.resetDirection) {
                this.resetDirection = false;
                $DIRCFG.setDirection(false);
            }
        },

        preBuildRendering: function preBuildRendering(props) {
            this._super(props);

            var popupCfg = this.popupConfig;
            // Is the popup config NOT hosted within?
            if (popupCfg && !popupCfg.isHostedWithin) {
                // Get immediate ancestor and initialize css collection.
                var css = popupCfg.hostProxyCssClass.split(' '),
                    isThemeDefined = false;

                $ARR.forEach($HASH.keyarray($ENUM_THEME_NAMES), function (themeName) {
                    if (css.indexOf($ENUM_THEME_NAMES[themeName]) >= 0) {
                        isThemeDefined = true;
                        return false;
                    }
                });

                //DE64742;if alreay contains theme class, do not add theme class
                //do not inherit its parent themeClassName, if noInheritTheme. Like case in Create Menu
                if (!(isThemeDefined || popupCfg.noInheritTheme)) {
                    var themeClassName = mstrmojo.vi.ui.theme.getThemeClass.call(this);
                    if (themeClassName) {
                        css.push(themeClassName);
                    }
                }
                // Add css collection to host proxy css class.
                popupCfg.hostProxyCssClass = css.join(' ');
            }
        },

        buildRendering: function buildRendering() {
            // Call super.
            var res = this._super();
            if (res) {
                // Do we NOT have a parent and does our DOM node NOT have a parent element?
                if (!this.parent && !this.domNode.parentElement) {
                    // Insert the domNode as a child of the body tag.
                    document.body.appendChild(this.domNode);
                }
            }
            return res;
        },

        postBuildRendering: function postBuildRendering() {
            //DE54389 when isHostedWithin is false, monitor window resize and try to replace the popup widget
            // Attaches an event listener to hear when the size changes.
            var me = this,
                popupCfg = this.popupConfig;

            if (popupCfg && !this._ListenerProc) {
                this._ListenerProc = function () {
                    me.monitorWindow();
                };

                $DOM.attachEvent(window, 'resize', this._ListenerProc);
            }
            this._super();

        },

        /**
         * DE54389 when resize window,
         * (1)update scroll node maxheight,
         * (2)update scrollbar
         * (3)adjust corners positions
         */
        monitorWindow: function () {
            var maxHeight = $DOM.getMaxScrollHeight();

            if (this.updateScrollbars && this.scrollNode) {
                // DE69951; fix scroll node max height.
                // The previous operation in terms of scrollNode maxheight changes are improper.
                // Yet close to GA, add scrollNodeMaxHeight property at the level of PopupList to avoid
                // quirky popuplist behaviour in some modules.
                this.scrollNode.style.maxHeight = (this.scrollNodeMaxHeight || maxHeight) + "px";
                this.updateScrollbars();
            }
            if (this.visible) {
                // DE103926;  _FillsBrowser attaches listener after 150ms delay. In order for that resize event to be
                // called before resize event on Popup, we set a delay for 175ms here. This gives enough time for
                // the layout to finish building before we calculate popup position based on its container
                var me = this,
                    timeoutId = null;
                window.clearTimeout(timeoutId);
                timeoutId = window.setTimeout(function () {
                    /* DE101540; Broser resize changes scroll node height
                       Due to delay of 175 Ms, scrollNode.style.maxHeight intermittently changes in adjustCornersForPopupOverflow
                       and that impact this call which happen afetr 175ms and loses its actual value set from scrollNodeHeight.
                       To solve this issue, now setting value only when we are making call
                    */
                    me.scrollNode.style.maxHeight = (me.scrollNodeMaxHeight || maxHeight) + $PX;
                    me.adjustCornersForPopupOverflow();
                }, 175);
            }
        },

        /**
         * Removes the event handler created in preBuildRendering.
         *
         * @see {mstrmojo.Widget}
         * @ignore
         */
        destroy: function destroy(ignoreDom) {
            // Have we already created our window monitor method?
            if (this._ListenerProc) {
                // Detach the DOM event handler.  Note you must use the same function you passed to attachEvent
                $DOM.detachEvent(window, 'resize', this._ListenerProc);
                delete  this._ListenerProc;
            }
            this._super(ignoreDom);
        },

        unrender: function unrender(ignoreDom) {
            // Check if the popup is not hosted within the host element.
            if (this.popupConfig && !this.popupConfig.isHostedWithin && this.hostProxy) {
                // Remove the node from the body.
                document.body.removeChild(this.hostProxy);

                // Delete the reference to the host proxy
                delete this.hostProxy;
            }

            // Call super.
            this._super(ignoreDom);
        }
    };

}());
/**
 * Created with JetBrains WebStorm.
 * User: ikakushadze
 * Date: 12/12/13
 * This class is created to host static (shared) functions used within DI project.
 */
(function () {
    mstrmojo.requiresCls(
        "mstrmojo.Obj",
        "mstrmojo.locales",
        "mstrmojo.date",
        "mstrmojo.DI.DIConstants",
        "mstrmojo.DI.DIDatabaseHelper"
    );

    mstrmojo.requiresDescs(2052, 2170, 2265, 3434, 3544, 4530, 4699, 8002, 8984, 9614, 9919, 9920, 9921, 9922, 12491, 12492, 12493, 12494, 12495, 12509, 12771, 13031, 13131, 13132, 13980, 13981, 8536);

    var constants = mstrmojo.DI.DIConstants,
        dataTypeMenuItems = constants.dataTypeMenuItems,
        rdcsFlag = constants.rdcsFlag,
        $DOM = mstrmojo.dom,
        $ARR = mstrmojo.array;

    /**
     * @extends mstrmojo.Obj
     * @author Irakli Kakushadze
     */
    mstrmojo.DI.DIHelpers = mstrmojo.declare(
        /** Superclass **/
        mstrmojo.Obj,

        /** Mixins **/
        null,

        /**
         * @lends mstrmojo.DI.DIHelpers.prototype
         */
        null
    );

    mstrmojo.DI.DIHelpers.isIE7 = function isIE7() {
        return mstrmojo.dom.isIE7;
    };

    // mstrmojo.dom.isIE doesn't work for IE11
    mstrmojo.DI.DIHelpers.isIE = function () {
        return $DOM.isIE || !!$DOM.userAgent.match(/Trident\/7\.0/);
    };

    mstrmojo.DI.DIHelpers.isIEOrEdge = function(){
        return  mstrmojo.dom.isEdge || this.isIE();
    };

    /**
     * Static function to get description of available URL formats
     * @returns {String} Available URL formats, separated by comma
     */
    mstrmojo.DI.DIHelpers.getURLCaption = function () {
        //YGUO TQMS 821739 EnableFileImport property should be read from mstrApp.diParams.
        var caption = "";
        if (mstrApp.diParams && mstrApp.diParams.EnableURLImport) {
            if (mstrApp.diParams.EnableFileImport) {
                if (mstrApp.isSingleTier) { // TQMS 909244. Remove "File://" from "Supported URL format" content in mac when importing/browsing from URL because file:// format is not supported by Mac/Linux/Unix system
                    if (window.FormWrapper !== window.client) {
                        caption += "File://";
                    }
                } else {
                    caption += "File://";
                }
            }
            if (mstrApp.diParams.EnableHttpImport) {
                if (caption !== "") {
                    caption += ", ";
                }
                caption += "Http://, Https://";
            }
            if (mstrApp.diParams.EnableFTPImport) {
                if (caption !== "") {
                    caption += ", ";
                }
                caption += "Ftp://";
            }
        }
        return caption;
    };

    /**
     * Gets the tooltips for the URL import option
     * @returns {string}
     */
    mstrmojo.DI.DIHelpers.getUrlTooltip = function getUrlTooltip() {
        var tooltip = "";
        if (!mstrApp.diParams) {
            return tooltip;
        }
        if (!mstrApp.diParams.EnableURLImport) {
            tooltip = mstrmojo.desc(12491, "URL file uploads are currently disabled. Please contact your administrator.");
        } else {
            tooltip = mstrmojo.desc(12492, "Use one of the following URL formats to upload your file:") + " ";
            tooltip += mstrmojo.DI.DIHelpers.getURLCaption();

            if (mstrApp.enableFileImport) {
                tooltip += "\r\r";
                tooltip += mstrmojo.desc(12493, "'File://' format allows you to upload files in your local machine. For example: File://ComputerName/path/FileName.");
            }

            if (mstrApp.enableHttpImport || mstrApp.enableHttpsImport) {
                tooltip += "\r\r";
                if (mstrApp.enableFileImport) {
                    tooltip += mstrmojo.desc(12494, "Some other examples are:");
                } else {
                    tooltip += mstrmojo.desc(12495, "Some examples are:");
                }
            }

            if (mstrApp.enableHttpImport) {
                tooltip += "\r";
                tooltip += "http://host/path/FileName";
                tooltip += "\r";
                tooltip += "https://user:password@host/path/FileName";
            }
            if (mstrApp.enableFtpImport) {
                tooltip += "\r";
                tooltip += "ftp://user:password@host/path/FileName";
                tooltip += "\r";
                tooltip += "ftp://user:password@host:port/path/FileName";
            }
        }
        return tooltip;
    };

    /**
     * Given a JSON, returns the mstrmojo object
     * @param {Object} simpleObject The base object to pass in
     * @param {Array} excludeTags The property names which we do not want to make a deep copy.
     * @returns {mstrmojo.Obj}
     */
    mstrmojo.DI.DIHelpers.createMSTRObjects = function (simpleObject, excludeTags) {
        var mstrObj,
            property,
            i;
        if (simpleObject.constructor === Array) {
            mstrObj = simpleObject;
            for (i = 0; i < mstrObj.length; i++) {
                mstrObj[i] = mstrmojo.DI.DIHelpers.createMSTRObjects(simpleObject[i], excludeTags);
            }
        } else if (typeof simpleObject === "object") {
            mstrObj = new mstrmojo.Obj(simpleObject);
            for (property in simpleObject) {
                if (!excludeTags || excludeTags.indexOf(property) === -1) {
                    if (simpleObject.hasOwnProperty(property)) {
                        mstrObj.set(property,  mstrmojo.DI.DIHelpers.createMSTRObjects(simpleObject[property], excludeTags));
                    }
                }
            }
        } else {
            mstrObj = simpleObject;
        }
        return mstrObj;
    };

    /**
     * Static function used to parse url parameters
     * @param {String} url
     * @returns {Array} key value
     */
    mstrmojo.DI.DIHelpers.getURLParameters = function (url) {
        var i;
        var params;
        var retVal = [];

        if (url) {
            if (url.indexOf('?') > 0) {
                url = url.substr(url.indexOf('?') + 1);
            }

            params = url.split('&');

            for (i = 0; i < params.length; i++) {
                var paramNameValue = params[i].split('=');
                if (paramNameValue.length === 2) {
                    retVal[paramNameValue[0]] = paramNameValue[1];
                }
            }
        }

        return retVal;
    };

    /**
     * gives back the backend enumeration of connector types given the GUI enumeration.
     * @param subtype
     * @returns {*}
     */
    mstrmojo.DI.DIHelpers.getBackendSourceType = function (subtype) {
        var backendType = constants.backendSourceSubtype.localFile;
        switch (subtype) {
            case constants.sourceSubtype.dropbox:
                backendType = constants.backendSourceSubtype.dropbox;
                break;
            case constants.sourceSubtype.bisource:
                backendType = constants.backendSourceSubtype.bISources;
                break;
            case constants.sourceSubtype.clipboard:
                backendType = constants.backendSourceSubtype.clipboard;
                break;
            case constants.sourceSubtype.facebook:
                backendType = constants.backendSourceSubtype.facebook;
                break;
            case constants.sourceSubtype.googleAnalytics:
                backendType = constants.backendSourceSubtype.googleAnalytics;
                break;
            case constants.sourceSubtype.googleBigQuery:
                backendType = constants.backendSourceSubtype.googleBigQuery;
                break;
            case constants.sourceSubtype.googleBigQueryFFSQL:
                backendType = constants.backendSourceSubtype.googleBigQueryFFSQLModel;
                break;
            case constants.sourceSubtype.googleBigQuerySingleTable:
                backendType = constants.backendSourceSubtype.googleBigQuerySingleTable;
                break;
            case constants.sourceSubtype.googleDrive:
                backendType = constants.backendSourceSubtype.googleDrive;
                break;
            case constants.sourceSubtype.hadoop:
                backendType = constants.backendSourceSubtype.hadoopFileBrowser;
                break;
            case constants.sourceSubtype.localFile:
                backendType = constants.backendSourceSubtype.localFile;
                break;
            case constants.sourceSubtype.mdx:
                backendType = constants.backendSourceSubtype.OLAPSources;
                break;
            case constants.sourceSubtype.salesforce:
                backendType = constants.backendSourceSubtype.salesforce;
                break;
            case constants.sourceSubtype.samplefile:
                backendType = constants.backendSourceSubtype.samplefile;
                break;
            case constants.sourceSubtype.searchOnSource:
                backendType = constants.backendSourceSubtype.searchAsASource;
                break;
            case constants.sourceSubtype.twitter:
                backendType = constants.backendSourceSubtype.twitter;
                break;
            case constants.sourceSubtype.url:
                backendType = constants.backendSourceSubtype.url;
                break;
            case constants.sourceSubtype.publicData:
                backendType = constants.backendSourceSubtype.publicData;
                break;
            case constants.sourceSubtype.cloudElement:
                backendType = constants.backendSourceSubtype.cloudElement;
                break;
        }
        return backendType;
    };


    /**
     * Static function used to parse the state parameter
     * @param {String} state
     * @returns {Array} key value
     */
    mstrmojo.DI.DIHelpers.getStateParameters = function (state) {
        var i;
        var params;
        var retVal = [];

        if (state.indexOf(':') >= 0) {
            params = state.split(':');
        } else {
            params = state.split('%3A');
        }

        for (i = 0; i < params.length; i++) {
            var param = params[i];
            if (param.substr(2, 1) === '_') {
                retVal[param.substr(0, 2)] = param.substr(3);
            }
        }

        return retVal;
    };
    mstrmojo.DI.DIHelpers.getExtensionType = function (extension) {
        var ext = extension.toLowerCase(), type;
        //TQMS-900567 Jazhang, enable xlsm file
        if (ext === ".xls" || ext === ".xlsx" || ext === ".xlsm") {
            type = constants.xdaType.excel;
        } else if (ext === ".txt" || ext === ".csv" || ext === ".tsv" || ext === ".prn") {
            type = constants.xdaType.text;
        } else {
            type = 0;
        }
        return type;
    };

    mstrmojo.DI.DIHelpers.setTablesrc = function (controller, srcWidgetID, tableID) {
        if (srcWidgetID) {
            if (!controller.tablesSrc[srcWidgetID]) {
                controller.tablesSrc[srcWidgetID] = [];
            }
            controller.tablesSrc[srcWidgetID].push(tableID);
        }
    };
    /**
     * Data types of columns returned from backend
     */
    /*
    var COLUMN_DATA_TYPES = {
        0: 'reserved',  //unknown
        1: 'integer',  //signed integer
        2: 'unsigned',  //unsigned integer
        3: 'numeric',  //number with exact precision and scale
        4: 'decimal',  //similar to ric , actual precision may be larger
        5: 'real',  //single precision real number, 4 bytes
        6: 'dtdouble',  //double precision real number, 8 bytes
        7: 'dtfloat',  //floating point number with precision
        8: 'dtchar',  //fixed length character string
        9: 'varChar',  //variable length character string
        10: 'longVarChar', //variable length char data up to 2GB
        11: 'binary', //fixed length binary data
        12: 'varBin', //variable length binary data
        13: 'longVarBin', //variable length binary data, up to 2GB
        14: 'date', //date: containing year, month and day
        15: 'dttime', //time: hour, minute, second and fraction of second
        16: 'timeStamp', //include both data and time.
        17: 'nChar',
        18: 'nVarChar',
        30: 'bigDecimal',
        31: 'cellFormatData',
        33: 'Text'
    };
    */

    function getDataTypeString(dataTypeInt) {
        // Use the same kinds string as we show in change data type menu
        var dataTypeToBaseFormType = {0: 2, 1: 2, 2: 2, 3: 2, 4: 2, 5: 2, 6: 2, 7: 2, 8: 3, 9: 3, 10: 3, 11: 2, 12: 2, 13: 2, 14: 8, 15: 9, 16: 1, 17: 3, 18: 3, 21: 2, 22: 2, 23: 3, 30: 11, 31: 2, 33: 3, 34: 2},
            columnDataTypeMap = {
                1: constants.columnDataTypes.integer,
                2: constants.columnDataTypes.integer,
                6: constants.columnDataTypes.dtdouble,
                7: constants.columnDataTypes.dtfloat,
                21: constants.columnDataTypes.integer,
                22: constants.columnDataTypes.nlong,
                30: constants.columnDataTypes.bigDecimal,
                34: constants.columnDataTypes.int64
            },
            dtp = dataTypeToBaseFormType[dataTypeInt],
            ctp = columnDataTypeMap[dataTypeInt],
            str = '';

        switch (dtp.toString()) {
        case constants.dataTypeMenuItems.NUMBER:
            switch (ctp) {
            case constants.columnDataTypes.integer:
                str = mstrmojo.desc(9614, "Integer");
                break;
            case constants.columnDataTypes.nlong:
                str = mstrmojo.desc(13131, "Long");
                break;
            case constants.columnDataTypes.int64:
                str = mstrmojo.desc(13132, "Big Integer");
                break;
            case constants.columnDataTypes.dtfloat:
                str = mstrmojo.desc(8002, "Float");
                break;
            case constants.columnDataTypes.dtdouble:
                str = mstrmojo.desc(2265, "Double");
                break;
            case constants.columnDataTypes.bigDecimal:
                str = mstrmojo.desc(9920, "Big Decimal");
                break;
            default:
                str = mstrmojo.desc(3434, 'Number');
                break;
            }
            break;
        case constants.dataTypeMenuItems.DATE:
            str = mstrmojo.desc(2052, 'Date');
            break;
        case constants.dataTypeMenuItems.DATE_TIME:
            str = mstrmojo.desc(9919, 'DateTime');
            break;
        case constants.dataTypeMenuItems.TIME:
            str = mstrmojo.desc(2170, 'Time');
            break;
        case constants.dataTypeMenuItems.TEXT:
            str = mstrmojo.desc(3544, 'Text');
            break;
        case constants.dataTypeMenuItems.HTML_TAG:
            str = mstrmojo.desc(9921, 'HTML Tag');
            break;
        case constants.dataTypeMenuItems.PHONE_NUMBER:
            str = mstrmojo.desc(8984, 'Phone Number');
            break;
        case constants.dataTypeMenuItems.SYMBOL:
            str = mstrmojo.desc(4530, 'Symbol');
            break;
        case constants.dataTypeMenuItems.URL:
            str = mstrmojo.desc(9922, 'URL');
            break;
        case constants.dataTypeMenuItems.EMAIL:
            str = mstrmojo.desc(4699, 'Email');
            break;
        }

        return str;
    }

    mstrmojo.DI.DIHelpers.getDataTypeString = getDataTypeString;

    /**
     * Function to parse validate result of alternate source for IRR
     * @param {Object} cols JSON object returned from backend
     * @returns {Array}
     */
    mstrmojo.DI.DIHelpers.parseAlternateSourceValidationResults = function parseAlternateSourceValidationResults(cols) {
        var items = [],
            origName,
            origDataType,
            newName,
            newDataType,
            src,
            isMatch,
            origCol,
            newCol;

        $ARR.forEach(cols, function (col) {
            origName = origDataType = newName = newDataType = '';
            isMatch = (col.vt === 3) ? 1 : 0;
            switch (col.vt) {
            case 0: // nothing match
            case 1: // only name match
            case 2: // only data type match
            case 3: // all match
                origName = col.n;
                origDataType = getDataTypeString(col.ddt);
                src = col.src;
                newName = src.n;
                newDataType = getDataTypeString(src.ddt);
                break;
            case 4: // missing column
                origName = col.n;
                origDataType = getDataTypeString(col.ddt);
                break;
            case 8: // new column
                src = col.src;
                newName = src.n;
                newDataType = getDataTypeString(src.ddt);
                break;
            }
            origCol = origDataType ? origName + '(' + origDataType + ')' : origName;
            newCol = newDataType ? newName + '(' + newDataType + ')' : newName;
            items.push([origCol, isMatch, newCol]);
        });

        return items;
    };

    /**
     * Get file name part of one URL
     * @param {string} url
     * @returns {string}
     */
    mstrmojo.DI.DIHelpers.getURLFileName = function (url) {
        var idx = url.lastIndexOf('/');
        return idx >= 0 && idx + 1 !== url.length ? url.substr(idx + 1) : url;
    };

    /*
     * Function to check if v is a valid operationMode
     * @param {number} v
     * @returns {boolean}
     */
    mstrmojo.DI.DIHelpers.isOperationMode = function (v) {
        return v !== undefined && v !== null;
    };

    /**
     * Detect if user press the ctrl key in PC or command key in MAC
     * @param hWin
     * @param e
     * @returns {boolean}
     */
    mstrmojo.DI.DIHelpers.isCtrlKey = function (hWin, e) {
        var evt = e || (hWin || window).event;
        return evt.ctrlKey || evt.metaKey;
    };
    /**
     * Check if user have the privilege to refresh a cube
     * @param model
     * @returns {boolean}
     */
    mstrmojo.DI.DIHelpers.isRefreshable = function (model) {
        var k,
            urlTableCount = 0;
        for (k in model.importSources) {
            var source = model.importSources[k];
            if (source.type === constants.sourceType.file && (source.subtype === constants.sourceSubtype.url || source.subtype === constants.sourceSubtype.publicData)) {
                // DE19296; for the cubes in Sample Dashboard, we can refresh it.
                if (!source.sourceInfo || source.sourceInfo.url.indexOf('http://mirror.microstrategy.com/datahub/samples') !== 0) {
                    urlTableCount++;
                }
            }
        }
        //If all tables in the cube are URL based and if URL is disabled, we don't support republishing of the cube.
        if (model.getAllTableID().length === urlTableCount && !mstrApp.diParams.EnableHttpImport && !mstrApp.diParams.EnableFTPImport && !mstrApp.diParams.EnableFileImport && !mstrApp.diParams.EnableURLImport) {
            return false;
        }
        return true;
    };
    /*
     * Function to check if the str contain the prefix
     * @param {number} v
     * @returns {boolean}
     */
    mstrmojo.DI.DIHelpers.strStartsWith = function (str, prefix) {
        return str.indexOf(prefix) === 0;
    };

    /**
     * Function to adjust the dataIdx property based on mappings (attributes and attribute forms)
     * @param {Array} mappings
     * @param {String} the name of idx field
     */
    mstrmojo.DI.DIHelpers.adjustDataIdx = function (mappings, idxField) {
        var container = [],
            columns;
        if (!mappings || mappings.length === 0) {
            return;
        }
        $ARR.forEach(mappings, function (map) {
            columns = map.subColumns;
            if (columns && columns.length > 1) {
                // have sub columns
                container = container.concat(columns);
            } else {
                container.push(map);
            }
        });
        container.sort(function (a, b) {
            return a[idxField] - b[idxField];
        });
        //YGUO TQMS-995368 remove code, we do not need to assign the idx again
    };

    mstrmojo.DI.DIHelpers.setDataIdx = function (mappings, headers, idxField) {
        if (!headers || headers.length === 0) {
            return;
        }

        if (headers[0].hasOwnProperty('clix')) {
            $ARR.forEach(mappings, function (map) {
                var ix = map.ix;
                map[idxField] = $ARR.find(headers, 'clix', ix);
                if (map.isMultiForm) {
                    $ARR.forEach(map.subColumns, function (item) {
                        item[idxField] = $ARR.find(headers, 'clix', item.ix);
                    });
                }
            });
        }

        // DE9673, now backend return column ID in preview data, we can use it to match mapping and preview
        if (headers[0].hasOwnProperty('did')) {
            $ARR.forEach(mappings, function (map) {
                var did = map.did;
                var idx = $ARR.find(headers, 'did', did);
                if (idx !== -1) {
                    map[idxField] = idx;
                }
                if (map.isMultiForm) {
                    $ARR.forEach(map.subColumns, function (item) {
                        idx = $ARR.find(headers, 'did', item.did);
                        if (idx !== -1) {
                            item[idxField] = idx;
                        }
                    });
                }
            });
        }
    };

    /**
     * Function to encode the input data
     * @param v
     * @returns {string|number}
     */
    mstrmojo.DI.DIHelpers.encodeData = function (v) {
        var r = "";
        if (v !== undefined) {
            if (typeof v === "number") {
                r = v;
            } else {
                r = mstrmojo.string.encodeHtmlString(v, false, true);
            }
        }
        return r;
    };

    /**
     * folder size unit
     */
    var FOLDER_SIZE_UNIT = {
        0: 'Bytes',
        1: 'KB',
        2: 'MB',
        3: 'GB',
        4: 'TB',
        5: 'PB'
    };

    function getFolderSizeUnit(dataTypeInt) {
        return FOLDER_SIZE_UNIT[dataTypeInt] || 'unknown';
    }

    /**
     * Function return the size with proper Units and 3 Precision number
     */
    mstrmojo.DI.DIHelpers.getRoundSize = function getRoundSize(size) {
        var i;
        for (i = 0; (size / 1024) > 1; i++) {
            size = size / 1024;
        }

        size = size.toPrecision(3);
        return size + getFolderSizeUnit(i);
    };

    /**
     * Function to find the newly elements
     * @param {Array} srcArr
     * @param {Array} dstArr
     * @returns {Array}
     */
    mstrmojo.DI.DIHelpers.findNewElements = function (srcArr, dstArr) {
        var ret = [],
            idx;
        if (srcArr && srcArr.length) {
            $ARR.forEach(dstArr, function (elem) {
                idx = $ARR.indexOf(srcArr, elem); // TQMS 956240: use mstrmojo.array.indexOf
                if (idx === -1) {
                    ret.push(elem);
                }
            });
        } else if (dstArr && dstArr.length) {
            ret = [].concat(dstArr);
        }

        return ret;
    };

    /**
     * Generate a cube name based on emma table names.
     *
     * @param {Array} tableNames Emma table names
     * @returns {string} Cube name
     */
    mstrmojo.DI.DIHelpers.generateCubeName = function (tableNames) {
        var name,
            tableNum,
            MAX_LEN = 50;

        name = tableNames.join(' ');
        if (name.length > MAX_LEN) {
            name = name.slice(0, MAX_LEN) + '...';
        }
        tableNum = tableNames.length;
        if (tableNum > 1) {
            name += ' (' + tableNum + ' tables)';
        }

        return name;
    };

    /**
     * Function to parse validate results for republish workflow
     * @param {Object} res
     * @returns {{isValidate: boolean, tbids: Array, tableValidate: Array, missingColumnTbids: Array, mismatchedDatatypeTbids: Array, missingTableTbids: Array, missingColumns: {}, mismatchedDatatypeColumns: {}, missingTablesColumns: {}}}
     */
    mstrmojo.DI.DIHelpers.parseValidateSourceResults = function (res) {
        var results = {
                isValidate: true, // Validate or not on cube level
                hasError: false,
                tbids: [], // array of tables ID
                tableValidate: [], // validate or not for each table
                missingColumnTbids: [], // array of  missing columns tables ID
                mismatchedDatatypeTbids: [], // array of mismatched datatype tables ID
                missingTableTbids: [], // array for missing tables ID
                errorTableTbids: [], // array for erro tables ID
                missingColumns: {}, // Object to hold missing columns, use table ID as key for each table
                mismatchedDatatypeColumns: {}, // Object to hold mismatched datatypes columns, use table ID as key for each table
                missingTablesColumns: {}, // Object to hold missing tables columns, use table ID as key for each table
                errorTableErrCode: {},
                errorTableErrMsg: {}
            },
            vts = res && res.vts;

        $ARR.forEach(vts, function (table) {
            var tbid = table.tbid,
                tbvt = table.vt,
                tbErrorMsg = table.emsg,
                cols = table.cols || [],
                isValidate = true,
                hasError = false,
                isMissingTable,
                missingColumns = [],
                mismatchColumns = [];

            if (tbvt === 1) {
                isValidate = true;
            } else {
                // TQMS 995704: backend add other error code here.
                switch (tbvt) {
                    case constants.backendError.switchingFileType:
                    case constants.backendError.noExternalSession:
                    case constants.backendError.databaseCredentialsNotAvailable:
                    case constants.backendError.CECredentialNotAvailable:
                    case constants.backendError.AuthenticationError:
                    case constants.backendError.shouldBeIgnored:
                        hasError = true;
                        break;
                }
                // tbvt indicate this table are not completely matched, need to check columns
                $ARR.forEach(cols, function (col) {
                    var vt = col.vt;
                    switch (vt) {
                    case 1:
                        // datatype mismatched
                        mismatchColumns.push(col);
                        break;
                    case 4:
                        // missing column
                        missingColumns.push(col);
                        break;
                    }
                });
            }
            if (hasError) {
                results.errorTableTbids.push(tbid);
                results.errorTableErrCode[tbid] = tbvt;
                results.errorTableErrMsg[tbid] = tbErrorMsg;
                results.isValidate = false;
                results.hasError = true;
            }
            isMissingTable = missingColumns.length > 0 && missingColumns.length === cols.length;
            if (missingColumns.length > 0 || mismatchColumns.length > 0) {
                isValidate = false;
            } else {
                isValidate = true;
            }
            // save parse result for this table
            if (isValidate === false) {
                results.isValidate = false; // at least one table is not validate
            }
            results.tbids.push(tbid);
            results.tableValidate.push(isValidate);
            if (missingColumns.length > 0) {
                if (isMissingTable) {
                    results.missingTableTbids.push(tbid);
                    results.missingTablesColumns[tbid] = missingColumns;
                } else {
                    results.missingColumnTbids.push(tbid);
                    results.missingColumns[tbid] = missingColumns;
                }
            }
            if (mismatchColumns.length > 0) {
                results.mismatchedDatatypeTbids.push(tbid);
                results.mismatchedDatatypeColumns[tbid] = mismatchColumns;
            }
        });

        return results;
    };

    mstrmojo.DI.DIHelpers.truncate = function (name, strLen, atEnd) {
        if (name && name.length > strLen) {

            var sepLen = 3,
                charsToShow = strLen - sepLen,
                frontChars = Math.ceil(charsToShow / 2),
                backChars = Math.floor(charsToShow / 2);
            if (atEnd) {
                //if we want to add the ... at the end of the string
                return name.substr(0, charsToShow) + "...";
            } else {
                //if we want to add the ... at the middle of the string
                return name.substr(0, frontChars) +
                    "..." +
                    name.substr(name.length - backChars);
            }

        } else {
            return name;
        }
    };

    mstrmojo.DI.DIHelpers.getAbsoluteFileName = function (file) {
        var display,
            pos = file.lastIndexOf("\\");  //For windows OS
        if (pos === -1) {
            pos = file.lastIndexOf("/"); //for MAC OS
        }
        display = file.substring(pos + 1, file.length);
        return display;
    };

    /**
     * Function to make sure the pop up page never has minus position
     * @param {HTMLElement} domNode Dom node of the popup dialog
     */
    mstrmojo.DI.DIHelpers.reevaluatePopupPosition = function (domNode) {
        if (domNode) {
            var elementStyle = domNode.style,
                elementDisplay = elementStyle.display,
                left = elementStyle.left,
                top = elementStyle.top;
            elementStyle.display = "block";
            if (parseInt(left.substring(0, left.length - 2)) < 0) {
                elementStyle.left = "0px";
            }
            if (parseInt(top.substring(0, top.length - 2)) < 0) {
                elementStyle.top = "0px";
            }
            elementStyle.display = elementDisplay;
        }
    };

    /**
     * Function to toggle collapse of one mojo Widget
     * @param {mstrmojo.Widget} widget
     * @returns {boolean} collapse status
     */
    mstrmojo.DI.DIHelpers.expandNode = function (widget) {
        var isVisible = widget.visible;
        widget.set('visible', !isVisible);
        return !isVisible;
    };

    /**
     * Function to normalize timestamp and make it available for all browsers. (TQMS-992516)
     * @param timestamp
     * @returns {*}
     */
    mstrmojo.DI.DIHelpers.normalizeTimestamp = function (timestamp) {
        /**
         * Available timestamp for all browsers is like "YYYY/MM/DD HH:mm:ss"
         * Currently the decimal precision of second is not acceptable by all browsers. We need to remove it.
         */
        var ts = timestamp.replace(/-/g, "/");
        var i = ts.indexOf(".");
        if (i > 0) {
            ts = ts.substring(0, i);
        }
        return ts;
    };

    /**
     * Function to return description of one error code
     * @param code
     * @param sourceType
     * @returns {string}
     */
    mstrmojo.DI.DIHelpers.getBackendErrorStr = function (code, sourceType) {
        var msg = "";
        switch (code) {
            case constants.backendError.switchingFileType:
                msg = mstrmojo.desc(12509, "Switching the file type is not allowed during republishing or editing the cube.");
                break;
            case constants.backendError.noExternalSession:
            case constants.backendError.databaseCredentialsNotAvailable:
            case constants.backendError.CECredentialNotAvailable:
            case constants.backendError.AuthenticationError:
                msg = mstrmojo.desc(14392, "We do not have the credentials needed to get the data for this table. Please provide the credentials to proceed publishing this table.");
                break;
        }
        return msg;
    };

    /**
     * Function to find comment elements of two arrays
     *
     * @param larr
     * @param rarr
     * @param equalFn
     * @returns {Array}
     */
    mstrmojo.DI.DIHelpers.getCommonElements = function (larr, rarr, equalFn) {
        var ret = [],
            i,
            j;
        for (i = 0; larr && i < larr.length; i++) {
            for (j = 0; rarr && j < rarr.length; j++) {
                if (equalFn(larr[i], rarr[j])) {
                    ret.push(larr[i]);
                    break;
                }
            }
        }

        return ret;
    };

    /**
     * Helper function to format the date time string to current locale format
     *
     * @param {String} datetimeStr input data time string
     * @param {Boolean=false} isUTC is the input data time string in UTC time? if true function will convert the UTC time to current timezone time
     * @returns {string}
     * @constructor
     */
    mstrmojo.DI.DIHelpers.formatDateAndTime = function (datetimeStr, isUTC) {
        var $D = mstrmojo.date;
        var $L = mstrmojo.locales;
        var info, dateInfo, timeInfo, dateStr, timeStr, date;

        // parse the Iserver date time
        info = $D.parseDateAndOrTime(datetimeStr);
        dateInfo = info.date;
        timeInfo = info.time;

        if (isUTC) {
            date = new Date(Date.UTC(dateInfo.year, dateInfo.month - 1, dateInfo.day, timeInfo.hour, timeInfo.min, timeInfo.sec));
            info = $D.getDateJson(date);
            dateInfo = info;
            timeInfo = info;
        }

        // format the date time use current locale display format
        dateStr = $D.formatDateInfo(dateInfo, $L.datetime.DATEDISPLAYFORMAT);
        timeStr = $D.formatTimeInfo(timeInfo, $L.datetime.TIMEDISPLAYFORMAT);

        return dateStr + " " + timeStr;
    };

    /**
     * Workstation server based window
     * @returns {boolean}
     */
    mstrmojo.DI.DIHelpers.isServerBasedWS = function () {
        return !!mstrApp.isWorkstation && !mstrApp.isSingleTier;
    };

    /**
     * Workstation stand alone [This has been deprecated, don't use it anymore.]
     * @returns {boolean}
     */
    mstrmojo.DI.DIHelpers.isLocalWS = function () {
        return !!mstrApp.isWorkstation && !!mstrApp.isSingleTier;
    };

    /**
     * Workstation stand alone DI in VI
     * @returns {boolean}
     */
    mstrmojo.DI.DIHelpers.isDIinVI = function () {
        return !!mstrApp.isWorkstation && !!mstrApp.isSingleTier && !!mstrApp.isPopup;
    };

    mstrmojo.DI.DIHelpers.extractFileNameFromHadoopURL = function(url) {
        if (!url) {
            return "";
        }

        var firstIndex, fileName;

        firstIndex = url.lastIndexOf("\/") + 1;
        fileName = url.substring(firstIndex);

        return fileName;
    };

    mstrmojo.DI.DIHelpers.extractFileExtensionFromHadoopURL = function(url) {
        if (!url) {
            return "";
        }

        var firstIndex, fileName;

        firstIndex = url.lastIndexOf("\/") + 1;
        fileName = url.substring(firstIndex);

        return fileName.substring(fileName.lastIndexOf(".")+1);
    };

    /**
     * Workstation including stand alone window, server based window and DI in VI
     * @returns {boolean}
     */
    mstrmojo.DI.DIHelpers.isWS = function () {
        return !!mstrApp.isWorkstation;
    };

    /**
     * Unifies environment checking mechanism.
     *
     * This functionality will return one Object with
     * several env checking methods and current ENV property attached.
     *
     * Under current circumstances, Operating System, Platform and Entry
     * need to be checked while implementing features or fixing bugs for DI.
     *
     * The aforementioned three key properties will be randomly combined to
     * detect any environment.
     *
     * Hence a bunch of methods will be generated via this combination.
     *
     * Programmer could check env at different layer.
     * e.g.
     *
     * isWeb:
     * This method just tells developer current platform(here it's Web platform),
     * without considering its current Operating System and current Entry.
     *
     * isWebDossier:
     * This method not only tells us current platform, but gives developers
     * the info of Entry(here it's Dossier at Web platform), but it omits Operating
     * System's checking.
     *
     * isWSMacDataSet:
     * This method informs developer very detailed environmental info. It gives
     * us current Platform, OS and Entry(here it's DataSet in Mac OS at Workstation).
     *
     * And so on for the remaining methods we haven't metioned in this description.
     *
     * For those of you who just needs one string of current environment,
     * this methods offers a property called ENV, which is a string hyphenating all
     * the three key properties above under specific circumstance.
     *
     * e.g.
     *
     * WebMacDossier:
     * This means Dossier at Mac OS in Web Platform.
     * And so on for the rest.
     *
     * @return {Object} An object with several env checking methods and current ENV property attached.
     *
     */
    mstrmojo.DI.DIHelpers.getEnvObj = function (){
        var os = (navigator.platform.indexOf('Win') !== -1 ? 'Win' : 'Mac'),
            platform = !!mstrApp.isWorkstation ? 'WS' : 'Web',
            env = [];

        env.push(platform, os);

        return {
            ENV: env.join('-'),
            isWSClient: function() {
                if(!window.FormWrapper || !window.FormWrapper.isDesktop){
                    return false;
                }
                return !window.FormWrapper.isDesktop();
            },
            isDesktopClient: function() {
                if(!window.FormWrapper || !window.FormWrapper.isDesktop){
                    return false;
                }
                return window.FormWrapper.isDesktop();
            },
            // Single checking condition
            isWeb: function (){
                return platform === 'Web';
            },
            isWS: function (){
                return platform === 'WS';
            },
            isWin: function (){
                return os === 'Win';
            },
            isMac: function (){
                return os === 'Mac';
            },
            isDataSet: function (){
                return  mstrApp.placeholder === 'DIApp' || mstrApp.placeholder === 'mainDIApp' || mstrApp.placeholder === 'QBApp';
            },
            isDIinVI: function (){
                return !!mstrApp.isFromVI;
            },

            isInDI: function () {
              return  mstrApp.placeholder === 'DIApp' || mstrApp.placeholder === 'mainDIApp';
            },
            isInQB: function () {
               return mstrApp.placeholder === 'QBApp';
            },

            isAppSchema: function () {
              return !!window.mstrAppSchema;
            },

            // Double checking condition
            isWebWin: function (){
                return this.isWeb() && this.isWin();
            },
            isWebMac: function (){
                return this.isWeb() && this.isMac();
            },
            isWebDataSet: function (){
                return this.isWeb() && this.isDataSet();
            },
            isWebDossier: function (){
                return this.isWeb() && this.isDIinVI();
            },
            isWSWin: function (){
                return this.isWS() && this.isWin();
            },
            isWSMac: function (){
                return this.isWS() && this.isMac();
            },
            isWSDataSet: function (){
                return this.isWS() && this.isDataSet();
            },
            isServerBasedWS:mstrmojo.DI.DIHelpers.isServerBasedWS,
            isWSDossier: function (){
                return this.isWS() && this.isDIinVI();
            },
            isWSLiveMode: function getWSLiveMode() {
                return this.isWS() && parseInt(window.FormWrapper.isWSLiveMode(), 10) === 1;
            },
            isWSDossierLocalMode: function() {
                return this.isWSDossier() && !this.isWSLiveMode();
            },

            // Triple checking condition
            isWebWinDataSet: function (){
                return this.isWeb() && this.isWin() && this.isDataSet();
            },
            isWebMacDataSet: function (){
                return this.isWeb() && this.isMac() && this.isDataSet();
            },
            isWebWinDossier: function (){
                return this.isWeb() && this.isWin() && this.isDIinVI();
            },
            isWebMacDossier: function (){
                return this.isWeb() && this.isMac() && this.isDIinVI();
            },
            isWSWinDataSet: function (){
                return this.isWS() && this.isWin() && this.isDataSet();
            },
            isWSMacDataSet: function (){
                return this.isWS() && this.isMac() && this.isDataSet();
            },
            isWSWinDossier: function (){
                return this.isWS() && this.isWin() && this.isDIinVI();
            },
            isWSMacDossier: function (){
                return this.isWS() && this.isMac() && this.isDIinVI();
            },
            isStandaloneDataSet: function () {
                return !this.isDIinVI() && this.isDataSet();
            }
        };
    }

    /**
     * Onetier desktop
     * @returns {boolean}
     */
    mstrmojo.DI.DIHelpers.isOnetier = function () {
        return !!mstrApp.isSingleTier;
    };

    /**
     * This function constructs the xml to send backend instead of json
     * @param {string} oid the target attribute ID, if user is defining RA on a fact table or lookup table and the attribute is not linked to the special relationship table, we should map the ID column to the picked attribute first, then define RA definition.
     * @param {object} hierarchyMaps source table ID, if not provides, this function will get the mapping change for current source
     * @returns {string} the xml string
     */
    mstrmojo.DI.DIHelpers.getHierarchyMappingXML = function(oid, hierarchyMaps) {
        var xml = "";
        var drvflg = 0,
            recurisve = 1,
            ot = 12;
        if (hierarchyMaps && hierarchyMaps[rdcsFlag.ID]) {
            xml += '<mpcs>';
            xml += '<mpc ';
            xml += 'did="' + hierarchyMaps[rdcsFlag.ID].did + '" drvflg="' + drvflg + (hierarchyMaps[rdcsFlag.ID].n?('" n="' + hierarchyMaps[rdcsFlag.ID].n + '" ot="'):'') + ot + '" recurisve="' + recurisve + '" ';
            if (!!oid && oid !== '') {
                xml += 'oid="' + oid  + '" ';
            }
            xml += '>';
            if (hierarchyMaps[rdcsFlag.JOIN_ID]) {
                xml += '<rdcs>';
            }
            for (var fg = rdcsFlag.JOIN_ID; fg <= rdcsFlag.DISTANCE; fg++) {
                if (hierarchyMaps[fg] !== undefined) {
                    xml += '<rdc did="' + hierarchyMaps[fg].did + '" fg="' + fg + '"/>';
                }
            }
            if (hierarchyMaps[rdcsFlag.JOIN_ID]) {
                xml += '</rdcs>';
            }
            xml += '</mpc>';
            xml += '</mpcs>';
        }
        return xml;
    };

    /*
     * Function to check what's current operation mode
     * @returns {number}
     */
    mstrmojo.DI.DIHelpers.getOperationMode = function(){
        return mstrApp.getRootController().getModel().operationMode;
    };


    /**
     * Standardizes the DBRoles so that Web and Desktop have the same format
     * @param items - an object of datasets that contain dbRoles
     * @returns {Array} - an array of datasets that now have dbmsObj as a field on dbRoles
     */
    mstrmojo.DI.DIHelpers.standardizeDBRolesFormat = function standardizeDBRolesFormat(items) {
        var exclude = ['att', 'dbRole', 'tableMap'],
            dbInfo,
            dbRole,
            dbmsObj,

            // cnsr vars
            efd,
            def,
            cnsr,

            // DBS vars
            keyValue,
            auth,
            dbp,
            dbtp,
            setDbpField = (function () {
                // cnsr = AUTHENTICATIONMETHOD=1;DATABASENAME=tutorial_wh;HOSTNAME=10.27.68.208;PORT=1433;APPLICATIONUSINGTHREADS=1;DRIVER=MicroStrategy ODBC Driver for SQL Server Wire Protocol;
                var // TYPE_BOOL = 'boolean',
                    TYPE_LIST = 'list',
                    TYPE_NUM = 'number',
                    TYPE_TEXT = 'text';

                function pushObject(arr, field, value, ids, type, opt) {
                    // verify that arr and value actually exist (field and ids are also required, but passed in below)
                    if (arr && value) {
                        // options are optional (only used for lists)
                        if (opt) {
                            arr.push({
                                field: field,
                                fieldV: value,
                                IDS: ids,
                                options: opt,
                                tp: type
                            });
                        } else {
                            arr.push({
                                field: field,
                                fieldV: value,
                                IDS: ids,
                                tp: type
                            });
                        }
                    }
                }

                // key already has toLowerCase called on it
                return {
                    authenticationmethod: function (arr, value) {
                        pushObject(arr, 'auth', value, 7776, TYPE_LIST, [
                            {
                                IDS: 13980,
                                n: mstrmojo.desc(13980),
                                v: '1' // default encryption
                            },
                            {
                                IDS: 13981,
                                n: mstrmojo.desc(13981),
                                v: '4' // kerberos
                            }
                        ]);
                    },

                    databasename: function (arr, value) {
                        pushObject(arr, 'db', value, 8519, TYPE_TEXT);
                    },

                    hostname: function (arr, value) {
                        pushObject(arr, 'host', value, 8533, TYPE_TEXT);
                    },

                    port: function (arr, value) {
                        pushObject(arr, 'port', value, 8534, TYPE_NUM);
                    },

                    server: function (arr, value) {
                        pushObject(arr, 'svr', value, 8536, TYPE_TEXT);
                    }
                };
            }());

        items = Object.keys(items).map(function (key) {
            // we need the table to also be an mstrmojo.Obj, so use a helper to get that
            return mstrmojo.DI.DIHelpers.createMSTRObjects(items[key], exclude);
        });

        // initialize the DBInfo so we can reuse the controller code flow
        $ARR.forEach(items, function (ds) {
            $ARR.forEach(ds.tables, function (table) {
                table.dbRole = (table.dbRole && table.dbRole.oi) || table.dbRole;
                table.dbmsObj = table.dbmsObj && table.dbmsObj.oi;

                dbRole = table.dbRole;

                if (dbRole) {
                    dbRole.dbmsObj = table.dbmsObj;
                    dbmsObj = dbRole.dbmsObj;

                    if (!dbRole.dbms) {
                        dbRole.dbms = dbRole.def && dbRole.def.dbms && dbRole.def.dbms.did;
                    }
                }

                if (!dbmsObj || dbmsObj.DBInfo) {
                    return;
                }

                dbmsObj.DBInfo = {};
                dbInfo = dbmsObj.DBInfo;

                efd = dbRole.efd;
                if (!efd) {
                    return;
                }

                efd.forEach(function (e) {
                    def = e.oi && e.oi.def;
                    if (!def) {
                        return;
                    }

                    dbtp = def.dbtp;
                    if (dbtp) {
                        dbRole.db_type = dbtp;
                        dbInfo.dbTypes = {
                            dbt: {
                                v: dbtp,
                                //This logic to get n is not correct, stop to use this, we should get it from DBProperties.xml
                                n: mstrmojo.desc(mstrmojo.DI.DIDatabaseHelper.getDescriptionIdByDBType(dbtp))
                            }
                        };
                    }

                    cnsr = def.cnsr;
                    if (!cnsr) {
                        return;
                    }

                    dbp = [];
                    auth = null;

                    // cnsr = AUTHENTICATIONMETHOD=1;DATABASENAME=tutorial_wh;HOSTNAME=10.27.68.208;PORT=1433;APPLICATIONUSINGTHREADS=1;DRIVER=MicroStrategy ODBC Driver for SQL Server Wire Protocol;
                    dbRole.connstr = cnsr;
                    cnsr.split(';').forEach(function (field) {
                        keyValue = field.split('=');
                        keyValue[0] = keyValue[0].toLowerCase().trim();
                        if (keyValue[0] === 'driver') {
                            dbInfo.driverInstalled = true;
                        } else if (keyValue[0] === 'authenticationmethod') {
                            auth = keyValue;
                        } else if (setDbpField[keyValue[0]]) {
                            setDbpField[keyValue[0]](dbp, keyValue[1]);
                        }
                    });

                    // We want the authentication method to be the last dynamic field, so we pull it out and append it to the end.
                    if (auth) {
                        setDbpField[auth[0]](dbp, auth[1]);
                    }

                    // The db properties extracted from above logic is not correct, but the drvierInstalled field is still useful.
                    // So I just commented the following code, the extracting logic will be in DBCredentialEditor.js which will
                    // first send a task to get db data from DBProperties.xml.

                    // dbInfo.DBS = [{
                    //     dbVersions: [{
                    //         DBPS: [{
                    //             DBP: dbp
                    //         }]
                    //     }]
                    // }];
                });
            });
        });
        return items;
    };

    /**
     * filterDisableSources
     *
     * filters disabled sources in filterDisableSources.xml, currently it is only used by Application Schema.
     */
    mstrmojo.DI.DIHelpers.filterDisableSources = function filterDisableSources(sourceType) {
        return $ARR.indexOf(mstrApp.diParams.disabledSources, sourceType) < 0;
    };


    /**
     * getPopupWindowOptions
     * get a set of option for popup window, used for oauth, connector
     * @returns {string}
     */
    mstrmojo.DI.DIHelpers.getPopupWindowOptions = function getPopupWindowOptions() {
        var wnd_settings = {};
        var screenX = window.screenX || window.screenLeft || 0, // current window's left
            screenY = window.screenY || window.screenTop || 0, // current window's top
            wndW = 800,// current window width, try to use outer width if possible, otherwise use inner width
            wndH = 600,// current window height, try to use outer height if possible, otherwise use inner height
            wnd_options;
        // TQMS 947321: IE8 doesn't support window.outerWidth/window.outerHeight/window.screenX/window.screenY
        if (document.body && document.body.offsetWidth) {
            wndW = document.body.offsetWidth;
            wndH = document.body.offsetHeight;
        }
        if (document.compatMode === 'CSS1Compat' &&
            document.documentElement &&
            document.documentElement.offsetWidth) {
            wndW = document.documentElement.offsetWidth;
            wndH = document.documentElement.offsetHeight;
        }
        if (window.innerWidth && window.innerHeight) {
            wndW = window.innerWidth;
            wndH = window.innerHeight;
        }
        if (window.outerWidth) {
            wndW = window.outerWidth;
        }
        if (window.outerHeight) {
            wndH = window.outerHeight;
        }

        wnd_settings.height = wndH * 0.5;
        wnd_settings.width = wndW * 0.8;
        if (wnd_settings.height < 600 || isNaN(wnd_settings.height)) {
            wnd_settings.height = 600;
        }
        if (wnd_settings.width < 800 || isNaN(wnd_settings.width)) {
            wnd_settings.width = 800;
        }

        wnd_settings.left = screenX + (wndW - wnd_settings.width) / 2;
        wnd_settings.top = screenY + (wndH - wnd_settings.height) / 8;

        //DE77517 this logic is for live/local dossier in windows workstation.
        //In this environment, the oauth log in window could not pop up in the center of the screen.
        //The root cause is frontend could not get right window's position. As a workarond, we set the pop up window in the center of the screen.
        if(this.getEnvObj().isWSWin() && this.getEnvObj().isDIinVI()) {
            wnd_settings.left = (window.screen.width - wnd_settings.width)/2;
            wnd_settings.top = (window.screen.height - wnd_settings.height)/2;
        }

        wnd_options = "width=" + wnd_settings.width + ",height=" + wnd_settings.height;
        wnd_options += ",toolbar=0,scrollbars=1,status=1,resizable=1,location=1,menuBar=0";
        wnd_options += ",left=" + wnd_settings.left + ",top=" + wnd_settings.top;

        return wnd_options;
    };


    /**
     * Function to create an empty new popup window
     * @params {String} url
     * @params {String} name
     * @returns {Object}
     */
    mstrmojo.DI.DIHelpers.createPopupWindow = function createPopupWindow(url, name) {
        var wnd,
            wnd_options;

        wnd_options = this.getPopupWindowOptions();
        if (!url) {
            url = '';
        }
        wnd = window.open(url, name, wnd_options);
        return {wnd: wnd};
    };

    /**
     * Function to set the location of popup window
     * @param {window} wnd
     * @param {string} name
     * @param {string} url
     * @returns {Object} window
     */
    mstrmojo.DI.DIHelpers.openPopupWindow = function openPopupWindow(wnd, name, url) {
        var r;
        if (wnd && !wnd.closed) {
            wnd.location = url;
            wnd.focus();
        } else {
            r = this.createPopupWindow(url);
            wnd = r.wnd;
            if (wnd) {
                wnd.focus();
            }
        }
        return wnd;
    };

    /**
     * Function to send response to opener window
     * @param {string} response
     */
    mstrmojo.DI.DIHelpers.sendResponse2Window = function sendResponse2Window(response, origin, wnd) {
        var opener;
        if (wnd) {
            opener = wnd;
        } else {
            opener = window.opener;
        }
        if (opener) {
            if (origin === undefined) {
                origin = window.location.origin;
                if (!origin) {
                    origin = window.location.protocol + '//' + window.location.hostname + (window.location.port ? ':' + window.location.port : '');
                }
            }
            try {
                if (this.isIE() && opener.postMessagePassthrough) { // mstrmojo.dom.ieIE doesn't work for IE11
                    // in IE, postMessage between windows doesn't work, we need to:
                    //  - use iframe postMessage proxy, postMessage works between iframes
                    //  - or directly call opener's function since we're in same origin
                    opener.postMessagePassthrough(response, origin);
                    try { // Close the window first in IE, work in IE7 and later
                        window.open('', '_self', '');
                        window.close();
                    } catch (e) {
                        window.close();
                    }
                } else {
                    opener.postMessage(response, origin);
                }
            } catch (ex) {
                console.log("postMessage error: " + ex);
            }
        }
    };

    /*
     * convertDataSourceType2SourceType
     *
     * convert appschema data source type to sourcetype of iserver
     */
    mstrmojo.DI.DIHelpers.convertDataSourceType2SourceType = function convertDataSourceType2SourceType(type) {
        switch(type) {
            case constants.dataSourceType.DROPBOX:
                return constants.sourceType.dropbox;
            case constants.dataSourceType.GOOGLE_DRIVE:
                return constants.sourceType.googleDrive;
            case constants.dataSourceType.GOOGLE_ANALYTICS:
                return constants.sourceType.googleAnalytics;
            case constants.dataSourceType.SALESFORCE:
                return constants.sourceType.salesforce;
            case constants.dataSourceType.GOOGLE_BIGQUERY:
                return constants.sourceType.googleBigQuery;
            default:
                return -1;
        }
    };

    /**
     * function to generate text with highlighted words
     * @param keyWord
     * @param text
     * @param highlightedCssClass
     * @returns {string}
     */
    mstrmojo.DI.DIHelpers.highlightKeyWords = function highlightKeyWords(keyWord, text, highlightedCssClass) {
        var escapes = "\\*.?+$^[](){}|/",
            searchTextEscaped = keyWord,
            esc,
            i;
        if(keyWord === ""){
            return text;
        }
        for (i in escapes) {
            if (escapes.hasOwnProperty(i)) {
                esc = escapes[i];
                searchTextEscaped = searchTextEscaped.replace(new RegExp('\\'+esc,'g'), '\\'+esc);
            }
        }
        var filterRegExp = new RegExp('('+searchTextEscaped+')','ig');
        var DELEMITER = '\u001E',
            encode = mstrmojo.string.encodeHtmlString,
            highlightText;
        if (filterRegExp.test(text)) {
            text = text.replace(filterRegExp, function (match) {
                return DELEMITER + match + DELEMITER;
            });
            highlightText = $ARR.map((text || "").split(DELEMITER), function (v, idx) {
                return (idx % 2 === 0) ? encode(v) : ('<span class="' + highlightedCssClass + '">' + encode(v) + '</span>');
            });
            return highlightText.join("");
        }
    };

    mstrmojo.DI.DIHelpers.detectCustomImg = function (name, iconNode) {
        if (!name || !(iconNode.nodeType && iconNode.nodeType === window.Node.ELEMENT_NODE)){
            return;
        }
        var _name = name.replace ? name.replace(/\s+/g, '') : '';
        var head = document.getElementsByTagName('head')[0];
        var img = document.createElement('img');
        img.src = "../javascript/mojo/css/images/DI/connectors/" + _name + ".png";
        img.onload = function () {
            iconNode.style.background = "url(../javascript/mojo/css/images/DI/connectors/" + _name + ".png) no-repeat";
            head.removeChild(img);
        };
        img.onerror = function () {
            iconNode.style.background = "url(../javascript/mojo/css/images/DI/connectors/default.png) no-repeat";
            head.removeChild(img);
        };
        head.appendChild(img);
    };

    /**
     * Function to splice url coz file name or folder name may contains '###' itself.
     *
     * @param {string} url needs to be parsed
     */
    mstrmojo.DI.DIHelpers.spliceUrlBySeparator = function (url) {
        //Get real separator index coz it has symmetrical structure.
        var arr = url.split('#');
        return arr.slice(arr.length / 2 + 1).join('#');
    };

    mstrmojo.DI.DIHelpers.isOriginalConnector = function (oid) {
        var connectorList = constants.originalConnector;
        if(connectorList.elastic === oid || connectorList.tapClicks === oid){
            return true;
        }
        return false;
    };

    // Check if current event is coming from its parent or any ancestor element.
    // Need to be called on the component you wanna check event's origin.
    // Function.prototype.call will be recommended.
    mstrmojo.DI.DIHelpers.acceptEventFromAncestor = function (target) {
        if (!target) {
            return true;
        }
        if (!this.domNode || typeof target.contains !== 'function' || !this.hasRendered) {
            return false;
        }
        return target.contains(this.domNode);
    };

    mstrmojo.DI.DIHelpers.isdbRoleWritable = function (dbRole) {
        if(mstrmojo.DI.DIHelpers.isOnetier()){
            return true;
        }
        else {
            return dbRole.writable === '1' && mstrApp.rootController.hasPrivilege(constants.DssXmlPrivileges.DssXmlPrivilegesUseDatabaseInstanceManager);
        }
    };

    mstrmojo.DI.DIHelpers.isdbRoleUsable = function (dbRole) {
        return mstrmojo.DI.DIHelpers.isOnetier() ? true : dbRole.usable === '1';
    };

    /**
     * replace placeholder !#DRIVERSUFFIX#! with real platform suffix
     * @param DBInfo this object is returned by arch.getDBObjects
     */
    mstrmojo.DI.DIHelpers.applyDriverSuffix = function (DBInfo) {
        if (!DBInfo || !DBInfo.Preferences) { return ; }

        var jsonStr = JSON.stringify(DBInfo),
            suffixes = DBInfo.Preferences.driverNameSuffix,
            env = this.getEnvObj();

        var key = "Platform";
        //Desktop
        if (env.isDesktopClient()) {
            key = env.isMac() ? "DesktopMac" : "DesktopWin";
        }
        else if(env.isWSClient()) {
            key = env.isMac() ? "WorkstationMac" : "WorkstationWin";
        }

        var suffix = suffixes[$ARR.find(suffixes, 'n', key)];

        return JSON.parse(jsonStr.replace(/!#DRIVERSUFFIX#!/g, suffix ? suffix.value : ''));
    };

    mstrmojo.DI.DIHelpers.isGeo = function (item){
        return item.georole && item.georole > 0;
    };

    mstrmojo.DI.DIHelpers.isTime = function (item){
        return item.dtp === parseInt(dataTypeMenuItems.DATE,10) || item.dtp === parseInt(dataTypeMenuItems.DATE_TIME,10) || item.dtp === parseInt(dataTypeMenuItems.TIME,10);
    };
}());

(function () {

    mstrmojo.requiresCls("mstrmojo.publisher",
                         "mstrmojo.Widget",
                         "mstrmojo.array",
                         "mstrmojo._HasChildren");

    var $ARR = mstrmojo.array;

    /**
     * Disables the supplied children (which aren't already disabled) and caches them for later restoration.
     *
     * @param {Array.<mstrmojo.Widget>} children  The children to disable.
     *
     * @this {mstrmojo.Container}
     */
    function disableChildren(children) {
        // Do we NOT propagate enabled state to children?
        if (!this.shouldPropagateEnabled) {
            // Nothing to do.
            return;
        }

        // Get collection.
        var disabledCollection = this._disabledChildren;

        // Iterate passed children.
        $ARR.forEach(children, function (child) {
            // Is the child enabled?
            if (child.enabled) {
                // Add to collection and disable.
                disabledCollection.push(child.id);
                child.set('enabled', false);
            }
        });
    }

    /**
     * Enables any children that were previously disabled by this container.
     *
     * @this {mstrmojo.Container}
     */
    function enableChildren() {
        // Iterate disabled children.
        $ARR.forEach(this._disabledChildren, function (childId) {
            // Does the child still exist and belong to this container?
            var child = mstrmojo.all[childId];
            if (child && child.parent === this) {
                // Enable child.
                child.set('enabled', true);
            }
        }, this);

        // Clear cache.
        this._disabledChildren = [];
    }

    /**
     * <p>Base widget container class.</p>
     *
     * <p>Container is a widget that contains other "child" widgets. Typically used to arrange other widgets
     * visually in a GUI.</p>
     *
     * @class
     * @extends mstrmojo.Widget
     * @mixes mstrmojo._HasChildren
     */
    mstrmojo.Container = mstrmojo.declare(
        mstrmojo.Widget,

        [ mstrmojo._HasChildren ],

        /**
         * @lends mstrmojo.Container.prototype
         */
        {
            scriptClass: "mstrmojo.Container",

            /**
             * <p>The default slot name under which children should be placed.</p>
             *
             * <p>Typically each child has a "slot" (String) property which indicates which "slot node" that child's DOM should
             * be appended to. If the child's "slot" property is undefined, we assume this default instead.</p>
             */
            defaultChildSlot: "containerNode",

            /**
             * The default {@link HTMLElement} that will hold child DOM nodes.
             *
             * @type {HTMLElement}
             */
            containerNode: null,

            /**
             * <p>If true, the domNodes of the Container's children will be inserted into their
             * corresponding slot nodes in the same order in which the children are listed in the "children" array
             * property.</p>
             *
             * <p>Otherwise, the domNodes are appended to their corresponding slot nodes in whatever
             * order they happen to be rendered; by default, that order is the same sequence as the "children" array,
             * but in general, other subclasses can modify that order if desired (for example, an "on-demand" rendering mixin).</p>
             *
             * @type {boolean}
             */
            preserveChildDomOrder: true,

            /**
             * <p>True if the children of this container should become disabled when the container is disabled.</p>
             *
             * <p>Subclasses that want to use this need to include {@link mstrmojo.Container.enabledMarkupMethod}.</p>
             *
             * @type {boolean}
             * @default false
             */
            shouldPropagateEnabled: false,

            /**
             * <p>Base widget container class.</p>
             *
             * <p>Overwrites the inherited constructor {@link mstrmojo.Widget#init} in order to initialize child widgets (if any)
             * before initializing this object's bindings.</p>
             *
             * @param {Object=} props Hash of property values to be applied to this instance.
             */
            init: function init(props) {
                this._super(props);

                // Create cache to hold children who have been disabled through inheritance.
                this._disabledChildren = [];

                // Attach event listener to hear when a children is added.
                this.attachEventListener('addChild', this.id, function (evt) {
                    // Should we propagate enabled state AND are we currently disabled?
                    if (this.shouldPropagateEnabled && !this.enabled) {
                        // Disable newly added children.
                        disableChildren.call(this, evt.value);
                    }
                });

                // If we have a "children" config, initialize our children.
                if (this.children) {
                    this.initChildren();
                }

                // If we are an orphan, init our bindings now (if any). Otherwise we have a parent,
                // and that parent is responsible for calling us later to init our bindings, after it
                // has finished constructing its children.
                // Note: If we have no bindings, our children still might, so don't skip initBindings call.
                var parent = this.parent;
                if (!parent || parent.hasInitBindings) {
                    this.initBindings();
                }
            },

            /**
             * <p>Extends the inherited method in order to call destroy on its child objects and its bindings before
             * destroying itself.</p>
             *
             * <p>This method destroys this object's children first before destroying this object's bindings.
             * Typically, children with bindings are bound to properties in their ancestors. Therefore, we wait
             * until after our children are destroyed to destroy our own bindings, thereby reducing the number of
             * binding events raised by our own destruction.</p>
             *
             * <p>This method passes a flag along to its children's "destroy" call which lets the children know
             * that they can skip the DOM cleanup, because it will be handled by this container.</p>
             */
            destroy: function dst(skipCleanup) {
                if (this.children) {
                    this.destroyChildren(true);
                }
                if (this.bindings) {
                    this.destroyBindings();
                }
                this._super(skipCleanup);
            },

            /**
             * <p>Extends the inherited method to unrender all children before un-rendering this container.</p>
             *
             * <p>This container calls the children's "unrender" before performing its own unrender, because
             * the children might assume that their domNode is still in the document when their unrender is called.</p>
             *
             * <p>This method also passes a flag along to its children's "unrender" call which lets the children know
             * that they can skip the DOM cleanup, because it will be handled by a container. This is intended as
             * a performance optimization, so that the children's DOM can be removed from the document in a single batch operation.</p>
             *
             * @param {boolean} [ignoreDom=false] If true we don't need to clear the DOM (meaning it'll be handled by a parent/ancestor).
             */
            unrender: function unrender(ignoreDom) {
                var c = this.children,
                    len = (c && c.length) || 0,
                    i;

                for (i = len - 1; i > -1; i--) {
                    c[i].unrender(true);
                }

                this._super(ignoreDom);
            },

            /**
             * <p>Extends the rendering cycle to trigger the rendering of child widgets, if any.</p>
             *
             * <p>This method triggers the rendering of this container's children after the container's domNode
             * has been rendered but BEFORE the container's "hasRendered" property is set to true.</p>
             */
            postBuildRendering: function postBuildRendering() {
                if (this._super() !== false) {
                    this.renderChildren();
                    // Override the return value to show that we rendered.
                    return true;
                }

                return false;
            },

            /**
             * <p>Asks all children who are ready for rendering to render now.</p>
             *
             * <p>Container's implementation of renderChildren renders
             * all the children immediately who pass the "childRenderCheck" filter.
             * Subclasses of Container can enhance/overwrite this behavior to support alternative rendering modes.
             */
            renderChildren: function renderChildren() {
                var ch = this.children,
                    len = (ch && ch.length) || 0,
                    i;

                for (i = 0; i < len; i++) {
                    var c = ch[i];
                    if (this.childRenderCheck(c)) {
                        c.render();
                    }
                }
            },

            /**
             * <p>Returns true if a given child is ready to be rendered.</p>
             *
             * <p>A child is considered ready if:</p>
             * <ol>
             * <li>the child has not rendered yet, and</li>
             * <li>the child's "slot" property corresponds to a non-null slot in this Container.</li>
             * </ol>
             *
             * <p>The slot check was important because a container may choose to
             * deliberately omit a slot so that certain children won't render.</p>
             *
             * @param {mstrmojo.Widget} c The child widget to be checked.
             *
             * @returns {Boolean} true if the child is ready to be rendered; false otherwise.
             */
            childRenderCheck: function childRenderCheck(c) {
                if (c && !c.hasRendered) {
                    var s = c.slot || this.defaultChildSlot;
                    return !!this[s];
                }
                return false;
            },

            addChildren: function addChildren(c, idx, silent) {
                var arr = this._super(c, idx, silent);
                if (arr) {
                    this.childRenderOnAddCheck(arr);
                }
                return arr;
            },

            /**
             * <p>Extends the inherited method to remove the children's DOM.</p>
             *
             * @inheritDoc
             */
            removeChildren: function removeChildren(c, silent) {
                var c2r = c ? [c] : (this.children || []),
                    len = c2r.length,
                    i;

                // Remove domNode(s) from slot(s).
                for (i = len - 1; i > -1; i--) {
                    var w = c2r[i],
                        dn = w && w.domNode;
                    if (dn) {
                        var s = this[(w.slot || this.defaultChildSlot)];
                        if (dn.parentNode === s) {
                            s.removeChild(dn);
                        }
                    }
                }

                // Call the inherited method to remove children from this.children.
                return this._super(c, silent);
            },

            /**
             * <p>Checks if newly added child should be rendered.</p>

             * <p>Called when children are newly added.  Checks if each child should be rendered, and if so,
             * calls the child's render() method. If the child has already been rendered, attempts to include
             * its rendering within this container's rendering.</p>
             *
             * <p>If this container has not been rendered, this method does nothing.</p>
             *
             * @param {mstrmojo.Widget[]} ch The newly added child widgets to be checked.
             */
            childRenderOnAddCheck: function childRenderOnAddCheck(ch) {
                if (this.hasRendered && ch) {
                    var len = ch.length,
                        i;

                    for (i = 0; i < len; i++) {
                        var c = ch[i];
                        if (this.childRenderCheck(c)) {
                            c.render();
                        } else if (c && c.hasRendered) {
                            this.onchildRenderingChange(c);
                        }
                    }
                }
            },

            /**
             * <p>Inserts a given child widget's DOM into a slot of this container. Once all children are
             * rendered, raises a "childrenRendered" event.</p>
             *
             * <p>The target slot name is determined by the child's "slot" property (if missing,
             * this container's "defaultChildSlot" property value is assumed).</p>
             *
             * <p>If the targeted slot is not defined in the current rendering, the child widget's domNode is
             * simply removed from DOM until future use.
             * If the targeted slot is defined, the child's domNode will be appended to
             * the slot node, unless this Container's "preserveChildDomOrder" property is
             * true; if so, the child's domNode will be inserted at the child index corresponding
             * to the child's order in this container's "children" array.</p>
             *
             * @param {mstrmojo.Widget} child The child whose rendering is to be inserted.
             */
            onchildRenderingChange: function onchildRenderingChange(child) {
                var d = child && child.domNode;
                if (!d) {
                    return;
                }

                // Compare the domNode's parentNode to the slot node it belongs under.
                var defaultChildSlot = this.defaultChildSlot,
                    childSlot = child.slot || defaultChildSlot,
                    slot = this[childSlot],
                    children = this.children;

                if (!slot) {
                    // No slot found. Remove child domNode from DOM.
                    if (d.parentNode) {
                        d.parentNode.removeChild(d);
                    }
                } else {
                    // We have a slot. Is the domNode already inserted into the slotNode?
                    // TO DO: Do we really need this parentNode check? What happens if you try to call node.parentNode.appendChild(node)?
                    if (d.parentNode === slot) {
                        return;
                    }
                    // Insert the domNode; compute the insertion index.
                    if (!this.preserveChildDomOrder) {
                        // Append the domNode, insertion index is irrelevant.
                        slot.appendChild(d);
                    } else {
                        // Compute an insertion position. Find the domNode of the last preceding child in the same slot (if any).
                        var sib,
                            i;

                        for (i = children.length - 1; i >= 0; i--) {
                            var c = children[i];

                            // Is this the rendered child?
                            if (c === child) {
                                // We've found the child so the last sib value is it's sib.
                                break;
                            }

                            // Is this child in the same slot as the rendered child?
                            if (childSlot === (c.slot || defaultChildSlot)) {
                                // Does it have a domNode?
                                var cNode = c.domNode;

                                // Does the parent of the domNode match the slotNode?
                                if (cNode && cNode.parentNode === slot) {
                                    // This is the node of the child that should appear after the rendered child.
                                    sib = cNode;
                                }
                            }
                        }

                        // Do we have a child that should appear after the rendered child?
                        if (sib) {
                            // Yes, then insert the child before that node.
                            slot.insertBefore(d, sib);
                        } else {
                            // No, then append the child to the slot node.
                            slot.appendChild(d);
                        }
                    }
                }

                // Raise a "childrenRendered" if all children are now rendered.
                if (mstrmojo.publisher.hasSubs(this.id, "childrenRendered")) {
                    var childrenLength = children.length,
                        k;

                    // Iterate my children
                    for (k = 0; k < childrenLength; k++) {
                        // Does the domNode NOT exist?  We check for the existence of the domNode rather than the isRendered flag because at this point, the
                        // isRendered flag has not been set yet.
                        if (!children[k].domNode) {
                            // No, then no reason to raise event.
                            return;
                        }
                    }

                    // All children are rendered so raise the event.
                    this.raiseEvent({
                        name: "childrenRendered"
                    });
                }
            },

            /**
             * <p>Propagates the value of the property from a given container to it's children widgets.</p>
             *
             * @param {String} propName The name of the property that needs to be propagated.
             */
            propagateChildProps: function propagateChildProps(propName) {
                var containerProp = this[propName],
                    children = this.children || [],
                    childCount = children.length,
                    i;

                // Iterate children. TODO: Convert to native forEach once we stop supporting older browsers.
                for (i = 0; i < childCount; i++) {
                    // Pass property value from the container to it's child widget.
                    children[i].set(propName, containerProp);
                }
            }
        }
    );

    /**
     * <p>Markup method for container enabled state.</p>
     *
     * <p>Includes code for optionally propagating enabled state to children</p>
     *
     * @static
     */
    mstrmojo.Container.enabledMarkupMethod = function () {
        // Call super.
        mstrmojo.Widget.enabledMarkupMethod.apply(this, arguments);

        // Should we propagate enabled state to children?
        if (this.shouldPropagateEnabled) {
            // Are we enabled?
            if (this.enabled) {
                // Enable our children.
                enableChildren.call(this);
            } else {
                // Disable our children.
                disableChildren.call(this, this.children);
            }
        }
    };
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Widget",
                         "mstrmojo.dom",
                         "mstrmojo.hash",
                         "mstrmojo.css");

    var $DOM = mstrmojo.dom,
        $HASH = mstrmojo.hash,
        $CSS = mstrmojo.css;

    /**
     * <p>A button that can hold an image or text.</p>
     *
     * @class
     * @extends mstrmojo.Widget
     */
    mstrmojo.Button = mstrmojo.declare(
        mstrmojo.Widget,

        null,

        /**
         * @lends mstrmojo.Button.prototype
         */
        {
            scriptClass: 'mstrmojo.Button',

            /**
             * An optional second CSS class that will be added to the domNode "class" attribute.
             * Typically used for setting an icon for the Button.
             *
             * @type {String}
             */
            iconClass: '',

            /**
             * An optional CSS class that will be added to the textNode "class" attribute.
             * Typically used for setting an icon for the Button, especially the Button has iconClass set with other background.
             *
             * @type {String}
             */
            innerIconClass: '',

            /**
             * The tooltip for this button.
             *
             * @type {String}
             */
            title: '',

            /**
             * An optional text to appear in the button.
             *
             * @type {String}
             * @default '&nbsp;'
             */
            text: '&nbsp;',

            /**
             * Whether the button is enabled.
             *
             * @type {boolean}
             */
            enabled: true,

            /**
             * Whether the button is selected.
             *
             * @type {boolean}
             */
            selected: false,

            markupString: '<div id="{@id}" class="mstrmojo-Button {@cssClass} {@iconClass}" title="{@title}" style="{@cssText}" mstrAttach:touchstart,click,mousedown,mouseup>' +
                            '<div class="mstrmojo-Button-text {@innerIconClass}"></div>' +
                          '</div>',

            markupSlots: {
                textNode: function () { return this.domNode.firstChild; }
            },

            markupMethods: {
                onvisibleChange: mstrmojo.Widget.visibleMarkupMethod,

                onenabledChange: function () {
                    $CSS.toggleClass(this.domNode, 'disabled', !this.enabled);
                },

                onselectedChange: function () {
                    $CSS.toggleClass(this.domNode, 'selected', this.selected);
                },

                ontextChange: function () {
                    this.textNode.innerHTML = this.text;
                },

                ontitleChange: function () {
                    this.domNode.title = this.title;
                },

                onwidthChange: mstrmojo.Widget.widthMarkupMethod
            },

            oniconClassChange: function oniconClassChange(evt) {
                var domNode = this.domNode;
                if (this.hasRendered && domNode) {
                    domNode.className = domNode.className.replace(evt.valueWas, '') + ' ' + evt.value;
                }
            },

            /**
             * Called when the button is clicked.
             *
             * @param {mstrmojo._HasMarkup.MSTRDomEventType} evt
             *
             * @abstract
             */
            onclick: mstrmojo.emptyFn,

            ontouchend: function ontouchend(evt) {
                this.onclick(evt);
            }
        }
    );

    /**
     * Helper function to create icon button configuration objects.
     *
     * @param {String} t The tooltip text to display in the button.
     * @param {String} c The css class(es) used to display the button image.
     * @param {Function} fn The function to execute when the button is clicked.
     * @param {Object} [b] An optional collection of bindings for this button.
     * @param {Object} [ps] An option collection of properties to be added to the button config.
     *
     * @returns {Object} The button config.
     *
     * @static
     */
    mstrmojo.Button.newIconButton = function newIconButton(t, c, fn, b, ps) {
        // Create the button config.
        var btn = {
            scriptClass: 'mstrmojo.Button',
            title: t,
            cssClass: c,
            text: '',
            onclick: fn
        };

        // Are there bindings?
        if (b) {
            // Add the bindings.
            btn.bindings = b;
        }

        // copy extra properties
        $HASH.copy(ps, btn);

        return btn;
    };

    /**
     * Private helper function to build app specific button configs.
     *
     * @param {String} t The text to appear in the button.
     * @param {Function=} fn An optional function to execute when the button is clicked.
     * @param {String=} cssClass An optional cssClass to be added to the Button properties.
     * @param {Object=} buttonProps An optional collection of properties to add to the button.
     *
     * @returns {Object} A config object that can be used to build a new {@link mstrmojo.Button} widget.
     *
     * @private
     */
    function newButtonConfigHelper(t, fn, cssClass, buttonProps) {
        var classes = [];

        if (cssClass) {
            classes.push(cssClass);
        }


        var cssClassProp = buttonProps && buttonProps.cssClass;
        // Do the button properties have the cssClass property ?
        if (cssClassProp) {
            classes.push(cssClassProp);

            // Delete the css class so that it does not override the one we want to specify.
            delete buttonProps.cssClass;
        }

        // Create base button config.
        var btn = {
            scriptClass: 'mstrmojo.Button',
            cssClass: classes.join(' '),
            text: t
        };

        // Do we have an onclick function?
        if (fn) {
            btn.onclick = fn;
        }

        // Copy extra properties and return.
        return $HASH.copy(buttonProps, btn);
    }

    /**
     * Helper function to create an interactive text button.
     *
     * @param {string} t The text to appear in the button.
     * @param {Function} [fn] An optional function to execute when the button is clicked.
     * @param {String} [haloColor] The color to use a the active halo
     * @param {Object} [ps] An optional collection of properties to add to the button.
     *
     * @return {Object} The button configuration object.
     *
     * @deprecated See mstrmojo.Button.newWebButton
     */
    mstrmojo.Button.newInteractiveButton = function newInteractiveButton(t, fn, haloColor, ps) {
        // Create base button config.
        var btn = {
            glowClass: "glow"
        };

        // Should the buttons use halo?
        if (haloColor && ($DOM.isFF || $DOM.isWK)) {
            // Add the mousedown and mouseup to apply halo.
            $HASH.copy({
                onmousedown: function onmousedown() {
                    $CSS.applyShadow(this.domNode, 0, 0, 10, haloColor);
                },
                onmouseup: function onmouseup() {
                    $CSS.removeShadow(this.domNode);
                }
            }, btn);
        }

        // Pass the custom CSS class, copy extra properties and return the default button config helper.
        return newButtonConfigHelper(t, fn, 'mstrmojo-InteractiveButton', $HASH.copy(ps, btn));
    };

    /**
     * Helper function to create an interactive text button for use within the MSTR Web application.
     *
     * @param {string} text The text to appear in the button.
     * @param {Function=} fn An optional function to execute when the button is clicked.
     * @param {boolean=} isHotButton True if this is the 'hot' button (highlighted).
     * @param {Object=} buttonProps An optional collection of properties to add to the button.
     *
     * @return {Object} The button configuration object.
     */
    mstrmojo.Button.newWebButton = function newWebButton(text, fn, isHotButton, buttonProps) {
        // Pass the custom CSS class and return the default button config helper.
        return newButtonConfigHelper(text, fn, 'mstrmojo-WebButton' + (isHotButton ? ' hot' : ''), buttonProps);
    };


    /**
     * Helper function to create an action button button for use within the MSTR Web application.
     * Action button is used for any button (say Add, Browse etc..) that is NOT a main button (like OK, Cancel, Save etc..).
     *
     * @param {string} t The text to appear in the button.
     * @param {Function=} fn An optional function to execute when the button is clicked.
     * @param {Object=} buttonProps An optional collection of properties to add to the button.
     *
     * @return {Object} The button configuration object.
     */
    mstrmojo.Button.newActionButton = function (t, fn, buttonProps) {
        var btn = mstrmojo.Button.newWebButton(t, fn, false, buttonProps);

        // add action button css class to set the custom properties
        btn.cssClass = btn.cssClass + ' action-button';

        return btn;
    };
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Widget",
                         "mstrmojo.dom");

    var baseCssClass = 'mstrmojo-Image';

    /**
     * An image class.
     *
     * @class
     * @extends mstrmojo.Widget
     *
     */
    mstrmojo.Image = mstrmojo.declare(

        mstrmojo.Widget,

        null,

        /**
         * @lends mstrmojo.Image
         */
        {
            scriptClass: "mstrmojo.Image",

            markupString: '<div id="{@id}" class="' + baseCssClass + ' {@cssClass}" style="{@cssText}" mstrAttach:click>' +
                              '<image class="{@imgCssClass}" src="{@src}" mstrAttach:load />' +
                          '</div>',


            markupSlots: {
                imgNode: function () { return this.domNode.firstChild; }
            },

            markupMethods: {
                onsrcChange: function () {
                    // Do we have an imgNode?
                    var imgNode = this.imgNode;
                    if (imgNode) {
                        // Set image source.
                        imgNode.src = this.src || '../javascript/mojo/css/images/1ptrans.gif';
                    }
                },
                oncssClassChange: function () {
                    // Do we have a domNode?
                    var domNode = this.domNode;
                    if (domNode) {
                        // Set dom node css class to the cssClass property (or base class if empty).
                        domNode.className = this.cssClass || baseCssClass;
                    }
                },
                onvisibleChange: mstrmojo.Widget.visibleMarkupMethod
            },

            /**
             * The src of the image.
             *
             * @type String
             * @default ""
             */
            src: '',

            /**
             * Returns the inner height and width of the image node.
             *
             * @type Object
             */
            getImageSize: function getImageSize() {
                var imgNode = this.imgNode;
                return {
                    w: imgNode.clientWidth,
                    h: imgNode.clientHeight
                };
            }
        }
    );

    /**
     * The base CSS class applied to the domNode.
     *
     * @static
     * @type String
     */
    mstrmojo.Image.baseCssClass = baseCssClass;

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Widget",
    		"mstrmojo.string");

    var $STR = mstrmojo.string;

    /**
     * A click sensitive label to display text.
     *
     * @class
     * @extends mstrmojo.Widget
     */
    mstrmojo.Label = mstrmojo.declare(

        mstrmojo.Widget,

        null,

        /**
         * @lends mstrmojo.Label.prototype
         */
        {
            scriptClass: "mstrmojo.Label",

            /**
             * Flag indicating whether allowing HTML element in the provided text content.
             *  True - text content will be displayed as is. Set to true only when the text is ensured from a safe source.
             *  False - text content will be html-encoded for security reason.
             * @param {boolean}
             * @default false
             */
            allowHTML: false,

            /**
             * The text (or HTML) to be displayed in the label.
             *
             * @type {string}
             */
            text: '',

            /**
             * The tooltip for this button.
             *
             * @type String
             */
            title: '',

            /**
             * @inheritDoc
             */

            markupString: '<div id="{@id}" class="mstrmojo-Label {@cssClass}" style="{@cssText}" title="{@title} "mstrAttach:click>' +
                          '</div>',

            /**
             * @inheritDoc
             */
            markupMethods: {
                ontitleChange: function () {
                    this.domNode.title = this.title;
                },
                ontextChange: function () {
                    var txt = this.text;

                    // Make sure the text is not empty and is a String object.
                    txt = $STR.isEmpty(txt) ? '' : txt.toString();

                    this.domNode.innerHTML = this.allowHTML ? txt : $STR.encodeHtmlString($STR.decodeHtmlString(txt), true); //set the skip space param to be true to fix 1009484.
                },
                oncssTextChange: mstrmojo.Widget.cssTextMarkupMethod,
                onvisibleChange: mstrmojo.Widget.visibleMarkupMethod,
                onenabledChange: mstrmojo.Widget.enabledMarkupMethod
            },

            /**
             * If this property is true the label will be hidden for empty string, <code>null</code> or <code>undefined</code>.
             *
             * @type {boolean}
             * @default false
             */
            autoHide: false,

            _set_text: function _set_text(n, v) {
                // Should we auto hide?
                if (this.autoHide) {
                    // Set visible status to false for empty string, null or undefined.
                    this.set('visible', (v !== null) && (v !== '') && (v !== undefined));
                }

                // Change text value.
                var was = this.text;
                this.text = v;

                // Return boolean indicating whether the value changed.
                return (was !== v);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._HasLayout");

    /**
     * Common styling that must be applied to column and divider elements.
     *
     * @type {string}
     * @private
     * @static
     */
    var commonStyle = ' style="display:inline-block;vertical-align:middle;"';

    /**
     * A container widget for two column widgets within the properties editor of the HTML5 VI application.
     *
     * @class
     * @extends mstrmojo.Container
     * @mixes mstrmojo._HasLayout
     */
    mstrmojo.ui.editors.controls.TwoColumnContainer = mstrmojo.declare(
        mstrmojo.Container,

        [ mstrmojo._HasLayout ],

        /**
         * @lends mstrmojo.ui.editors.controls.TwoColumnContainer.prototype
         */
        {
            scriptClass: 'mstrmojo.ui.editors.controls.TwoColumnContainer',

            markupString: '<div id="{@id}" class="mstrmojo-vi-TwoColumnProp {@cssClass}" style="{@cssText}">' +
                              '<div class="vi-col1"' + commonStyle + '></div>' +
                              '<div class="divider"' + commonStyle + '></div>' +
                              '<div class="vi-col2"' + commonStyle + '></div>' +
                          '</div>',

            markupSlots: {
                col1Node: function col1Node() { return this.domNode.firstChild; },
                dividerNode: function dividerNode() { return this.domNode.childNodes[1]; },
                col2Node: function col2Node() { return this.domNode.lastChild; }
            },

            markupMethods: {
                onvisibleChange: mstrmojo.Widget.visibleMarkupMethod,
                onenabledChange: mstrmojo.Container.enabledMarkupMethod
            },

            layoutConfig: {
                w: {
                    col1Node: '40%',
                    dividerNode: '5px',
                    col2Node: '60%'
                },
                xt: true
            },

            shouldPropagateEnabled: true,

            /**
             * The width of the first column slot (either percentage or fixed).
             *
             * @type {string}
             * @default "40%"
             */
            col1Width: '40%',

            /**
             * The fixed width of the first divider node (with pixel unit).
             *
             * @type {string}
             * @default "3px"
             */
            dividerWidth: '5px',

            /**
             * The width of the second column slot (either percentage or fixed).
             *
             * @type {string}
             * @default "60%"
             */
            col2Width: '60%',

            init: function init(props) {
                this._super(props);

                // Clone and replace current layout config.
                var layoutConfig = this.layoutConfig = JSON.parse(JSON.stringify(this.layoutConfig)),
                    lcWidth = layoutConfig.w;

                // Update width values from instance properties.
                lcWidth.col1Node = this.col1Width;
                lcWidth.dividerNode = this.dividerWidth;
                lcWidth.col2Node = this.col2Width;
            },

            /**
             * Returns the child at the given container column index.
             *
             * @param {int} index The column index of the requested child control.
             *
             * @returns {mstrmojo.Widget}
             */
            getControl: function getControl(index) {
                // Filter children.
                return (this.children || []).filter(function (child) {
                    // Return child at the indicated slot.
                    return child.slot === 'col' + index + 'Node';
                })[0];
            }
        }
    );
}());
(function(){

	mstrmojo.requiresCls(
			'mstrmojo.css',
			'mstrmojo.Container');


	/**
	 * The prefix to use when designating new slots.
	 *
	 * @const
	 * @private
	 * @ignore
	 */
	var PREFIX = "slot";

	/**
	 * A container for laying children out in a single horizontal row.
	 * @class
	 *
	 * @extends mstrmojo.Container
	 */
	mstrmojo.HBox = mstrmojo.declare(
		// superclass
		mstrmojo.Container,

		// mixins,
		null,

		/**
		 * @lends mstrmojo.HBox.prototype
		 */
		{
			scriptClass: "mstrmojo.HBox",

			cellCssClass: "",

			cellSpacing: 0,

			cellPadding: 0,

			markupString: '<table id="{@id}" class="mstrmojo-HBox {@cssClass}" style="{@cssText}" cellspacing="{@cellSpacing}" cellpadding="{@cellPadding}">{@colHTML}<tr>{@tableHtml}</tr></table>',

			colHTML: '',

			markupSlots: {
				containerNode: function() { return this.domNode.rows[0]; }
			},

			markupMethods: {
				onvisibleChange: function() { this.domNode.style.display = this.visible ? mstrmojo.css.DISPLAY_TABLE : 'none'; }
			},

			/**
			 * Extends the rendering cycle by populating the tableHtml property with an HTML markup
			 * string that contains a table cell for each child present at render-time.  Each child is
			 * assigned a table cell as its slot.
			 */
			buildRendering: function bldRn() {
				// Build the tableHtml string property.
				this.tableHtml = '';
				var t = [],
					ch = this.children,
					len = (ch && ch.length) || 0,
					i;

				if (len) {
					var counter = 0,
						css = this.cellCssClass ?
								' class="mstrmojo-HBox-cell ' + this.cellCssClass + '" ' :
								'',
						tdHtml = '<td ' + css + '></td>';
					for (i=0; i<len; i++) {
						t[counter++] = tdHtml;
						ch[i].slot = PREFIX+i;
					}
					this.tableHtml = t.join('');
				}

				// Call the inherited method to do the DOM construction.
				this._super();

				// Add the newly generated cells as slots.  This must be done
				// before renderChildren() is called in postBuildRendering, so that
				// the slots are ready to receive the children's DOM nodes.
				if (len) {
					var slots = {},
						tds = this.containerNode.cells;
					for (i=0; i<len; i++) {
						slots["slot"+i] = tds[i];
					}
					this.addSlots(slots);
				}
			},

			addChildren: function addChild(widget, idx, silent) {
				if (!widget) {
					return widget;
				}

				// Calculate the index (if not supplied).
				if (idx === undefined || isNaN(idx) || idx < 0) {
				    var ch = this.children;
					idx = (ch && ch.length) || 0;
				}

				var i = 0,
				    cnt;

				// If an array of children we need to iterate...
				if (widget.constructor === Array) {
					for (i = 0, cnt = widget.length; i < cnt; i++) {
						widget[i].slot = PREFIX + (idx + i);
					}
				} else {
					// Otherwise, just do it once.
					widget.slot = PREFIX + idx;
				}

				// Add the child widget(s).
				return this._super(widget, idx, silent);
			},

			/**
			 * Overwrites the inherited childRenderCheck from Container to support
			 * rendering children whose slot = "slot<#>" even if no such slot is defined yet.
			 * For such children, the slot will be created dynamically on-demand.
			 */
			childRenderCheck: function childRndrChk(/*Object*/ child) {
				if (child && !child.hasRendered) {
					var slotName = child.slot || this.defaultChildSlot;
					return !!this[slotName] || slotName.match(/^slot[\d]+$/);
				}
				return false;
			},

			onchildRenderingChange: function chRnChg(/*Event|Widget*/ obj) {
				var child = (obj && obj.src) || obj,
					d = child && child.domNode;

				if (d) {
					// What is the slot name of the child?
					var s = child.slot;
					// Do we have a slot node to match that name?
					if (!this[s]) {
						// No. We may need to build it on-the-fly.
						// Does the slot name have this syntax: "slot<#>"?
						var match = s && s.match(/^slot([\d]+)$/);
						if (match) {
							// The # is an index for a cell. Build the cell as a new slot (which
							// in turn requires building cells/slots for all preceeding indices too).
							var idx = parseInt(match[1], 10),
								cn = this.containerNode,
								cells = cn.cells,
								cLen = (cells&&cells.length) || 0,
								slots = {};
							for (var i = cLen; i <= idx; i++) {
								var td = cn.insertCell(i);
								slots["slot"+i] = td;
								if (this.cellCssClass) {
									td.className = this.cellCssClass;
								}
							}
							this.addSlots(slots);
						}
					}
				}

				// Call the inherited method to actually insert the child DOM into slot.
				this._super(obj);
			}

		}
	);

})();
(function () {

    mstrmojo.requiresCls("mstrmojo.Container");

    var $WIDGET = mstrmojo.Widget;

    /**
     * A generic container with minimal markup.
     *
     * @class
     * @extends mstrmojo.Container
     */
    mstrmojo.Box = mstrmojo.declare(

        mstrmojo.Container,

        null,

        /**
         * @lends mstrmojo.Box.prototype
         */
        {
            scriptClass: "mstrmojo.Box",

            markupString: '<div id="{@id}" class="mstrmojo-Box {@cssClass}" style="{@cssText}"></div>',

            markupSlots: {
                containerNode: function () { return this.domNode; }
            },

            markupMethods: {
                onvisibleChange: $WIDGET.visibleMarkupMethod,
                onheightChange: $WIDGET.heightMarkupMethod,
                onwidthChange: $WIDGET.widthMarkupMethod
            }
        }
    );

}());
(function () {

    mstrmojo.requiresCls(
                         "mstrmojo.Container",
                         "mstrmojo.Widget",
                         "mstrmojo.css",
                         "mstrmojo.dom");

    var $CSS = mstrmojo.css,
        $DOM = mstrmojo.dom;

    var KEY_CODE_NAME = {
        9: 'Tab',
        13: 'Enter',
        27: 'Esc',
        38: 'ArrowUp',
        40: 'ArrowDown'
    };

    /**
     * Applies emptyText and emptyClass properties to a given widget.
     * Typically called whenever the widget receives focus or gets its "value" property updated to a non-empty value.
     * @private
     */
    function hideEmpty() {
        var value = this.value,
            inputNode = this.inputNode,
            inputNodeValue = inputNode.value,
            resolvedValue = (value !== null && value !== undefined) ? String(value) : '';

        // Has the value changed and do we not want to keep the empty text ? Or if we want to keep the empty text but the value is different from the empty text.
        if (resolvedValue !== inputNodeValue && (!this.keepEmpty || inputNodeValue !== this.emptyText)) {
            inputNode.value = resolvedValue;
        }

        // Does the input node have a custom empty flag ?
        if (inputNode.mstrmojoEmpty) {
            // Remove the empty CSS class on the input node.
            $CSS.removeClass(inputNode, [ this.emptyClass ]);

            // Delete the mstrmojoEmpty flag.
            inputNode.mstrmojoEmpty = null;
        }
    }

    /**
     * Applies emptyText and emptyClass properties to a given widget.
     * Typically called whenever the widget loses focus or gets its "value" property updated to a non-empty value.
     *
     * @private
     */
    function showEmpty() {
        var inputNode = this.inputNode;

        inputNode.value = this.emptyText || '';

        // Add the empty CSS class on the input node.
        $CSS.addClass(inputNode, [this.emptyClass]);

        // Set a flag on it to denote it's empty.
        inputNode.mstrmojoEmpty = true;
    }

    /**
     * Sets the value of the given TextBox widget to match the current value in its inputNode.
     * Typically called from DOM after end-user types into inputNode.
     *
     * @private
     */
    function dom2value() {
        var inputNode = this.inputNode;
        if (inputNode) {
            this.readingDom = true; // Lets event handlers know that this event was triggered by DOM.
            this.set("value", inputNode.value);
            this.readingDom = false;
        }
    }

    /**
     * Delay for a time to sets the value of the given TextBox to match the current value in its inputNode.
     *
     * @private
     * @memberOf {mstrmojo.TextBox}
     */
    function delaySetValue(delay) {
        var textBox = this;

        if (delay === -1) {
            dom2value.call(this);
        } else {
            // If we have any lingering timeouts - clear them
            if (this._lastTimeoutId) {
                window.clearTimeout(this._lastTimeoutId);
            }

            this._lastTimeoutId = window.setTimeout(function () {
                // Delete the last time out id.
                delete textBox._lastTimeoutId;

                // Update the value.
                dom2value.call(textBox);
            }, delay || 100);
        }
    }

    /**
     * A simple text box control.
     *
     * @class
     * @extends mstrmojo.Container
     */
    mstrmojo.TextBox = mstrmojo.declare(
        mstrmojo.Container,

        null,

        /**
         * @lends mstrmojo.TextBox.prototype
         */
        {
            scriptClass: 'mstrmojo.TextBox',

            /**
             * The value to appear in the text box.
             *
             * @type String
             * @default ''
             */
            value: '',

            /**
             * The type of the input tag.
             *
             * @type String
             * @default 'text'
             */
            type: 'text',

            /**
             * String to appear as hint in html 5 text box.
             *
             * @type String
             * @default ''
             */
            hint: '',

            /**
             * Specifies whether the input is readonly or not.
             *
             * @type Boolean
             * @default false
             */
            readOnly: false,

            /**
             * The length of the text box input in characters.
             *
             * @type String
             * @default ''
             */
            size: '',

            /**
             * The maximum allowed number of characters.
             *
             * @type String
             * @default ''
             */
            maxLength: '',

            cssDisplay: 'inline',

            /**
             * The position of the text box input in tabbing order.
             *
             * @type {int}
             */
            tabIndex: '',

            /**
             * <p>Optional text to display when TextBox's value is empty string or null.</p>
             *
             * <p>The text disappears (temporarily) when the end-user gives the TextBox focus, and
             * then reappears when the end-user leaves the TextBox if the TextBox is empty.</p>
             */
            emptyText: '',

            /**
             * <p>Optional property that works along-side the "emptyText" property and keeps the empty property as part
             * of the input node when hiding the emptyText.</p>
             *
             * @type {Boolean}
             * @default false
             */
            keepEmpty: false,

            /**
             * Optional CSS class name to be temporarily appended to TextBox's inputNode whenever
             * emptyText is displayed.
             */
            emptyClass: 'mstrmojo-empty',

            /**
             * <p>Optional delay in ms to denote whether to trigger the value change event on the text box widget
             * after that delay.</p>
             *
             * @type {Number}
             * @defalt -1
             */
            valueChangeDelay: -1,

            /**
             * Denotes whether the text box is in an invalid state.
             *
             * @type {Boolean}
             * @default true
             */
            textValid: true,

            // attributes available on INPUT elements in some browsers (e.g. WebKit)
            autoComplete: true,
            autoCorrect: true,
            autoCapitalize: true,
            spellCheck: true,

            /**
             * Specifies whether the value of input should be html encoded to prevent xss injection
             *
             * @type Boolean
             * @default false
             */

            markupString: '<input id="{@id}" class="mstrmojo-TextBox {@cssClass}"  style="{@cssText}" ' +
                                'title="{@tooltip}" type="{@type}" ' +
                                'value="" size="{@size}" maxlength="{@maxLength}" index="{@tabIndex}"' +
                                'min="{@min}" max="{@max}" placeholder="{@hint}" ' +
                                'mstrAttach:focus,keyup,blur,paste,cut,input,click,keydown,mousedown  tstid="{@tstid}"/>',

            markupSlots: {
                inputNode: function inputNode() {
                    return this.domNode;
                }
            },

            markupMethods: {
                onvisibleChange: mstrmojo.Widget.visibleMarkupMethod,
                onwidthChange: mstrmojo.Widget.widthMarkupMethod,
                onheightChange: mstrmojo.Widget.heightMarkupMethod,
                oncssClassChange: function oncssClassChange() {
                    this.inputNode.className = "mstrmojo-TextBox " + (this.cssClass || '');
                },
                onhintChange: function onhintChange() {
                    this.inputNode.setAttribute('placeholder', this.hint);
                },
                onenabledChange: function onenabledChange() {
                    var inputNode = this.inputNode;
                    inputNode.disabled = !this.enabled;
                    $CSS.toggleClass(inputNode, 'disabled', !this.enabled);
                },
                onvalueChange: function onvalueChange() {
                    // Update the DOM value.
                    var v = this.value,
                    em = (v === undefined) || (v === null) || (v === "");

                    // Toggle the empty styling as needed.
                    if (em) {
                        // If the inputNode has focus currently, dont show the empty value yet.
                        // Wait for the blur handler to do it.
                        if (!this.hasFocus) {
                            showEmpty.call(this);
                        } else {
                            this.inputNode.value = "";
                        }
                    } else {
                        hideEmpty.call(this);
                    }

                    // In IE 9 and older, for 'password' type, change to use default 'text' type to show placeholder text.
                    if ($DOM.isIE9) {
                        this.inputNode.type = em ? 'text' : this.type;
                    }
                },
                ontooltipChange: function ontooltipChange() {
                    this.domNode.title = this.tooltip;
                },
                onreadOnlyChange: function onreadOnlyChange() {
                    this.inputNode.readOnly = this.readOnly;
                },
                ontextValidChange: function ontextValidChange() {
                    // Add/Remove the error class to the dom node.
                    $CSS.toggleClass(this.inputNode, ['err'], !this.textValid);
                }
            },

            postBuildRendering: function postBuildRendering() {
                this._super();

                // set auto correction, etc. attributes on the input element
                var e = this.inputNode;
                e.setAttribute("autocomplete", this.autoComplete ? "on" : "off");
                e.setAttribute("autocorrect", this.autoCorrect ? "on" : "off");
                e.setAttribute("autocapitalize", this.autoCapitalize ? "on" : "off");
                e.setAttribute('spellcheck', this.spellCheck ? "true" : "false");
            },

            focus: function focus() {
                // 951055 for IE8, there will exception if we set the focus on an inputNode that is not visible.
                // We can use offsetParent to tell whether the inputNode is inside a visible HTML node or not.
                if (this.inputNode && this.inputNode.offsetParent) {
                    try {
                        this.inputNode.focus();
                    } catch (ex) {
                    }
                }
            },

            /**
             * Responds to inputNode getting focus by clearing emptyText, if shown.
             */
            prefocus: function prefocus() {
                this.hasFocus = true;
                // Remove the empty styling, if any.
                hideEmpty.call(this);
            },

            blur: function blur() {
                // TQMS 945866: Input Enter in transparency text box should lose the focus. Add blur function
                this.inputNode.blur();
            },

            /**
             * Handler blur events by updating the widget's "value" property to the DOM's input,
             * and then applying emptyText if the widget's "value" property is empty.
             */
            preblur: function preblur() {
                window.setTimeout(function () {
                    // do nothing just a hack for issue #528431
                }, 200);

                this.hasFocus = false;

                dom2value.call(this);

                var value = this.value;

                // Was an empty text defined and is the value empty? OR Was it defined to keep the empty text and is the value referencing the empty text?
                if (((value === null || value === "") && this.emptyText) || (this.keepEmpty && value === this.emptyText)) {
                    // Apply the empty styling.
                    showEmpty.call(this);
                }
            },

            /**
             * Handles key up events for the inputNode.
             */
            prekeyup: function prekeyup(evt) {
                // Do we have an onenter method and did the user hit the enter key?
                var hWin = evt.hWin,
                    e = evt.e || hWin.event;

                // Trigger the dom to value function in a delay.
                delaySetValue.call(this, this.valueChangeDelay);

                var n = KEY_CODE_NAME[e.keyCode];
                if (this['on' + n]) {
                    this['on' + n](evt);
                }
            },

            /**
             * Handles input events for the inputNode.
             *
             * WebKit browser does not update the <input> value at keyup, need this 'input' event to do it.
             */
            preinput: function preinput() {
                // Trigger the dom to value function in a delay.
                delaySetValue.call(this, this.valueChangeDelay);
            },

            /**
             * Handles paste events for the inputNode.
             */
            prepaste: function prepaste() {
                delaySetValue.call(this);
            },

            /**
             * Handles precut events for the inputNode.
             */
            precut: function precut() {
                delaySetValue.call(this);
            },

            /**
             * Puts the TextBox into an error state due to a validation failure.
             *
             * @param {String} [msg] The error message to display.
             */
            setInvalidState: function setInvalidState(msg) {
                // Set the text valid flag.
                this.set('textValid', false);

                // Is there a message to display?
                if (msg) {
                    // Put it in the tooltip.
                    this.domNode.setAttribute('title', msg);
                }
            },

            /**
             * Cleans up the text box inputs value and validation status.
             */
            cleanUp: function cleanUp() {
                // Clear the value.
                this.inputNode.value = '';

                // Set the text valid flag.
                this.set('textValid', true);

                // Reset the tooltip.
                this.domNode.setAttribute('title', this.tooltip);
            }
        }
    );

}());
(function () {
    mstrmojo.requiresCls("mstrmojo.dom",
        "mstrmojo.css",
        "mstrmojo.Container",
        "mstrmojo._IsPopup",
        "mstrmojo.boxmodel",
        "mstrmojo.dom",
        "mstrmojo.ui._HasScroller");

    var $BOX = mstrmojo.boxmodel,
        $DOM = mstrmojo.dom,
        $CSS = mstrmojo.css,
        CSS_TOOLTIP = 'mstrmojo-Tooltip',
        CSS_SCROLL_NODE = 'mstrmojo-scrollNode',
        CURSOR_HEIGHT = 20;

    /**
     * Attaches (or detaches) a listener to hear opener ancestors scroll event.
     *
     * @param {mstrmojo.Widget} opener
     * @param {mstrmojo.Tooltip} tooltip
     * @param {boolean=} isDetach
     */
    function toggleScrollbox(opener, tooltip, isDetach) {
        // Default listener name.
        var fnName = 'connectScrollbox';

        // Are we detaching the listener?
        if (isDetach) {
            // Change name.
            fnName = 'dis' + fnName;
        }

        // Get opener parent and step up ancestor chain.
        var parent = opener && opener.parent;
        while (parent) {
            // Does this ancestor support this method?
            if (parent[fnName]) {
                // Call the method passing the tooltip.
                parent[fnName](tooltip);
            }

            // Get next ancestor.
            parent = parent.parent;
        }
    }

    /**
     * Paints the tooltip UI after a slight delay.
     */
    function delayPaint() {
        // Do we NOT have a delayed paint already scheduled?
        if (!this._paintHandle) {
            var id = this.id,
                fnPaint = function (isInit) {
                    // Is there NO tooltip?
                    var tooltip = mstrmojo.all[id];
                    if (!tooltip) {
                        // Nothing to do.
                        return;
                    }

                    // Clear paint handle.
                    delete tooltip._paintHandle;

                    // Create collection to hold CSS tooltips (start with default).
                    var domNodeCss = [ CSS_TOOLTIP ],
                        cssClass = tooltip.cssClass;

                    // Is there a custom CSS class?
                    if (cssClass) {
                        // Add custom CSS class.
                        domNodeCss.push(cssClass);
                    }

                    // we will use page theme for the tooltip everywhere unless the opener has a custom theme for tooltip
                    var themeClassName = mstrApp.getThemeClassName && mstrApp.getThemeClassName(),
                        opener = tooltip.opener;

                    // if the opener has a specific tooltip theme (ex: root toolbar), use it
                    if(opener && opener.getTooltipThemeClass) {
                        themeClassName = opener.getTooltipThemeClass();
                    }

                    // add css for the tooltip theme
                    domNodeCss.push(themeClassName);

                    // Replace class name of DOM node.
                    tooltip.domNode.className = domNodeCss.join(' ');

                    var tooltipContent = tooltip.content,
                        contentNode = tooltip.contentNode,
                        arrowNode = tooltip.arrowNode;

                    contentNode.className = (CSS_TOOLTIP + '-content ' + CSS_SCROLL_NODE + ' ' + tooltip.contentNodeCssClass);
                    contentNode.style.cssText = tooltip.contentNodeCssText;
                    //For widget tooltip, do not add innerHTML
                    if (!tooltip.hasWidgetContent) {
                        contentNode.innerHTML = tooltipContent;
                    }

                    // Clear the arrowNode inline style.
                    arrowNode.style.cssText = '';

                    // Set visibility based on presence of content.
                    tooltip.domNode.style.visibility = !!tooltipContent ? 'visible' : 'hidden';

                    // Position the tooltip.
                    tooltip.updatePosition();
                    if (!isInit && tooltip.optimizePos) {
                        // TQMS 762074: has multiple tooltips, need to optimize their positions.
                        tooltip.optimizePos();
                    }

                    tooltip.updateScrollbars();

                };

            // #937665: when show warning tooltip there is some position computations based on the tooltip size, thus
            // we have to show it right now for the first time so we can get the correct tooltip size information.
            if (!this._hasPaint) {
                fnPaint(true);
                this._hasPaint = true;
            } else {
                this._paintHandle = window.setTimeout(fnPaint, 0);
            }
        }
    }

    /**
     * Updates current tooltip properties based on opener's properties.
     *
     * @param {mstrmojo.Tooltip} tooltip
     * @param {mstrmojo.Widget} opener
     * @param {Event=} e
     * @param {window=} win
     */
    function updateTooltipProperties(tooltip, opener, e, win) {
        // Get tooltip reference and mouse position.
        var reference = opener && (opener.richTooltip || opener.tooltip),
            mousePosition = e ? $DOM.getMousePosition(e, win || self) : null,
            isString = reference && (typeof reference === 'string');

        // Initialize default property value (assuming reference is a string).
        var cnCssCls = '',
            cssClass = '',
            cnCssTxt = '',
            content = reference,
            refNode = null,
            positionType = mstrmojo.tooltip.POS_TOPLEFT,
            left = null,
            top = null,
            updatePosition = null,
            hasWidgetContent = false,
            children = null,
            tooltipCloseDelay = mstrmojo._HasTooltip.TOOLTIP_CLOSE_DELAY;

        var keepArrowXPos = false,
            keepArrowYPos = false;

        // Do we have a reference AND is the reference NOT a string?
        if (reference && !isString) {
            // Reset property values to reference values (or current if not in reference).
            cssClass = reference.cssClass || cssClass;
            cnCssCls = reference.contentNodeCssClass || cnCssCls;
            cnCssTxt = reference.contentNodeCssText || cnCssTxt;
            content = reference.content || '';                  // Not sure why, but doesn't use default value if no reference content.
            refNode = reference.refNode || refNode;
            positionType = reference.posType || positionType;
            left = reference.left || 0;
            top = reference.top || 0;
            keepArrowXPos = reference.keepArrowXPos || keepArrowXPos;
            keepArrowYPos = reference.keepArrowYPos || keepArrowYPos;
            updatePosition = reference.updatePosition || null;
            hasWidgetContent = reference.hasWidgetContent;
            children = reference.children;
            tooltipCloseDelay = reference.tooltipCloseDelay || mstrmojo._HasTooltip.TOOLTIP_CLOSE_DELAY;
        }

        // Set properties on tooltip.
        tooltip.set('contentNodeCssClass', cnCssCls);
        tooltip.set('cssClass', cssClass);
        tooltip.set('contentNodeCssText', cnCssTxt);
        tooltip.set('content', content);
        tooltip.set('refNode', refNode);
        tooltip.set('posType', positionType);
        tooltip.set('left', isString ? ((mousePosition && mousePosition.x) || tooltip.left) : left);
        tooltip.set('top', (isString || !reference) ? ((mousePosition && (mousePosition.y + CURSOR_HEIGHT)) || tooltip.top) : top);        // vertical offset is cursor position + cursor height (20px)
        tooltip.set('keepArrowXPos', keepArrowXPos);
        tooltip.set('keepArrowYPos', keepArrowYPos);
        //US70225;overwrite updatePosition for visualization editor unit tooltip
        if (updatePosition) {
            //If opener has cusmized updateposition, use it
            tooltip.set('updatePosition', updatePosition);
        } else {
            tooltip.set('updatePosition', mstrmojo.Tooltip.prototype.updatePosition);
        }
        tooltip.set('hasWidgetContent', hasWidgetContent);
        tooltip.set('children', children);
        tooltip.set('tooltipCloseDelay', tooltipCloseDelay);
    }

    /**
     * This is the tooltip popup to show customized tooltip.
     *
     * @class
     * @extends mstrmojo.Container
     * @mixes mstrmojo._IsPopup
     */
    mstrmojo.Tooltip = mstrmojo.declare(
        mstrmojo.Container,

        [ mstrmojo._IsPopup, mstrmojo.ui._HasScroller ],

        /**
         * @lends mstrmojo.Tooltip.prototype
         */
        {
            scriptClass: 'mstrmojo.Tooltip',

            /**
             * Tooltip content
             */
            content: null,

            /**
             * Top position of the tooltip.
             *
             * The final position of the tooltip is decided by (top,left) x refNode x posType.
             */
            top: null,

            /**
             * Left position of the tooltip.
             *
             * The final position of the tooltip is decided by (top,left) x refNode x posType.
             */
            left: null,

            /**
             * The reference node for top/left. If refNode is null, then left/top is corresponding to window.
             */
            refNode: null,

            // The reason we set two properties to controll arrow position is that we do not know when under which axis the arrow should be kept.
            // This should be told by users.

            /**
             * Keep the arrow x position when the reposition is triggered to avoid tooltip beyond browser.
             */
            keepArrowXPos: false,

            /**
             * Keep the arrow y position when the reposition is triggered to avoid tooltip beyond browser.
             */
            keepArrowYPos: false,

            /**
             * The corner of the tooltip is positioned.
             * mstrmojo.tooltip.POS_TOPLEFT: the top left corner of the tooltip would be positioned according to the offset (top, left) of refNode.
             *                     (top,left)
             *                         o-----------
             *                      |  tooltip |
             *                      ------------
             *                        --------------------
             *                        |                  |
             *                        |    RefNode       |
             *                        --------------------
             * mstrmojo.tooltip.POS_BOTTOMLEFT: the bottom left corner of the tooltip would be positioned according to the offset (top, left) of refNode.
             *                         ------------
             *                      |  tooltip |
             *                      o-----------
             *                  (top,left)
             *
             *
             *                        --------------------
             *                        |                  |
             *                        |    RefNode       |
             *                        --------------------
             * mstrmojo.tooltip.POS_TOPRIGHT: the top right corner of the tooltip would be positioned according to the offset (top, left) of refNode.
             *                     (top,left)
             *              -----------o
             *           |  tooltip |
             *           ------------
             *                        --------------------
             *                        |                  |
             *                        |    RefNode       |
             *                        --------------------
             * mstrmojo.tooltip.POS_BOTTOMRIGHT: the bottom right corner of the tooltip would be positioned according to the offset (top, left) of refNode.
             *           ------------
             *           |  tooltip |
             *              -----------o
             *                     (top,left)
             *
             *
             *                        --------------------
             *                        |                  |
             *                        |    RefNode       |
             *                        --------------------
             * Default value is mstrmojo.tooltip.POS_TOPLEFT.
             *
             */
            posType: "TL",

            /**
             * If true, we bypass the singleton nature of ttpInst, allowing for multiple tooltips
             * This is useful for layered objects (such as a FilterBox) with interactive tooltips
             */
            allowOtherTooltips: false,

            markupString: '<div id="{@id}" class="' + CSS_TOOLTIP + ' {@cssClass}" style="{@cssText}" mstrAttach:mouseover,mouseout>' +
                              '<div class="' + CSS_TOOLTIP + '-shadow {@shadowNodeCssClass}"></div>' +
                              '<div class="' + CSS_TOOLTIP + '-contentWrapper">' +
                                  '<div class="' + CSS_TOOLTIP + '-content ' + CSS_SCROLL_NODE + ' {@contentNodeCssClass}" style="{@contentNodeCssText}"></div>' +
                              '</div>' +
                              '<div class="' + CSS_TOOLTIP + '-arrow"></div>' +
                          '</div>',

            markupSlots: {
                containerNode: function () {
                    return this.domNode.children[1];
                },
                contentNode: function () {
                    return this.domNode.children[1].firstChild;
                },
                shadowNode: function () {
                    return this.domNode.firstChild;
                },
                arrowNode: function () {
                    return this.domNode.children[2];
                }
            },

            setupScrollNodes: function setupScrollNodes() {
                this.scrollNode =  this.contentNode;
                this.scrollbarHostNode = this.containerNode;
            },

            /***
             * Use to remember the previous visible value. Because markupMethods.onvisibleChange do not know whether the value is really changed.
             */
            _previousVisible: false,

            markupMethods: {
                onvisibleChange: function () {
                    var domNodeStyle = this.domNode.style,
                        isVisible = !!this.visible;

                    if (this._previousVisible !== isVisible) {
                        // Set visible to hide and display based on visible property.
                        domNodeStyle.visibility = 'hidden';
                    }
                    domNodeStyle.display = isVisible ? 'block' : 'none';

                    this._previousVisible = isVisible;

                    // Should the tooltip be visible?
                    if (isVisible) {
                        // Update the position.
                        this.updatePosition();

                        // Do we have content?
                        if (this.content) {
                            // Show positioned content.
                            delayPaint.call(this);
                        }
                    }
                },

                onleftChange: delayPaint,
                ontopChange: delayPaint,
                onrefNodeChange: delayPaint,
                onposTypeChange: delayPaint,
                oncontentNodeCssClassChange: delayPaint,
                oncontentNodeCssTextChange: delayPaint,
                oncontentChange: delayPaint,
                oncssClassChange: delayPaint
            },

            /**
             * If there is no parent node assigned for this tooltip, we need to append it to the document body node.
             *
             * @ignore
             */
            preBuildRendering: function preBuildRendering() {
                // if no slot or placeholder is assigned, create the placeholder under the body node.
                if (!this.slot && !this.placeholder) {
                    this.placeholder = document.body.appendChild(document.createElement('div'));
                }

                return this._super();
            },

            updatePosition: function updatePosition(ignoreVisible) {
                // Is the tooltip NOT visible AND are we NOT ignoring that?
                if (!this.visible && !ignoreVisible) {
                    // Nothing to do.
                    return;
                }

                // update position
                // x and y in event refers to a certain node, we need to calculate the offset corresponding to document
                var ref = this.refNode,
                // if we have reference node, we need to calculate the offset in document
                // if we do not have a reference node, then the left/top are from event,
                // which is in window coordinate, so we need to calculate the scroll offset
                    offset = ref ? $BOX.offset(ref, document.body) : {
                        left: $DOM.getHorizontalScroll(),
                        top: $DOM.getVerticalScroll()
                    },
                    domNodeStyle = this.domNode.style,
                    containerNode = this.containerNode,
                    containerOffsetWidth = containerNode.offsetWidth,
                    containerOffsetHeight = containerNode.offsetHeight,
                    positionType = this.posType,
                    positionRight = positionType.indexOf("R") > -1,
                    positionBottom = positionType.indexOf("B") > -1,

                    top = this.top !== null ? parseInt(this.top, 10) + offset.top - (positionBottom ? containerOffsetHeight : 0) : null,
                    left = this.left !== null ? parseInt(this.left, 10) + offset.left - (positionRight ? containerOffsetWidth : ((positionType.indexOf("C") > -1) ? Math.floor(containerOffsetWidth / 2) : 0)) : null,
                    isLeftOffset = false,
                    isTopOffset = false,
                    newLeft,
                    newTop,

                    // Check body clinetWidth/clientHeight in case the scrollbar shows.
                    // Calc the min left/top to avoid tooltip overflow of the window view point
                    winDim = $DOM.windowDim(),
                    bodyClientWidth = $DOM.getHorizontalScroll() + winDim.w,
                    bodyClientHeight = $DOM.getVerticalScroll() + winDim.h,

                    arrowNode = this.arrowNode,
                    arrowStyle = null;

                if (left !== null) {
                    newLeft = Math.min(Math.max(left, 0), bodyClientWidth - containerOffsetWidth);
                    domNodeStyle.left = newLeft + 'px';
                    isLeftOffset = left !== newLeft;
                }

                if (top !== null) {
                    newTop = Math.min(Math.max(top, 0), bodyClientHeight - containerOffsetHeight);
                    domNodeStyle.top = newTop + 'px';
                    isTopOffset = top !== newTop;
                }

                if (isLeftOffset || isTopOffset) {
                    var arrowStyleLeft,
                        needRepositionLeft = this.keepArrowXPos && isLeftOffset,
                        needRepositionTop = this.keepArrowYPos && isTopOffset;
                    // Performance: only getComputedStyle when we need it.
                    if (needRepositionLeft || needRepositionTop) {
                        arrowStyle = $CSS.getComputedStyle(arrowNode);
                        arrowStyleLeft = arrowStyle.left;
                    }

                    //DE64202;when it of percent, for non-chrome browser, getComputedStyle would return as percent, not 'px', then we would calculate wrong left value.
                    //When it is percent, change it to 'px' left
                    if (arrowStyleLeft && arrowStyleLeft.endsWith('%')) {
                        arrowStyleLeft = parseFloat(arrowStyleLeft) / 100.0 * containerOffsetWidth;
                    }
                    if (needRepositionLeft) {
                        arrowNode.style.left = (parseInt(arrowStyleLeft, 10) + left - newLeft) + 'px';
                    }
                    if (needRepositionTop) {
                        arrowNode.style.top = (parseInt(arrowStyle.top, 10) + top - newTop) + 'px';
                    }
                }

                $CSS.toggleClass(this.domNode, 'offset', isLeftOffset || isTopOffset);
            },

            _on_tooltip_change: function (evt) {
                updateTooltipProperties(this, evt && evt.src);
            },

            /**
             * Custom setter for 'opener' property.
             *
             * Since we are going to share the same tooltip instance with different widget, each time when this tooltip associates with a new widget,
             * we need to perform some cleanup with previous widget and set up some listeners with the new widget.
             *
             * @ignore
             */
            _set_opener: function (n, opener) {
                var currentOpener = this.opener,
                    isOpenerChanged = opener !== currentOpener;

                // if new opener is different from previous opener,
                // 1. we need to attach event listeners for scrolling to the new opener
                // at the same time detach event listeners for scrolling from previous opener
                // 2. we need to listen to any change of opener's richTooltip and tooltip
                if (isOpenerChanged) {
                    if (opener) {
                        toggleScrollbox(opener, this);
                    }

                    if (currentOpener) {
                        toggleScrollbox(opener, this, true);
                    }

                    if (currentOpener && currentOpener.detachEventListener) {
                        currentOpener.detachEventListener(this._richSubs);
                        currentOpener.detachEventListener(this._ttpSubs);
                    }

                    if (opener && opener.attachEventListener) {
                        this._richSubs = opener.attachEventListener('richTooltipChange', this.id, '_on_tooltip_change');
                        this._ttpSubs = opener.attachEventListener('tooltipChange', this.id, '_on_tooltip_change');
                    }

                    this.opener = opener;
                }

                return isOpenerChanged;
            },

            /**
             * Updates config for Popup rendering.
             */
            updatePopupConfig: function (config, opener) {
                updateTooltipProperties(this, opener, config && config.e, config && config.win);
            },

            /**
             * Event handler for scroll event generated from any ancestor of opener.
             * When any ancestor of opener is scrolled, we need to reposition tooltip.
             *
             * @ignore
             */
            onscroll: function onscroll() {
                //421475
                if (this.visible && this.nudge) {
                    this.nudge();
                }
                this._super();
            },

            onmouseover: mstrmojo.emptyFn,
            onmouseout: mstrmojo.emptyFn
        }
    );

    // Single tooltip instance.
    var ttpInst = null;

    /**
     * Singleton for tooltip widget.
     *
     * @static
     */
    mstrmojo.tooltip = {
        /**
         * @type {string}
         */
        POS_TOPLEFT: "TL",

        /**
         * @type {string}
         */
        POS_BOTTOMLEFT: "BL",

        /**
         * @type {string}
         */
        POS_TOPRIGHT: "TR",

        /**
         * @type {string}
         */
        POS_BOTTOMRIGHT: "BR",

        /**
         * @type {string}
         */
        POS_BOTTOMCENTER: "BC",

        /**
         * @type {string}
         */
        POS_TOPCENTER: "TC",

        /**
         * Displays a single tooltip.
         *
         * @param {mstrmojo.Widget} opener
         * @param {Event} e
         * @param {window} win
         * @param {Object=} config
         */
        open: function open(opener, e, win, config) {
            if (opener && opener.hasWidgetContent && ttpInst) {
                //For widgetContent tooltip, destroy previous tooltip, if existing
                ttpInst.destroy();
            }
            // Create a new tooltip object if either we haven't created the object.
            // OR if the tooltip object has been destroyed...
            if (!ttpInst || !mstrmojo.all[ttpInst.id]) {
                ttpInst = new mstrmojo.Tooltip();
            }

            config = config || {};
            config.e = e;
            config.win = win;

            ttpInst.open(opener, config);

            // Set reference to opener
            opener.tooltip = ttpInst;
        },

        /**
         * Hides the previously opened tooltip.
         */
        close: function close() {
            if (ttpInst && !ttpInst.allowOtherTooltips) {
                var opener = ttpInst.opener;
                if (opener) {
                    // Clear reference
                    opener.tooltip = null;
                }
                ttpInst.close();
                if (opener && opener.hasWidgetContent) {
                    //destroy widget content tooltip
                    ttpInst.destroy();
                }
            }
        }
    };
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.Widget",
                         "mstrmojo.ui._HasScroller",
                         "mstrmojo.css",
                        "mstrmojo.DI.DIHelpers");

    var $CSS = mstrmojo.css,
        $STR = mstrmojo.string,
        showDetailsStr = mstrmojo.desc(14058, 'Show Details'),
        hideDetailsStr = mstrmojo.desc(14059, 'Hide Details'),
        $DIHELPER = mstrmojo.DI.DIHelpers,
        contactStr = mstrmojo.desc(14060, "We are sorry for the inconvenience. Please {contact} your administrator for help.").replace('{', '<span class="dyn-link">').replace('}','</span>');

    /**
     * Class to handle the Error dialog content
     *
     * @class
     *
     * @extends mstrmojo.Widget
     */
    mstrmojo.ui.editors.ErrorDialogContent = mstrmojo.declare(
        mstrmojo.Widget,

        [ mstrmojo.ui._HasScroller ],

        /**
         * @lends mstrmojo.ui.editors.ErrorDialogContent.prototype
         */
        {
            scriptClass: 'mstrmojo.ui.editors.ErrorDialogContent',

            markupString: '<div class="mstrmojo-error-content {@cssClass}" mstrAttach:click>' +
                              '<div class="scroll-container">' +
                                  '<div>{@shortDesc}</div>' +
                                  '<div class="contact">' + contactStr + '</div>' +
                                  '<div class="toggle-details-link" >' + showDetailsStr + '</div>' +
                                  '<div class="error-details">{@longDesc}</div>' +
                              '</div>' +
                          '</div>',

            markupSlots: {
                scrollNode: function () {
                    return this.domNode.firstChild;
                },
                contactNode: function () {
                    return this.domNode.firstChild.children[1].getElementsByClassName('dyn-link')[0];
                },
                toggleDetailsNode: function () {
                    return this.domNode.firstChild.children[2];
                },
                errorDetailsNode: function () {
                    return this.domNode.firstChild.children[3];
                }
            },

            markupMethods: {
                onshowDetailsChange: function () {
                    var showDetails = this.showDetails;

                    // update the node text
                    this.toggleDetailsNode.innerHTML = showDetails ? hideDetailsStr : showDetailsStr;

                    // set css to update the arrow and hide/show the details
                    $CSS.toggleClass(this.domNode, "show-details", showDetails);

                    this.updateScrollbars();
                }
            },

            /**
             * Extra cssClass for user to customize error dialogue
             * 
             * @type String
             */
            cssClass: undefined,

            /**
             * Short description of the error
             *
             * @type String
             * @default "An Error has occurred"
             */
            shortDesc: undefined,

            /**
             * Long description of the error
             *
             * @type String
             */
            longDesc: undefined,

            /**
             * Flag to indicate whether to show or hide the details
             *
             * @type boolean
             * @default false
             */
            showDetails: false,

            /**
             * Flag to indicate whether to show toggle bar for details or not
             * if false, then it means we don't wanna show details and toggler to user,
             * which is probably displayError's style.
             * 
             * @type boolean
             * @default true
             */
            showToggle: true,

            /**
             * Flag to indicate whether we show toggler or not.
             * Since we unified all error message dialog, in some cases like,
             * Web and WorkstationDataSet(Server based env)), we need display contact string toward user.
             * Except situations above, we have to hide them.
             * As this widget is not supposed to be aware of the platform it's embedded,
             * we add this flag, let components at upper level to decide whether we should display contact string or not.
             * By default, we show it.
             * 
             * @type boolean
             * @default true
             */
            enableContactStr: true,

            /**
             * Flag to indicate wheter we encode detailed information or not.
             * For security reason, we encode details by default. Hence its default value is false.
             * 
             * @type boolean
             * @default false
             */
            allowHTML: false,

            init: function init(props) {
                this._super(props);

                // Set default short description if not available
                this.shortDesc = this.shortDesc || mstrmojo.desc(14061, 'An error has occurred');
            },

            onclick: function onclick(evt) {
                var target = evt.getTarget(),
                    url,
                    longDesc = this.longDesc;

                if (target === this.contactNode) {
                    // construct the url, do not include body if there is no long description
                    url = 'mailto:?subject=' + encodeURI('Issue: ' + this.shortDesc) + (longDesc ? ('&body=' + encodeURI('Detail:\r\n' + longDesc)) : '');

                    // open the url
                    mstrApp.openPage(url, '_self');

                } else if (target === this.toggleDetailsNode) {
                    // toggle show details
                    this.set('showDetails', !this.showDetails);
                    this.parent.raiseEvent({
                        name: "EditorResized"
                    });
                    this.parent.positionDialog();
                }
            },

            setupScrollNodes: function setupScrollNodes() {
                this.scrollNode = this.scrollNode;
            },

            preBuildRendering: function preBuildRendering() {
                this._super && this._super();
                //DE97705;encode longDesc before domNode is generated
                if (!this.allowHTML) {
                    //DE106846;decode string before encoding, in case string has been passed as encoded
                    this.longDesc = $STR.encodeHtmlString($STR.decodeHtmlString(this.longDesc, true), true);
                }
            },

            postBuildRendering: function () {
                var contactNode = this.domNode.firstChild.children[1];
                this._super && this._super();
                !this.showToggle && $CSS.addClass(this.toggleDetailsNode, 'hide');
                !this.enableContactStr && $CSS.addClass(contactNode, 'invisible');
            }
        }
    );
})();
(function () {
    mstrmojo.requiresCls("mstrmojo.locales",
        "mstrmojo.tooltip",
        "mstrmojo.dom",
        "mstrmojo.css",
        "mstrmojo.array",
        "mstrmojo.hash",
        "mstrmojo.string");

    mstrmojo.requiresDescs(11038, 11935, 11936, 11937, 11856, 11938, 13138, 13230, 13260, 14633, 14636);

    var $COPY = mstrmojo.hash.copy,
        $CSS = mstrmojo.css,
        $D = mstrmojo.dom,
        $A = mstrmojo.array,
        $S = mstrmojo.string,

        /**Utility methods**/

        /**
         * <p>Replace the '##' with the 1st value in args array, 2nd with '###', and so on.</p>
         * @private
         * @param str {String} error message string
         * @param args {Array} replacement value array
         * @returns {*}
         */
        replaceSharp = function replaceSharp(str, args) {
            if (!str) {return; }

            var len = args && args.length || 0,
                i;

            for (i = len; i > 0; i--) {
                str = str.replace(new Array(i + 2).join('#'), args[i - 1]);
            }

            return str;
        },

        /***
         * <p>adjust the left and top of the tooltip, refer to refNode, after tooltip's paint.</p>
         *
         * <p>Suppose tooltip's posType is default mstrmojo.tooltip.POS_TOPLEFT</p>
         * @private
         * @context {mstrmojo.Tooltip}
         * @returns {{left: number, top: number}}
         */
        adjustTooltipPos = function adjustTooltipPos(validation) {
            if (!validation) { return; } //Not need to reset position

            var $this = this,
                refPos = $D.position(validation.refNode || $this.refNode),
                tlPos = $D.position($this.domNode),
                position = validation.position || WARNING_POS.RIGHT,
                l = 0,
                t = 0,
                mr = 9 + (validation.margin !== undefined ? validation.margin : 0),
                cssCls = ' ';

            switch (position) {
            case WARNING_POS.TOP:
                t = -tlPos.h - mr;
                cssCls += 't';
                break;
            case WARNING_POS.BOTTOM:
                t = refPos.h + mr;
                cssCls += 'b';
                break;
            case WARNING_POS.LEFT:
                l = -tlPos.w - mr;
                cssCls += 'l';
                break;
            case WARNING_POS.RIGHT:
                l = refPos.w + mr;
                cssCls += 'r';
                break;
            }

            mstrmojo.hash.forEach($COPY(validation, {left: l, top: t, contentNodeCssClass: cssCls, visible: false}), function (k, n) {
                this[n] = k;
            }, this);

            this.set('visible', validation.invalid);
        },

        /**Private methods**/

        /**<p>Get warning message in dictionary</p>
         * If validation donot contain error code, will show last content.
         * @private
         * @param validation {{errorCode: number, args: Array}}
         * @returns {String}
         */
        parseWarningContent = function parseWarningContent(validation) {
            var $this = this,//Context should be the widget
                _result,
                code = validation.errorCode,
                msg = validation.errorMsg,
                args = validation.args,
                dict = mstrmojo.vi.ui.rw.selectors.EnumWarningMessages;

            if (validation.invalid) {
                _result = {
                    content: code !== null ? ($this.generateContentHTML(replaceSharp(dict[code], args)) || dict['*']) : msg
                };
            }

            return _result;
        };

    /**
     * <p>Warning message dictionary</p>
     * <p>Please add all warning message here.</p>
     * <p>Include old dictionary in mstrmojo.locales</p>
     * @type {{0: String}}
     */
    mstrmojo.vi.ui.rw.selectors.EnumWarningMessages = $COPY(mstrmojo.locales.validation, {
        '*': mstrmojo.desc(11038, 'Invalid'),
        'invalidValueVIWarning': mstrmojo.desc(11935, "Invalid characters"),
        'emptyValueVIWarning': mstrmojo.desc(11936, "Please enter a number"),
        'notIntegerVIWarning': mstrmojo.desc(11937, "Please enter an integer"),
        'outOfRangeVIWarning': mstrmojo.desc(11856, "Please enter value between ## and ###."),
        'noMultiSelectionVIWaring': mstrmojo.desc(11938, 'This selector does not support multiple selections.'),
        'continuousSelectionVIWaring': mstrmojo.desc(13138, 'This selector does not support non-continuous selections.'),
        'bigDecimalMetricSliderVIWaring': mstrmojo.desc(13230, 'Cannot qualify on big decimal value. Please change qualification type to Rank'),
        'unableDisplaySelectionVIWarning': mstrmojo.desc(13260, 'Filter cannot display actual selections.'),
        'imageSizeExceedLimitVIWarning': mstrmojo.desc(14633, 'Cannot embed an image larger than ##MB. Your image is still ###MB after compression. Enter a URL to the image instead.'),
        'imageFileTypeNotSupportedVIWarning': mstrmojo.desc(14636, 'Invalid image format. Please use .png, .jpg, .jpeg, .gif or .bmp.'),
        'imageOverSizeNoCompessionVIWarning': mstrmojo.desc(14665, 'Cannot embed an image larger than ##MB. Enter a URL to the image instead.')
    });

    /***
     * <p>Enumeration of the position to put warning message
     * @type {{TOP: number, BOTTOM: number, LEFT: number, RIGHT: number}}
     */
    mstrmojo.vi.ui.rw.selectors.EnumWarningPosition = {
        TOP: 1,
        BOTTOM: 2,
        LEFT: 3,
        RIGHT: 4
    };

    var WARNING_POS = mstrmojo.vi.ui.rw.selectors.EnumWarningPosition;

    /**
     * <p>A mixin to add warning message tooltip functionality to filter selector within the HTML5 VI application.</p>
     *
     * <p>Include this mixin in the container where you want its children to share same warning tooltip,
     *  and bindWarningHandler(child) to the child which can raise validationChange event.</p>
     * <p>In container</p>
     *   this.bindWarningHandler(some child widget);
     * <p>In child, the warning message will show on top of its domNode.</p>
     *   this.set('validation', {
     *       refNode: this.domNode,
     *       position: 1,
     *       invalid: true,
     *       errorCode: 0,
     *       errorMsg: '',
     *       args: [1, 50]
     *       });
     *
     * @mixin
     * @public
     */
    mstrmojo.vi.ui.rw.selectors._HasWarningMessage = mstrmojo.provide(

        'mstrmojo.vi.ui.rw.selectors._HasWarningMessage',

        /**
         * @lends mstrmojo.vi.ui.rw.selectors._HasWarningMessage
         */
        {
            _mixinName: 'mstrmojo.vi.ui.rw.selectors._HasWarningMessage',

            /**
             * The warning message slot name in the host.
             * @type {String}
             */
            warningSlotName: 'warning',

            /**
             * <p>Show warning tooltip</p>
             * validation:
             * {{
             *  invalid: {boolean} Show warning message or not,
             *  errorCode: number/String Key in {@link mstrmojo.vi.ui.rw.selectors.EnumWarningMessages}. If this is not null, ignore errorMsg.,
             *  errorMsg: {String} warning message content,
             *  args: [] Values array to replace placeholders in error message,
             *  refNode: {domNode} The relative domNode to get position offset of tooltip,
             *  position: {@link mstrmojo.vi.ui.rw.selectors.EnumWarningPosition} Directions of refNode to put tooltip,
             *  lasting: number Tooltip lasting time,
             *  closeOnClick: {boolean} if we close this waring when user click other places in this page, default to be true,
             *  highlight: {boolean} Highlight the refNode,
             *  margin: number Margin between refNode and warning message
             * }}
             * @param validation {Object} If it's empty, show the last warning message.
             */
            showWarning: function showWarning(validation) {

                var $this = this,
                    wSlot = $this.warningSlotName,
                    tooltip = $this[wSlot],
                    lasting = validation && validation.lasting || 6000,
                    refNode = validation.refNode || this.domNode,
                    highlight = validation.highlight !== false,
                    closeOnClick = validation.closeOnClick === false ? false : true,
                    fnCloseOnClick;

                if (!tooltip) {
                    tooltip = new mstrmojo.Tooltip({
                        refNode: refNode,
                        highlight: highlight,
                        closeOnClick: closeOnClick,
                        updatePopupConfig: null,//Delete inherited method
                        cssClass: 'vi-warning vi-tooltip-V'
                    });

                    //Destroy together with opener
                    $this.addDisposable(tooltip);
                    $this[wSlot] = tooltip;

                    //Close on click
                    fnCloseOnClick = $this.closeOnClick = $this.getCloseOnClickListener();
                    $D.attachEvent(document.body, 'click', fnCloseOnClick);
                }
                // change the css class according to the postion
                var position = validation.position || WARNING_POS.TOP,
                    TOOLTIP_CSS_PRE = 'vi-warning vi-tooltip-';

                switch (position) {
                    case WARNING_POS.TOP:
                        tooltip.cssClass  = TOOLTIP_CSS_PRE + 'V';
                        break;
                    case WARNING_POS.BOTTOM:
                        tooltip.cssClass  = TOOLTIP_CSS_PRE + 'A';
                        break;
                    case WARNING_POS.LEFT:
                        tooltip.cssClass  = TOOLTIP_CSS_PRE + 'D';
                        break;
                    case WARNING_POS.RIGHT:
                        tooltip.cssClass  = TOOLTIP_CSS_PRE + 'C';
                        break;
                }

                //Show with content
                tooltip.open($this, parseWarningContent.call($this, validation));
                this.adjustPosition(validation);

                if (highlight) {
                    $CSS.toggleClass(tooltip.refNode, "mstrmojo-Warning", true);
                }

                //Last for 6 second then hide.
                window.clearTimeout($this._warningTimeOut);
                $this._warningTimeOut = window.setTimeout(function () {
                    $this.hideWarning();
                }, lasting);
            },

            /**
             * <p>Hide the warning</p>
             */
            hideWarning: function hideWarning() {
                var $this = this,
                    tooltip = $this[$this.warningSlotName];

                if (tooltip && tooltip.visible && tooltip.close) {

                    if (tooltip.highlight) {
                        $CSS.toggleClass(tooltip.refNode, "mstrmojo-Warning", false);
                    }

                    tooltip.close();

                    window.clearTimeout($this._warningTimeOut);
                    delete $this._warningTimeOut;
                }
            },

            /***
             * <p>Close on click on other part of the whole page</p>
             */
            getCloseOnClickListener: function getCloseOnClickListener() {
                var $this = this;
                return function () {
                    var tooltip = $this[$this.warningSlotName];

                    if (tooltip.closeOnClick) {
                        $this.hideWarning();
                    }
                };
            },

            /**
             * <p> Adjust position after warning messing shows</p>
             */
            adjustPosition: function adjustPosition(validation) {
                var $this = this;
                adjustTooltipPos.call($this[$this.warningSlotName], validation);
            },

            /**
             * <p>Generate HTML content with the error message</p>
             * @param errorMessage
             * @returns {String}
             */
            generateContentHTML: function generateContentHTML(errorMessage) {
                return $S.encodeHtmlString(errorMessage, true);
            },

            /**
             * <p>Bind warning message to some widget, this widget can raise validation event to show warning</p>
             * <p>every parameter will be treated as widget and attach event</p>
             */
            bindWarningHandler: function bindWarningHandler() {

                $A.forEach(arguments, function bindWarningHandlerToEach(widget) {

                    if (!widget || !widget.attachEventListener) { return; }

                    var _validationEventListener = widget._validationEventListener,
                        fnValidate;

                    if (_validationEventListener) {
                        widget.detachEventListener(_validationEventListener);
                        delete widget._validationEventListener;
                    }

                    fnValidate = this.getValidationEvtListener();
                    if (fnValidate) {
                        widget._validationEventListener = widget.attachEventListener('validationChange', this.id, fnValidate);
                    }

                }, this);
            },

            /**
             * Create handler to show the warning, attach to arbitrary event.
             *
             * @returns {Function}
             */
            getValidationEvtListener: function getValidationEvtListener() {
                var $this = this;
                return function validationChangeHandler(evt) {
                    var validation = evt.value;

                    $this[(validation && validation.invalid ? 'show' : 'hide') + 'Warning'](validation);
                };
            },

            /**
             * unrender the warning widget together.
             * @param ignoreDom
             */
            unrender: function unrender(ignoreDom) {
                var tooltip = this[this.warningSlotName];

                if (tooltip) {
                    tooltip.unrender();
                }
                this._super(ignoreDom);
            },

            /**
             * Destroy
             * @param ignoreDOM
             */
            destroy: function destroy(ignoreDOM) {
                $D.detachEvent(document.body, 'click', this.closeOnClick);
                return this._super(ignoreDOM);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
        "mstrmojo.func",
        "mstrmojo.array",
        "mstrmojo.Button",
        "mstrmojo.HBox",
        "mstrmojo.dom",
        "mstrmojo.Box");

    var $D = mstrmojo.dom;

    /**
     * Dialog is a modal dialog that has title bar, a collection of buttons and can contain other controls within it.
     *
     * @class
     * @extends mstrmojo.Container
     */
    mstrmojo.Dialog = mstrmojo.declare(
        mstrmojo.Container,

        null,

        /**
         * @lends mstrmojo.Dialog.prototype
         */
        {
            scriptClass: "mstrmojo.Dialog",

            /**
             * An optional title for the dialog.
             *
             * @type {string}
             */
            title: '',

            /**
             * An optional array of {@link mstrmojo.Button} configuration objects.
             *
             * @type {Array.<Object>}
             */
            buttons: null,

            /**
             * Alignment of the dialog. Default to center. can also be 'top', 'left', 'right', 'bottom'
             *
             * @type {string}
             */
            alignment: 'center',

            /**
             * <p>The alignment of the buttons.</p>
             *
             * <p>Possible values are "left" (default) or "right".</p>
             *
             * @type {string}
             */
            btnAlignment: 'right',

            /**
             * <p>The zIndex used by this popup.</p>
             *
             * <p>In general, if this is a modal popup, the curtain used by this popup would be 1 less than zIndex here.</p>
             *
             * @type {int}
             */
            zIndex: 10,

            /**
             * Indicate whether the editor is modal or not.
             *
             * @type {boolean}
             */
            modal: true,

            markupString: '<div id="{@id}" class="mstrmojo-Dialog {@cssClass}" style="z-index: 1100;" tabindex="0" mstrAttach:click>' +
                              '<div class="win mstrmojo-Editor" style="{@cssText}">' +
                                  '<div class="mstrmojo-Editor-titlebar"><div class="mstrmojo-Editor-title">{@title}</div></div>' +
                                  '<div class="mstrmojo-Editor-content"></div>' +
                                  '<div class="mstrmojo-Editor-buttons"></div>' +
                              '</div>' +
                              '<div class="mstrmojo-Editor-curtain"></div>' +
                              '<div class="mstrmojo-Editor-tip"></div>' +
                          '</div>',

            markupSlots: {
                editorNode: function () {
                    return this.domNode.firstChild;
                },
                curtainNode: function () {
                    return this.domNode.childNodes[1];
                },
                titleNode: function () {
                    return this.domNode.firstChild.firstChild;
                },
                containerNode: function () {
                    return this.domNode.firstChild.childNodes[1];
                },
                buttonNode: function () {
                    return this.domNode.firstChild.lastChild;
                },
                tipNode: function () {
                    return this.domNode.lastChild;
                }
            },

            /**
             * @type {HTMLElement}
             */
            editorNode: null,

            /**
             * The alias for the buttons container box.
             *
             * TODO: NS - Should this be a HBox ?
             *
             * @type {mstrmojo.HBox}
             * @ignore
             */
            btnHbox: null,

            markupMethods: {
                onzIndexChange: function () {
                    this.editorNode.style.zIndex = this.zIndex;
                    this.curtainNode.style.zIndex = this.zIndex - 1;
                },
                onwidthChange: function () {
                    this.editorNode.style.width = this.width || 'auto';
                },
                onvisibleChange: function (init) {
                    if (init) {
                        return;
                    }

                    var v = this.visible,
                        d = v ? 'block' : 'none';

                    this.editorNode.style.display = d;

                    if (this.modal) {
                        this.curtainNode.style.display = d;
                    }
                },
                onleftChange: function () {
                    this.editorNode.style.left = this.left || '';
                },
                ontopChange: function () {
                    this.editorNode.style.top = this.top || '';
                },
                ontitleChange: function () {
                    this.titleNode.firstChild.innerHTML = this.title || '';
                }
            },

            preBuildRendering: function preBuildRendering() {
                var b;

                // Do we have buttons AND do we not already have a button box (TQMS #687264)?
                var buttons = this.buttons;
                if (buttons && !this.btnHbox) {

                    // Add needed base cssClass.
                    for (b in buttons) {
                        buttons[b].cssClass = (buttons[b].cssClass || '') + (this.noButtonCls ? '' : ' mstrmojo-Editor-button');
                    }

                    // An an HBox with the buttons as children.
                    this.addChildren([{
                        scriptClass: 'mstrmojo.HBox',
                        cssText: 'float:' + this.btnAlignment,
                        slot: 'buttonNode',
                        alias: 'btnHbox',
                        children: buttons
                    }, {
                        scriptClass: 'mstrmojo.Label',
                        cssClass: 'mstrmojo-clearMe',
                        slot: 'buttonNode'
                    }
                    ]);
                }

                // Is this a modal editor?
                if (this.modal) {
                    // Add 'modal' css class.
                    this.cssClass += ' modal';
                }

                // Call the super.
                return this._super();
            },

            buildRendering: function buildRendering() {
                // Get a reference to the placeholder (since it will be blown away in the _super).
                var ph = this.placeholder;

                // Call super.
                if (this._super()) {
                    // Do we not have a parent and did we not have a placeholder?
                    if (!this.parent && !ph) {
                        // Insert the domNode as a child of the body tag.
                        document.body.appendChild(this.domNode);
                    }

                    return true;
                }

                return false;
            },

            // #659420  added function that returns method to resize overwritten in android dialog
            getResizeHandler: function getResizeHandler() {
                var id = this.id;
                return function () {
                    var dialog = mstrmojo.all[id];
                    dialog.resizeDialog();
                    dialog.positionDialog();
                };
            },

            postBuildRendering: function postBuildRendering() {
                this._super();

                // Is the dialog model?
                if (this.modal && this.visible) {
                    // Change curtainNode style to block.
                    this.curtainNode.style.display = 'block';
                }

                // Do we NOT have a resize handler yet?
                if (!this._resizeHandler) {
                    // Create handler function.
                    var fn = this._resizeHandler = this.getResizeHandler();

                    // Attach event listener to window object to hear when window size changes.
                    $D.attachEvent(window, 'resize', fn);
                }

                // resize and position dialog.  #659420 do not call resize Handler since it is overwritten in android and will cause an infinite loop.
                this.resizeDialog();
                this.positionDialog();

                //#576707 - take focus to avoid key event being received by document
                try {
                    this.domNode.focus();
                } catch (ex) {} //try-catch added to fix DE10106 and DE10623 for IE8

                return true;
            },

            /**
             * Called during rendering (and after window resizing) to adjust the size of the dialog.
             *
             */
            resizeDialog: function resizeDialog() {
                // Is the dialog modal?
                if (this.modal) {
                    // Resize the curtain.
                    this.resizeCurtain();
                }
            },

            /**
             * Function to resize the curtain when the editor is attached to body.
             */
            resizeCurtain: function resizeCurtain() {
                var w = this,
                    curtainNode = w.curtainNode,
                    body = document.body,
                    docElement = document.documentElement,
                    cs = curtainNode.style,
                    curtainPosition = w.curtainPosition;

                // Set width and height.
                cs.width = Math.max(body.clientWidth, docElement.scrollWidth) + 'px';

                if (curtainPosition && curtainPosition.h) {
                    cs.height = curtainPosition.h + 'px';
                } else {
                    cs.height = Math.max(body.clientHeight, docElement.scrollHeight) + 'px';
                }

                if (curtainPosition && curtainPosition.y) {
                    cs.top = curtainPosition.y + 'px';
                }

                w.raiseEvent({name: 'resizeCurtain'});
            },

            /**
             * Called during rendering (and after window resizing) to position the dialog.
             *
             */
            positionDialog: function positionDialog() {

                // cache top and left
                var editor = this.editorNode,
                    left = this.left,
                    top = this.top;

                // If either left or top are not specified, position to center first
                if (!left || !top) {

                    // Center the editor node within browser.
                    $D.center(editor);

                    // Should the editor be aligned with the top?
                    var style = editor.style;
                    if (this.alignment === 'top') {
                        // Move editor node to top.
                        style.top = '10px';
                    }

                    // Once positioned to center, if left was provided but not top, apply left
                    if (left) {
                        style.left = left;
                    }

                    // Once positioned to center, if top was provided but not left, apply top
                    if (top) {
                        style.top = top;
                    }
                }
            },

            destroy: function (ignoreDom) {
                // Do we have a window resize handler?
                var fn = this._resizeHandler;
                if (fn) {
                    // Detach the handler.
                    $D.detachEvent(window, 'resize', fn);
                }

                this._super(ignoreDom);
            }
        }
    );

    /**
     * A toast message appears at the bottom center of the given container. If no container is given, then it appears relative the entire document
     *
     * @param {String} msg The toast text to display.
     * @param {Number} [duration=3000] The length the toast message should linger.
     * @param {Function=} callback Optional callback function
     * @param {{id: String, cssClass: String, dom: HTMLElement}} toastConfig An Optional config object for the toast message.
     *
     * @static
     */
    mstrmojo.toast = function toast(msg, duration, callback, toastConfig) {

        var id = 'mojoToast9',
            dom,
            time = duration || 3000;

        if (toastConfig && toastConfig.id) {
            id = toastConfig.id + "-" + id;
        }

        //remove previous toast message
        try {
            mstrmojo.all[id].destroy();
        } catch (e) {
        }

        mstrmojo.insert({
            id: id,
            scriptClass: 'mstrmojo.Label',
            cssClass: (toastConfig && toastConfig.cssClass) ? toastConfig.cssClass : 'toastCss',
            text: msg
        }).render();

        dom = mstrmojo.all[id].domNode;

        if (toastConfig && toastConfig.dom) {
            toastConfig.dom.appendChild(dom);
        } else {
            //append it to document
            document.body.appendChild(dom);
            $D.bottomCenter(dom);
        }

        window.setTimeout(function () {
            if (callback) {
                callback();
            }
            try {
				mstrmojo.all[id].destroy();
			}catch(e){
				
			}
        }, time);
    };

    mstrmojo.mask = {
        show: function () {
            var win = mstrmojo.mask.win = mstrmojo.insert({
                scriptClass: 'mstrmojo.Box',
                cssClass: 'fullscreen-mask'
            });
            win.render();
            document.body.appendChild(win.domNode);
        },

        hide: function () {
            mstrmojo.mask.win.destroy();
        }
    };
}());
/**
 * Created by fding on 4/12/2017.
 */
(function () {
    mstrmojo.requiresCls(
        "mstrmojo.array",
        "mstrmojo.Box",
        "mstrmojo.css",
        "mstrmojo.Image",
        "mstrmojo.ui._HasScroller"
    );

    var ARR = mstrmojo.array,
        CSS = mstrmojo.css;

    mstrmojo.vi.ui.CoverPageGallery = mstrmojo.declare(
        mstrmojo.Box,
        [mstrmojo.ui._HasScroller],
        {
            scriptClass: "mstrmojo.vi.ui.CoverPageGallery",

            markupString: '<div id="{@id}" class="mstrmojo-Box mstrmojo-vi-ui-CoverPageGallery {@cssClass}" style="{@cssText}">' +
            '<div style="height: 100%"></div>' +
            '</div>',

            cssText: 'overflow: hidden',
            markupSlots: {
                containerNode: function () {
                    return this.domNode.firstChild;
                }
            },

            imageList: [],

            selectedImgNode: null,

            selectedImgURL: '',

            onselectedImgURLChange: function onselectedImgURLChange() {
                var children = this.children,
                    idx = ARR.find(children, 'src', this.selectedImgURL),
                    childImg = idx > -1 ? children[idx] : null;
                this.changeSelectedImg(childImg);
            },

            changeSelectedImg: function changeSelectedImg(img) {
                if (this.selectedImgNode) {
                    CSS.toggleClass(this.selectedImgNode, 'selected', false);
                }
                CSS.toggleClass(img && img.imgNode || null, 'selected', true);
                this.selectedImgNode = img && img.imgNode || null;
            },

            onimageSelected: mstrmojo.emptyFn,

            onimageListChange: function onImagelistChange() {
                this.removeChildren();
                var me = this;
                var imgList = this.imageList = this.imageList || [],
                    children = [];

                ARR.forEach(imgList, function (img) {
                    children.push({
                        scriptClass: 'mstrmojo.Image',
                        src: img.src,
                        cssDisplay: 'inline-block',
                        imgCssClass: 'coverPageItem',
                        onclick: function () {
                            if (me.selectedImgURL !== this.src) {
                                me.set('selectedImgURL', this.src);
                                me.onimageSelected(this.src);
                            }
                        }
                    });
                });
                this.addChildren(children);
                // update selected image gui
                this.onselectedImgURLChange();
                this.updateScrollbars();
            },

            setupScrollNodes: function setupScrollNodes() {
                this.scrollNode = this.containerNode;
            }
        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.dom",
                         "mstrmojo.css",
                         "mstrmojo.fx",
                         "mstrmojo.Dialog",
                         "mstrmojo.Label",
                         "mstrmojo._IsPopup",
                         "mstrmojo._HasPopup",
                         "mstrmojo._IsMovable",
                         "mstrmojo.ui._HasUITheme",
                         "mstrmojo.Button",
                         "mstrmojo.dom",
                         "mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo.tooltip",
                         "mstrmojo.ui.editors.ErrorDialogContent");

    var $FUNC = mstrmojo.func.composite,
        $DOM = mstrmojo.dom,
        $NWB = mstrmojo.Button.newWebButton,
        $CSS = mstrmojo.css,
        $ALL = mstrmojo.all,
        $HASH = mstrmojo.hash,
        $DIHELPER = mstrmojo.DI.DIHelpers,
        $ARR = mstrmojo.array;

    /**
     * Notifies the application that a modal dialog is opened/closed (only if editor is modal).
     *
     * @param {boolean} isOpen True if the editor is opening, False if closing.
     */
    function notifyAppAboutModality(isOpen) {
        // Is this editor NOT modal?
        if (!this.modal) {
            // Nothing to do.
            return;
        }

        // Do we have an app AND does it have the modal editor change method?
        var app = window.mstrApp;
        if (app && app.modalEditorChange) {
            // Tell application we are opening/closing.
            app.modalEditorChange(this.id, isOpen);
        }
    }

    /**
     * <p>Editor is a dialog that has title bar with title and content area.</p>
     *
     * <p>Users can drag and move the editor through the title bar, which contains other shortcut buttons, such as
     * close, help or menu.</p>
     *
     * <p> Like mstrmojo.Popup, mstrmojo.Editor is also a Popup. However, compared to Popup, Editor is more complicated and offer couple more
     * configurable features. First, an editor can have a title bar(showTitle is used to configured whether or not show a title bar).
     * Secondly, it can be dragged and moved around using title bar. Thirdly, an editor can also be configured to have curtain to avoid end users to interact while
     * it is popup/open, using parameter 'modal'. An editor can also be associated with a help topic and auto-closed.</p>
     *
     * @class
     *
     * @extends mstrmojo.Dialog
     *
     * @mixes mstrmojo._IsPopup
     * @mixes mstrmojo._HasPopup
     * @mixes mstrmojo._IsMovable
     * @mixes mstrmojo.ui._HasUITheme
     */
    mstrmojo.Editor = mstrmojo.declare(

        mstrmojo.Dialog,

        [ mstrmojo._IsPopup, mstrmojo._HasPopup, mstrmojo._IsMovable, mstrmojo.ui._HasUITheme ],

        /**
         * @lends mstrmojo.Editor.prototype
         */
        {
            scriptClass: "mstrmojo.Editor",

            /**
             * An optional title for the editor.
             *
             * @type {string}
             */
            title: '',

            /**
             * Whether or not allow HTML string in title property.
             */
            allowHTMLTitle: false,

            /**
             * The help topic this editor is associated with.
             *
             * @type {string}
             */
            help: '',

            /**
             * Whether or not autoClose this editor when clicking any place other than the editor.
             *
             * @type {boolean}
             */
            autoClose: false,

            /**
             * Whether or not show the title bar.
             *
             * @type {boolean}
             */
            showTitle: true,

            /**
             * Effect used to show the curtain and editor when opening them.
             * Note that this effect shall handle showing of both curtain and editor.
             * In the case of curtain, the modal of editor has to be considered as well.
             */
            openEffect: null,

            themeClassName: 'mojo-theme-light',

            useRichTooltip: true,

            /**
             * Effect used to close the curtain and editor when closing them.
             * Note that this effect shall handle closing of both curtain and editor.
             * In the case of curtain, the modal of editor has to be considered as well.
             */
            closeEffect: null,

            /**
             * DE71506: Considering sometimes we need to do something on editor's resizing, define a callback here.
             * It's encouraged to use raiseEvent({name: "EditorResized"}) to trigger it, or your own listener
             */
            onEditorResized: null,

            markupString: '<div id="{@id}" class="mstrmojo-Editor-wrapper">' +
                            '<div class="mstrmojo-Editor {@cssClass}" style="z-index:{@zIndex};{@cssText}" mstrAttach:mouseup,mousedown,click,contextmenu>' +
                                '{@titlebarHTML}' +
                                '<div class="mstrmojo-Editor-content"></div>' +
                                '<div class="mstrmojo-Editor-buttons"></div>' +
                            '</div>' +
                            '<div class="mstrmojo-Editor-curtain"></div>' +
                          '</div>',

            titleMarkupString: '<div class="mstrmojo-Editor-title-container">' +
                                     '<div class="mstrmojo-Editor-title"></div>' +
                                     '<div class="edt-title-btn mstrmojo-Editor-help" tooltip="' + mstrmojo.desc(1143, "help") + '"></div>' +
                                     '<div class="edt-title-btn mstrmojo-Editor-close" tooltip="' + mstrmojo.desc(2102, "Close") + '"></div>' +
                                  '</div>' +
                                  '<div class="mstrmojo-Editor-titleSpacer"></div>',

            markupSlots: {
                editorNode: function editorNode() {
                    return this.domNode.firstChild;
                },
                titleContainerNode: function titleContainerNode() {
                    return this.domNode.firstChild.firstChild;
                },
                titlebarNode: function titlebarNode() {
                    return this.showTitle ? this.domNode.firstChild.firstChild.firstChild : null;
                },
                titleNode: function titleNode() {
                    return this.showTitle ? this.domNode.firstChild.firstChild.firstChild : null;
                },
                helpNode: function helpNode() {
                    return this.showTitle ? this.domNode.firstChild.firstChild.children[1] : null;
                },
                closeNode: function closeNode() {
                    return this.showTitle ? this.domNode.firstChild.firstChild.lastChild : null;
                },
                containerNode: function containerNode() {
                    return this.domNode.firstChild.childNodes[2];
                },
                buttonNode: function buttonNode() {
                    return this.domNode.firstChild.childNodes[3];
                },
                curtainNode: function curtainNode() {
                    return this.domNode.lastChild;
                }
            },

            markupMethods: {
                ontitleChange: function () {
                    if (this.showTitle) {
                        // Changed this for DE35710 to make sure the title is being encoded.
                        // The root of DE35710 was that the server was passing the error's message
                        // as the error's title if a title was not provided, but it showed that a
                        // XSS vulnerability was present as well.
                        this.titleNode.innerHTML = this.allowHTMLTitle ? this.title : mstrmojo.string.encodeHtmlString(this.title);
                    }
                },

                onzIndexChange: function () {
                    var zIndex = this.zIndex;
                    this.editorNode.style.zIndex = zIndex;
                    this.curtainNode.style.zIndex = zIndex - 1;
                },

                onvisibleChange: function (init) {
                    if (init) {
                        return;
                    }

                    var visible = this.visible,
                        fx = 'closeEffect',
                        DISPLAY_NONE = 'none';

                    if (visible) {
                        fx = 'openEffect';
                        DISPLAY_NONE = 'block';
                    }

                    if (this[fx]) {
                        this.playEffect(fx);

                    } else {
                        this.editorNode.style.display = DISPLAY_NONE;
                        if (this.modal) {
                            this.curtainNode.style.display = DISPLAY_NONE;
                        }
                    }
                },

                onhelpChange: function onhelpChange() {
                    if (this.showTitle) {
                        var strHelp = this.help,
                            helpNode = this.helpNode;

                        if (!strHelp) {
                            helpNode.style.display = 'none';
                        } else {
                            helpNode.style.display = 'block';
                        }
                    }
                },

                onleftChange: function onleftChange() {
                    this.editorNode.style.left = this.left || '';
                },

                ontopChange: function ontopChange() {
                    this.editorNode.style.top = this.top || '';
                }
            },

            open: function open(opener, config) {
                this._super(opener, config);

                notifyAppAboutModality.call(this, true);
            },

            close: function close(config) {
                this._super(config);

                notifyAppAboutModality.call(this, false);
            },

            unrender: function unrender(ignoreDom) {
                this._super(ignoreDom);

                notifyAppAboutModality.call(this, false);
            },

            destroy: function destroy(skipCleanup) {
                this._super(skipCleanup);

                notifyAppAboutModality.call(this, false);
            },

            /**
             * Override to handle showTitle parameter.
             */
            preBuildRendering: function preBuildRendering() {
                if (!this.slot && !this.placeholder) {
                    this.placeholder = document.body.appendChild(document.createElement('div'));
                    this._curtain_to_body = true;

                    // Editor is rendering directly into body (bypassing open method) so notify app now.
                    notifyAppAboutModality.call(this, true);
                }

                // Based on editor's showTitle property, we either have the title markup string or placeholder DIVs.
                this.titlebarHTML = (this.showTitle) ? this.titleMarkupString : '<div></div><div></div>';

                return this._super();
            },

            getMovingHandle: function getMovingHandle() {
                return this.titlebarNode;
            },

            getMovingTarget: function getMovingTarget() {
                return this.editorNode;
            },

            /**
             * Override this to add logic handling data before calling close()
             *
             * @returns {boolean} true if editor should close, false if not.
             */
            onPreClose: function onPreClose() {
                this.hideTooltip();
                return true;
            },

            premousedown: function premousedown(evt) {
                var tgt = evt.getTarget();
                if (tgt === this.closeNode || tgt === this.helpNode) {
                    $CSS.toggleClass(tgt, 'active', true);
                }
            },

            premouseup: function premouseup(evt) {
                var tgt = evt.getTarget();
                if (tgt === this.closeNode || tgt === this.helpNode) {
                    $CSS.toggleClass(tgt, 'active', false);
                }
                // Should we close?
                if (evt.getTarget() === this.closeNode && this.onPreClose()) {
                    this.close();
                }
            },

            onclick: function onclick(evt) {
                if (evt.getTarget() === this.helpNode) {
                    if (mstrApp.showHelpTopic) {
                        mstrApp.showHelpTopic(this.help);
                    } else {
                        window.open(mstrmojo.helpPath() + (this.help || ''), "_blank");
                        return false;
                    }
                }
            },

            // Custom setter in order to set up handlers for resize curtain, center editor and auto close editor.
            _set_visible: function _set_visible(n, v) {
                // Is the new value different?
                var bChanged = (this[n] !== v);
                if (bChanged) {
                    // Update value.
                    this[n] = v;

                    var closeHandler = this._close_handler;

                    // Is the editor visible?
                    if (v) {
                        if (this._curtain_to_body) {
                            this.resizeDialog();
                            this.positionDialog();
                        }

                        // Auto close.
                        if (this.autoClose) {
                            var me = this;

                            closeHandler = this._close_handler = closeHandler || function (evt) {
                                var target = $DOM.eventTarget(self, evt); //TQMS 416177: somehow IE7 would return t as an empty object as event target.
                                if (target && target.parentNode && !$DOM.contains(me.editorNode, target, true, document.body)) {
                                    me.close();
                                }
                            };

                            $DOM.attachEvent(document.body, 'mousedown', closeHandler);
                        }
                    } else {
                        // Do we have a curtain handler?
                        var curtainHandler = this._curtain_handler;
                        if (curtainHandler) {
                            // Detach curtain handler.
                            $DOM.detachEvent(window, 'resize', curtainHandler);
                        }

                        // Do we have a close handler?
                        if (closeHandler) {
                            // Detach close handler.
                            $DOM.detachEvent(document.body, 'mousedown', closeHandler);
                        }
                    }
                }

                return bChanged;
            },

            showTooltip: function showTooltip(e, win) {
                var me = this,
                    t = $DOM.findAncestorByAttr($DOM.eventTarget(win, e), 'tooltip', true, this.domNode),
                    content = t && t.value;

                // Is the tooltip NOT already open or is the menu open?
                if (!me.hasOpenTooltip && content) {
                    var position = $DOM.position(t.node);

                    // Update the content and position
                    me.richTooltip = {
                        cssClass: 'vi-regular A-center vi-tooltip-A',
                        content: content,
                        top: Math.max(position.y + 40, 0),
                        left: Math.max(position.x + 4, 0),
                        posType: mstrmojo.tooltip.POS_TOPCENTER
                    };

                    this._super(e, win);
                }
            }
        }
    );

    /**
     * Effect configuration to fade editor in when opening.
     *
     * @type {Object}
     * @static
     */
    mstrmojo.Editor.openEffect_fadeIn = {
        scriptClass: 'mstrmojo.fx.AnimateProp',
        slot: 'curtainNode',
        props: {
            backgroundColor: {
                start: 255,
                stop: 0,

                //ease: mstrmojo.ease.cos,
                fn: function (v) {
                    v = Math.round(v);
                    return ['rgb(', v, ',', v, ',', v, ')'].join('');
                }
            }
        },

        preStart: function () {
            var target = this.target,
                widget = this.widget;

            widget.editorNode.style.display = 'block';

            if (!widget.modal) {
                return false;
            }

            target.style.display = 'block';
            $CSS.setOpacity(target, 60);

            return true;
        }
    };

    /**
     * Effect configuration to fade editor out when closing.
     *
     * @type {Object}
     * @static
     */
    mstrmojo.Editor.closeEffect_fadeOut = {
        scriptClass: 'mstrmojo.fx.FadeOut',
        slot: 'curtainNode',
        start: 0.6,
        stop: 0,
        preStart: function () {
            var widget = this.widget;
            widget.editorNode.style.display = 'none';

            return !!widget.modal;
        }
    };

    /**
     * Helper function to get a function that destroys an object with given id
     *
     * @param {String} id ID of the object to destroy
     * @returns {Function}
     */
    function getDestroyFn(id) {
        return function () {
            $ALL[id].destroy();
        };
    }

    /**
     * Helper function to handle confirm, warn, alert, error and notify.
     *
     * @param {String} msg Message to display in the dialog.
     * @param {Object} [props] Optional editor properties supplied.
     * @param {String} [title="Notification"] Optional title for the Editor.
     * @param {String} [cssClass] Optional css class to be added. props could also have css class that is supplied the confirm/warn/etc.. caller.
     * @returns {mstrmojo.Editor}
     */
    function createEditor(msg, props, title, cssClass) {
        var id = props.id || 'mojoAlertx9',
            cfg,
            buttons = props.buttons;

        // Add code to each button to destroy the editor.
        $ARR.forEach(buttons, function (btn) {
            var onClickFn = btn.onclick;
            btn.onclick = function (evt) {
                // onclick function could trigger another dialog (like alert),
                // we want to destroy the current dialog, not the one triggered by the onclick function
                // cache the current one to destroy after calling the function
                var currentEditor = $ALL[id];

                // don't close the dialog if the function exquisitely returns false
                if (onClickFn && onClickFn.call(btn, evt) === false) {
                    return;
                }

                // this will destroy the dialog second time if onclick calls another alert dialog (since we destroy alert dialog before opening other)
                // but destroying twice is fine since the second time destroy does not modify the registry (see destroy in obj.js)
                currentEditor.destroy();

                // set to null to avoid memory leak
                currentEditor = null;
            };
        });

        try {
            // There are some scenarios where the alert is being rendered twice
            // and causing an error on id duplication, try to destroy it first.
            !!$ALL[id] && $ALL[id].destroy();
        } catch (ignore) {    }

        // cache the cssClass from props
        var propsClass = props.cssClass,
            css = [];

        // if props has a cssClass,
        if (propsClass) {
            // add it to css
            css.push(propsClass);

            // delete from props so that the constructed css is not overwritten
            delete props.cssClass;
        }

        // if extra css is supplied, add it
        if (cssClass) {
            css.push(cssClass);
        }

        // add basic css for all editors
        css.push('mstrmojo-alert');

        cfg = {
            scriptClass: "mstrmojo.Editor",
            id: id,
            width: '475px',
            zIndex: 1000,
            title: title || mstrmojo.desc(11812, 'Notification'),
            cssClass: css.join(' '),
            children: [
                {
                    scriptClass: 'mstrmojo.Box',
                    cssClass: 'alert-content',
                    children: [
                        {
                            scriptClass: 'mstrmojo.Label',
                            text: msg,
                            allowHTML: props.allowHTML //whether to allow HTML tag in the msg
                        }
                    ]
                }
            ],
            visible: true // set visible to true, otherwise it is initialized to false.
        };

        // Instantiate, render and return editor.
        var editor = new mstrmojo.Editor($HASH.copy(props, cfg));
        editor.render();
        return editor;
    }


    // Do we need to override config and alert with complex dialogs?
    if (window.mstrConfig && !window.mstrConfig.simpleDialog) {

        /**
         * Creates a notification for HTML5 VI with supplied message an an optional cancel button based on the forceClose flag.
         * If forceClose is true, a cancel button will be added and user has to press cancel to dismiss the notification. Otherwise, the
         * notification will close automatically after 6s (or after specified duration).
         *
         * The notification will display right below the toolbar and is NOT modal.
         *
         * @param {String} msg Message to display in the notification
         * @param {Object} [editorProps] Optional editor properties
         * @param {Object} [config] Optional notification properties
         * @param {boolean} [config.forceClose] Flag to specify whether to provide cancel button
         * @param {int} [config.duration] Time to wait before closing the notification (will NOT be used if forceClose is true)
         * @param {Function} [config.callback] Function to be called when: the notification closes automatically (forceClose = false) OR when user presses Dismiss button (forceClose = true)
         * @param {String} [config.buttonText] Text to display on the button (forceClose = true)
         */
        mstrmojo.notify = function notify(msg, editorProps, config) {

            config = config || {};

            // create props specific to notification
            var forceClose = config.forceClose,
                callback = config.callback || mstrmojo.emptyFn,
                props = $HASH.copy(editorProps || {}, {
                    buttons: forceClose ? [ mstrmojo.Button.newActionButton((config.buttonText || mstrmojo.desc(8607, "Dismiss")), callback)] : null,
                    showTitle: false,
                    modal: false,
                    top: '42px'
                }),
                time = config.duration || 6000;

            // call dialog handler and get the editor created
            var editor = createEditor(msg, props, '', forceClose ? 'ed-notify' : 'ed-toast'),
                id = editor.id;

            // destroy the notification automatically after certain time if not forceClose
            if (!forceClose) {
                window.setTimeout($FUNC([callback, getDestroyFn(id)]), time);
            } else { // else, just decrease the opacity after 6s (time not configurable)
                window.setTimeout(function () {
                    // check if the notification is still there (user might have pressed cancel in 6s)
                    if ($ALL[id]) {
                        $ALL[id].editorNode.style.opacity = 0.75; //
                    }
                }, 6000);
            }

            // Return the editor back to the caller.
            return editor;
        };

        /**
         * Shows a Notification dialog to the user with a message and two buttons. If your dialog has only an OK button, please user mstrmojo.alert
         * First button is for confirming the action and the second button to cancel the action.
         * If no button configs are provided, Yes and No buttons are added by default.
         * If button configs are provided without text, "Yes" and "No" will be default text for the buttons.
         * If you need more than two buttons, custom buttons can be added to editorProps.buttons.
         *
         * @param {String} msg The message to display
         * @param {{confirmBtn: mstrmojo.Editor.ButtonConfigType, cancelBtn: mstrmojo.Editor.ButtonConfigType}} buttonConfigs Object containing confirm and cancel button configs
         * @param {Object=} editorProps Optional object of properties to be added.
         *
         * @memberOf mstrmojo
         * @overrides
         */
        mstrmojo.confirm = function confirm(msg, buttonConfigs, editorProps) {

            buttonConfigs = buttonConfigs || {};

            var confirmBtn = buttonConfigs.confirmBtn || {},
                cancelBtn = buttonConfigs.cancelBtn || {},
                isConfirmHot = confirmBtn.hot !== false,
                isCancelHot = !!cancelBtn.hot,
                title = editorProps && editorProps.title,
                buttons = [ $NWB(confirmBtn.t || mstrmojo.desc(219, "Yes"), confirmBtn.fn, isConfirmHot, confirmBtn.cfg), $NWB(cancelBtn.t || mstrmojo.desc(218, "No"), cancelBtn.fn, isCancelHot, cancelBtn.cfg)];

            // crate the dialog and display
            return createEditor(msg, $HASH.copy(editorProps || {}, {
                buttons: buttons,
                onPreClose: function () {//we need to handle the 'x' on the top right corner as the same function of cancel
                    if (cancelBtn && cancelBtn.fn) {
                        cancelBtn.fn();
                    }
                    return true;
                }
            }), title, $DIHELPER.getEnvObj().isStandaloneDataSet() ? ['error-dialogue-in-dataset'] : []);
        };

        /**
         * Same as confirm, but with extra exclamation icon on left of the message.
         * If you need more than two buttons, custom buttons can be added to editorProps.buttons.
         *
         * @param {String} msg The message to display
         * @param {{confirmBtn: mstrmojo.Editor.ButtonConfigType, cancelBtn: mstrmojo.Editor.ButtonConfigType}} buttonConfigs Object containing confirm and cancel button configs
         * @param {Object} [editorProps] Optional object of properties to be added.
         */
        mstrmojo.warn = function warn(msg, buttonConfigs, editorProps) {

            // add an extra css class for warning, this css differentiates warn from confirm
            editorProps = editorProps || {};
            editorProps.cssClass = (editorProps.cssClass || "") + " mstrmojo-warning";

            // create the warning and display
            return mstrmojo.confirm(msg, buttonConfigs, editorProps);
        };

        /**
         * Overrides default {@link mstrmojo.config} method to use mstrmojo.Editor for displaying a message to the user with a single 'OK' button.
         * Use when need to show a message with an OK button.
         *
         * @param {String} msg The message to display.
         * @param {Function} [fn] An optional function to be executed after the 'OK' button is clicked.
         * @param {String} [title="Notification"] An optional title for the editor.
         * @param {int} [zIndex=1000] An optional zIndex for the editor.
         * @param {String} [cssClass] An optional CSS class for the editor.
         * @param {Object} [editorProps] Optional object of properties to be added.
         *
         * @memberOf mstrmojo
         * @overrides
         */
        mstrmojo.alert = function alert(msg, fn, title, zIndex, cssClass, editorProps) {

            // copy the properties to an object
            var props = {
                title: title || mstrmojo.desc(12405, 'Alert'),
                zIndex: zIndex,
                cssClass: cssClass,
                buttons: [ $NWB(mstrmojo.desc(1442, 'OK'), fn, true)],
                onPreClose: function () {//alert only has one button, we need to handle the 'x' on the top right corner as the same function of ok
                    if (fn) {
                        fn();
                    }
                    return true;
                }
            };

            // delete if any of them are not defined as createEditor has defaults
            $HASH.forEach(props, function (value, key) {
                if (!value) {
                    delete props[key];
                }
            });

            // Create the alert editor, render and return it.
            return createEditor(msg, $HASH.copy(editorProps, props), title, $DIHELPER.getEnvObj().isStandaloneDataSet() ? ['error-dialogue-in-dataset'] : []);
        };

        /**
         * Creates an alert dialog with title as "Error". This will need a short description and a long description for the error to display.
         * Use when showing Error messages.
         *
         * @param {Object} errorInfo Object with error info:
         * @param {String} [errorInfo.shortDesc="An error has occurred"] Short description for the error (ex: "Cube not published").
         * @param {String} [errorInfo.longDesc] Optional long description for the error.
         * @param {Function} fn Function to execute when OK button is clicked.
         * @param {Object} editorProps Optional properties to add for the error (example: title, buttons,css class)
         */
        mstrmojo.error = function error(errorInfo, fn, editorProps) {

            var info = errorInfo || {};
            var title =  mstrmojo.desc(96, "Error");
            var enableContactStr = !($DIHELPER.getEnvObj().isInDI() || $DIHELPER.getEnvObj().isInQB()); //Do not show in DI

            if (editorProps) {
                title = (editorProps.title) ? editorProps.title :  mstrmojo.desc(96, "Error");
                editorProps.title = title;
                if (editorProps.enableContactStr === false) {
                    enableContactStr = false;
                }
            }

            // create dialog and display
            createEditor('', $HASH.copy(editorProps || {}, {
                buttons: [ $NWB(mstrmojo.desc(1442, "OK"), fn, true)],
                children: [
                    {
                        scriptClass: 'mstrmojo.ui.editors.ErrorDialogContent',
                        shortDesc: info.shortDesc,
                        longDesc: info.longDesc,
                        showToggle: !!(info.longDesc),
                        enableContactStr: enableContactStr,
                        // please go to DIRootController.js->displayError functionality for reference.
                        allowHTML: !!(editorProps && editorProps.allowHTML === true)
                    }
                ]
            }), title, $DIHELPER.getEnvObj().isStandaloneDataSet() ? ['error-dialogue-in-dataset'] : []);
            //DE75242 vi.css on web will not include those scss file without -ws suffix, while data-import.css does
        };
    }

    /**
     * @typedef {{
     *     t: String,
     *     fn: Function,
     * }}
     *
     * You can also provide any other properties of mstrmojo.Button.
     *
     * @property {String} t Text to display on the button.
     * @property {Function} fn Function to execute when this button is pressed.
     */
    mstrmojo.Editor.ButtonConfigType = null;

}());
/**
 * Created by fding on 8/19/2016.
 */
(function () {
    mstrmojo.requiresCls("mstrmojo.Editor",
        "mstrmojo.css",
        "mstrmojo.Button",
        "mstrmojo.TextBox",
        "mstrmojo.imageUtils",
        "mstrmojo.ui.editors.controls.TwoColumnContainer",
        "mstrmojo.vi.ui.CoverPageGallery",
        "mstrmojo.vi.ui.rw.selectors._HasWarningMessage");

    mstrmojo.requiresDescs(15020, 15021, 15025, 15131, 15132);

    var $NWB = mstrmojo.Button.newWebButton,
        CSS = mstrmojo.css,
        IMG_UTILS = mstrmojo.imageUtils,
        EDITOR_CONTENT_WIDTH = '380px',
        BASE_URL = 'https://demo.microstrategy.com/MicroStrategy/images/Coverpages/16-9/',
        IMAGE_NAME = [
            '22.jpg', '23.jpg', '24.jpg', '25.jpg', '26.jpg',
            '27.jpg', '28.jpg', '29.jpg', '30.jpg', '31.jpg',
            '32.jpg', '33.jpg', '34.jpg', '35.jpg', '36.jpg',
            '37.jpg', '38.jpg', '39.jpg', '40.jpg', '41.jpg',
            '42.jpg', '43.jpg', '44.jpg', '45.jpg', '46.jpg',
            '47.jpg', '48.jpg', '49.jpg', '50.jpg', '51.jpg',
            '52.jpg', '53.jpg'
        ],
        GALLERY_LIST = [];
    IMAGE_NAME.forEach(function (imageName) {
        GALLERY_LIST.push({src: BASE_URL + imageName});
    });

    /**
     * Private helper function to call when save is triggered.
     */
    function saveTriggered() {
        var coverPageEditor = this,
            url = coverPageEditor.urlBox.value;
        coverPageEditor.hideWarning();
        coverPageEditor.onSave(url, url !== coverPageEditor.originURL, coverPageEditor.urlAccesible);
        coverPageEditor.afterSave();
    }
    /**
     * <p>A simple editor used to allow the user to enter the desired name and rename any object.</p>
     *
     * @class
     * @extends mstrmojo.Editor
     */
    mstrmojo.vi.ui.editors.CoverPageEditor = mstrmojo.declare(
        mstrmojo.Editor,

        [mstrmojo.vi.ui.rw.selectors._HasWarningMessage],

        /**
         * @lends mstrmojo.ui.editors.CoverPageEditor.prototype
         */
        {
            scriptClass: "mstrmojo.vi.ui.editors.CoverPageEditor",

            cssClass: "mstrmojo-vi-ui-editors-CoverPageEditor",

            btnAlignment: 'right',

            /**
             * Alias for the rename box of the rename editor.
             *
             * @ignore
             */
            urlBox: undefined,

            /**
             * The text to initialize the text box to.
             *
             * @type {String}
             */
            originURL: '',

            title: mstrmojo.desc(15020, "Change Cover"),

            urlAccesible: true,
            
            /**
             * DE112496 The flag to indicate whether to show tooltip or not. Help to escape showing tooltip when "save" or "cancel" button got hitted.
             *
             * @type {Boolean}
             */
            isTooltipAllowed: true,

            init: function init(props) {
                // Call super
                this._super(props);
                this.bindWarningHandler(this);
            },

            postBuildRendering: function() {
                if(this._super) {
                    this._super();
                }
                this.urlBox.focus();
            },

            children: [
                {
                    scriptClass: "mstrmojo.Label",
                    text: mstrmojo.desc(15131, 'Paste an image URL:')
                },
                {
                    scriptClass: 'mstrmojo.TextBox',
                    alias: 'urlBox',
                    cssClass: 'urlBox',
                    width: EDITOR_CONTENT_WIDTH,

                    //DE112496 change the logic for tooltip here.
                    onEnter: function onEnter() {
                        if (this._super) {
                            this._super();
                        }
                        var me = this,
                            coverPageEditor = me.parent;

                        coverPageEditor.hideWarning();
                        IMG_UTILS.isImageAccessible(this.value, {
                            success: function () {
                                coverPageEditor.urlAccesible = true;
                            },
                            failure: function () {
                                coverPageEditor.urlAccesible = false;
                                coverPageEditor.set('validation', {
                                    refNode: me.domNode,
                                    position: 2,
                                    invalid: true,
                                    errorMsg: mstrmojo.desc(15021, 'Sorry, this image cannot be loaded, either because the URL is not valid, or there is no internet connection. Please enter a valid URL, and make sure the internet is connected.'),
                                    errorCode: null,
                                    //DE112496 to keep it open after click on blank space
                                    closeOnClick: false
                                });
                            }
                        });
                        coverPageEditor.gallery.set('selectedImgURL', this.value);
                    },

                    onvalueChange: function onvalueChange() {
                        if (this._super) {
                            this._super();
                        }
                        var me = this,
                            coverPageEditor = me.parent;

                        coverPageEditor.hideWarning();
                        coverPageEditor.btnHbox.saveButton.set("enabled",true);
                    },

                    //DE112496 clicking on blank space can also stimulate validation as pressing Enter.
                    onblur: function onblur() {
                        var coverPageEditor = this;
                        //Timeout is to wait for the button event be triggered.
                        window.setTimeout(function() {
                            if(coverPageEditor.parent.isTooltipAllowed){
                                coverPageEditor.onEnter();
                            }
                        },200);
                    }
                },

                {
                    scriptClass: "mstrmojo.Label",
                    text: mstrmojo.desc(15132, 'or select a sample image:')
                }, {
                    scriptClass: "mstrmojo.vi.ui.CoverPageGallery",
                    height: '320px',
                    width: EDITOR_CONTENT_WIDTH,
                    alias: 'gallery',
                    onimageSelected: function onimageSelected(src) {
                        var coverPageEditor = this.parent;
                        coverPageEditor.urlBox.set('value', src);
                        CSS.toggleClass(coverPageEditor.urlBox.domNode, 'changing', false);
                        if (window.requestAnimationFrame) {
                            window.requestAnimationFrame(function () {
                                CSS.toggleClass(coverPageEditor.urlBox.domNode, 'changing', true);
                            });
                        }
                    }
                }
            ],

            buttons: [
                $NWB(mstrmojo.desc(118, "Save"), function () {
                    var coverPageEditor = this.parent.parent;
                    //DE112496 not trigger tooltip when button is hitted
                    coverPageEditor.isTooltipAllowed = false;
                    //to determine the value for "urlAccesible"
                    IMG_UTILS.isImageAccessible(coverPageEditor.urlBox.value, {
                        success: function () {
                            coverPageEditor.urlAccesible = true;
                        },
                        failure: function () {
                            coverPageEditor.urlAccesible = false;
                        }
                    });
                    window.setTimeout(function() {
                        saveTriggered.call(coverPageEditor);
                    },50);
                }, true, {alias: 'saveButton'}),

                $NWB(mstrmojo.desc(221, "Cancel"), function () {
                    // Close the editor
                    var coverPageEditor = this.parent.parent;
                    coverPageEditor.isTooltipAllowed = false;
                    coverPageEditor.onCancel();
                    coverPageEditor.afterCancel();
                })
            ],

            onOpen: function onOpen() {
                this.gallery.set('imageList', GALLERY_LIST);
                this.urlBox.set('value', this.originURL);
                //DE112496 disable the save button when starting
                this.btnHbox.saveButton.set("enabled",false);
                this.isTooltipAllowed = true;
            },


            /**
             * Custom hook when save is triggered.
             *
             * @param {String} url the url in the textbox
             * @param {Boolean} whether the url is different from the original one
             * @param {isAccessible} whether the url is accessible
             */
            onSave: mstrmojo.emptyFn,

            afterSave: mstrmojo.emptyFn,

            onCancel: mstrmojo.emptyFn,

            afterCancel: mstrmojo.emptyFn,
            //DE112496 add a hidewarning function here
            close: function close() {
                this._super();
                this.hideWarning();
            }
        }
    );
}());

